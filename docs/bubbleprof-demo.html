
      <!DOCTYPE html>
      <meta charset="utf8">
      <meta name="viewport" content="width=device-width">
      <title>Clinic Bubbleprof</title>
      <link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABiVBMVEUAAADsHCt5fH7/CxwWzsXsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvuGinvGinsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvnIC9ygoNzgYLJOUTtHCvsHCvsHCvsHCvsHCvsHCvsHCvtGyu+Q0x4fX95fH6CdHfuGinsHCvsHCvsHCvsHCvsHCvoHy51gIF3foCkWF/tHCvsHCvuGinyFyftGyrsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvsHCvuGiryFibuGirsHCvsHCvsHCvsHCvtGyqLbXF3fX93foDsHCvsHCvsHCvsHCvsHCvvGil5fH55fH54fH66Rk/wGCjsHCvsHCvsHCvsHCvsHCvtGyqzTFR4fX95fH55fH7sHCvsHCvsHCv///90Vl8fAAAAgXRSTlMAAAAAAAhOref9/tw7BRuX8bUzs3wDt51E9rYaEweZ2m9gvd0/QjCElk/iTlpzM9bSJXn58K/eMM7yPK/1Q6qs9FBVbxa75kMcOVTohl1S6Yde5FnrXONLW+Cp38XhSjYSXYxmN9usFW9GaZMMz/KaSPu9GBEEZX811cYyh1kBY1ipN6EoAAAAAWJLR0SCi7P/RAAAAAd0SU1FB+ADBwwMDzX3WLIAAADtSURBVBjTY2BgYGRlY+fg5OLmYeVlZAByGfn4BRqBQFBIWEQUKMLIJ9YIBuISklLSMowMsnLyCopKQAFlFVU1dQ1WBk0tbR1dPX2giIGhkbEJG4OpmbmFpZU1UMDG1q6x0Z6Bw8HRydnFFSbgxsDZyO3u4enlDRXgBAo0+vi6+Xn5wwQ4GhsDAhuD2IJDJCFa7IEqQrkaw8IjIlWjQIaymURLGMY0NsbGxSckhgCtZU3y0kxOSW1sTEvPyMzKZmVgzOHLzeMxbWzMLygsKi4Beaa0rLyisrGxqrqmto6JAexfxno3Ts6gBmYWIB8A6xBC908vTlMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTYtMDMtMDdUMTI6MTI6MTUrMDE6MDBIIWgPAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE2LTAzLTA3VDEyOjEyOjE1KzAxOjAwOXzQswAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAABXelRYdFJhdyBwcm9maWxlIHR5cGUgaXB0YwAAeJzj8gwIcVYoKMpPy8xJ5VIAAyMLLmMLEyMTS5MUAxMgRIA0w2QDI7NUIMvY1MjEzMQcxAfLgEigSi4A6hcRdPJCNZUAAAAASUVORK5CYII=">
      <style>html {
  /* Define colors */
  --main-bg-color: rgb(27, 30, 39);
  --overlay-bg-color: rgba(55, 61, 79, 0.94);
  --main-bg-translucent: rgba(27, 30, 39, 0.94);

  --banner-bg-color: rgb(41, 45, 57);
  --banner-logo-color: rgba(255, 255, 255, 0.87);

/* Matches --banner-bg-color when overlaid over --main-bg-color */
  --lighten-bg-color: rgba(212, 224, 255, 0.08);

  --nearform-red: rgb(237,24,40);
  --nearform-grey: rgb(121,122,124);

  --grey-highlight: rgb(191,192,194);

  --pure-white: rgb(255, 255, 255);
  --pure-black: rgb(0, 0, 0);
  --translucent-black: rgba(0, 0, 0, 0.86);

  --cyan-bright: rgb(166, 228, 255);
  --cyan-highlight: rgb(96, 147, 208);
  --cyan: rgb(63, 125, 198);

  --party-colour-1: var(--cyan-bright);
  --party-colour-2: var(--cyan);
  --party-colour-3: var(--nearform-grey);

  --type-colour-1: rgb(173, 102, 71); /* Rusty orange */
  --type-colour-2: rgb(0, 209, 168); /* Pale green */
  --type-colour-3: rgb(211, 166, 255); /* Pale lilac */
  --type-colour-4: rgb(102, 69, 181); /* Deep purple */
  --type-colour-5: rgb(252, 255, 123); /* Pale yellow */

  /* Define simple SVG icons */
  --down-white-chevron-arrow: url('data:image/svg+xml;utf8,<svg fill="rgb(255,255,255)" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>');
  --down-cyan-chevron-arrow: url('data:image/svg+xml;utf8,<svg fill="rgb(63,125,198)" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>');

  /* Define text sizes */
  --main-text-size: 10pt;

  /* Define element sizes used in calculations by other elements */
  --banner-height: 65px;
  --footer-height: 65px;
  --header-height: 65px;
}

/* Main layout */

html, body {
  border: 0;
  margin: 0;
  padding: 0;
}

body {
  background: var(--main-bg-color);

  /* To resolve inconsistent browser issues:
   * - Chrome flashes an empty y scrollbar inconstently on some events in sublayouts
   * - Firefox adds an empty x scrollbar to sublayouts */
  overflow-y: scroll;
  overflow-x: hidden;
}

/* Global Typography */

html {
  font-family: sans-serif;
}

html * {
  box-sizing: border-box;
}

html #banner, html #header, html #node-link, html #side-bar, html #footer {
  /* Light text on dark background in the browser looks blocky. To make it smoother
     and clearer, we use antialiased font rendering in dark theme. More details,
     especially on why this is a bad idea for dark text on light backgrounds:
       http://usabilitypost.com/2012/11/05/stop-fixing-font-smoothing/
  */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html.light-theme #header, html.light-theme #node-link, html.light-theme #side-bar {
  -webkit-font-smoothing: unset;
  -moz-osx-font-smoothing: unset;
}

.hidden {
  display: none;
}

.collapsed .collapsible-content-wrapper {
  display: none;
}

a.external-link:link,
a.external-link:visited {
  color: var(--cyan);
  text-decoration: none;
}

a.external-link:after {
  display: inline-block;
  content: '⬈';
  border-left: 1px solid var(--cyan);
  border-bottom: 1px solid var(--cyan);
  padding-bottom: 5px;
  height: 5px;
  width: 5px;
  vertical-align: middle;
  box-sizing: border-box;
  margin: 0 4px 0 5px;
  line-height: 0px;
}

/* Banner layout */

#banner {
  display: flex;
  align-items: center;
  height: var(--banner-height);
  background: var(--banner-bg-color);
  position: relative;
}

#banner svg {
  fill: var(--banner-logo-color);
  margin-left: 12px;
}

#banner a:last-child svg {
  position: absolute;
  height: 40px;
  right: 28px;
  top: 13px;
}

main {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
}

/* Header */

#header {
  width: 100%;
  margin: 0 24px;
  border-bottom: 1px solid var(--cyan);
  font-size: var(--main-text-size);
  height: var(--header-height);
  position: sticky;
  top: 0;
  z-index: 11;
  background: var(--main-bg-color);
}

#header .header-bar {
  display: block;
  width: 100%;
  margin-top: 6px;
  margin-bottom: 6px;
  display: flex;
  flex-direction: row;
}

#header .panel {
  margin: 0 12px;
}

#header .panel > label {
  color: var(--cyan);
}

#header .highlight-bar {
  justify-content: space-between;
  margin-bottom: 3px;
}

#header .breadcrumb-bar {
  margin-top: 0;
  white-space: nowrap;
  overflow-x: hidden;
}

#header .panel.breadcrumbs-panel {
  margin: 0 6px;
}

#header .breadcrumb-bar:hover,
#header .breadcrumb-bar:focus,
#header .breadcrumb-bar:active {
  overflow-x: auto;
}

#header .breadcrumb {
  display: inline-block;
  margin-top: 3px;
  padding: 3px 6px;
  background-color: var(--pure-black);
}

#header .breadcrumb:hover {
  cursor: pointer;
}

#header .breadcrumb-separator {
  margin-left: 5px;
  margin-right: 5px;
}

#header .interactive-key {
  display: inline-block;
  margin: 0 3px;
  padding: 2px 2px 4px 2px;
  border-bottom: 1px solid transparent;
}

#header .interactive-key label {
  color: var(--pure-white);
  display: inline-block;
  vertical-align: middle;
}

#header .hover-box {
  display: flex;
  flex-direction: column-reverse;
  color: var(--grey-highlight);
  width: 255px;
  margin-left: -25px;
  margin-top: -12px;
}

#header .hover-box.hidden {
  display: none;
}

#header .hover-box .title-block.by-variable {
  border-bottom-style: solid;
  border-bottom-width: 1px;
}

#header .hover-box .collapse-control {
  color: var(--pure-white);
  cursor: pointer;
}

#header .hover-box a:link,
#header .hover-box a:visited {
  color: var(--cyan);
  text-decoration: none;
}

#header .hover-box a:hover,
#header .hover-box a:focus {
  color: var(--cyan-highlight);
}

#header .hover-box .collapsible-content-wrapper {
  padding-top: 14px;
}

#header .hover-box .collapsible-content-wrapper ul {
  padding-left: 16px;
  margin-bottom: 0;
}

#header .help-link-block {
  position: absolute;
  right: 0;
  background: var(--main-bg-translucent)
  border-radius: 6px;
}

#header .help-link-block .help-link {
  padding: 3px;
  display: block;
  font-weight: bold;
  text-decoration: none;
  outline: 4px solid var(--banner-bg-color);
}

#header .help-link-block .help-link:before {
  content: 'How to use this';
}

/* unvisited link only */
#header .help-link-block .help-link:link {
  animation-name: pulseLink;
  color: var(--pure-white);
  background-color: var(--banner-bg-color);
}

#header .help-link-block .help-link:link:after {
  animation-name: pulseIcon;
  color: var(--pure-white);
  border-left-color: var(--pure-white);
  border-bottom-color: var(--pure-white);
}

#header .help-link-block .help-link:link,
#header .help-link-block .help-link:link:after {
  animation-direction: alternate;
  animation-duration: 0.8s;
  animation-iteration-count: 8;
  animation-timing-function: ease-in-out;
}


#header .help-link-block .help-link:visited {
  background-color: var(--main-bg-color) !important;
  outline-color: var(--main-bg-color) !important;
  color: var(--cyan) !important;

  /* :visited can't apply animation-name: none; */
}

#header .help-link-block .help-link:visited:after {
    color: var(--cyan);
    border-left-color: var(--cyan);
    border-bottom-color: var(--cyan);
  /* :visited can't apply animation-name: none; */
}

@keyframes pulseLink {
  100% {
    background-color: var(--main-bg-color);
    color: var(--cyan);
    outline-color: var(--main-bg-color);
  }
}
@keyframes pulseIcon {
  100% {
    color: var(--cyan);
    border-left-color: var(--cyan);
    border-bottom-color: var(--cyan);
  }
}

.type-icon,
.party-icon {
  display: inline-block;
  vertical-align: middle;
  /* width and colour are set in js and type/party-specific CSS */
  border-top-style: solid;
  width: 11px;
  margin: 4px;
  height: 1px;
}

body[data-highlight-party='user'] #header .interactive-key.party-user,
body[data-highlight-party='external'] #header .interactive-key.party-external,
body[data-highlight-party='nodecore'] #header .interactive-key.party-nodecore,
body[data-highlight-type='files-streams'] #header .interactive-key.type-files-streams,
body[data-highlight-type='networks'] #header .interactive-key.type-networks,
body[data-highlight-type='crypto'] #header .interactive-key.type-crypto,
body[data-highlight-type='timing-promises'] #header .interactive-key.type-timing-promises,
body[data-highlight-type='other'] #header .interactive-key.type-other {
  border-bottom-color: var(--cyan);
}

body[data-highlight-party='user'] #header .interactive-key.party-user .party-icon,
body[data-highlight-party='external'] #header .interactive-key.party-external .party-icon,
body[data-highlight-party='nodecore'] #header .interactive-key.party-nodecore .party-icon,
body[data-highlight-type='files-streams'] #header .interactive-key.type-files-streams .type-icon,
body[data-highlight-type='networks'] #header .interactive-key.type-networks .type-icon,
body[data-highlight-type='crypto'] #header .interactive-key.type-crypto .type-icon,
body[data-highlight-type='timing-promises'] #header .interactive-key.type-timing-promises .type-icon,
body[data-highlight-type='other'] #header .interactive-key.type-other .type-icon {
  border-top-width: 4px !important;
}

/* Footer */

#footer {
  position: fixed;
  width: 100%;
  bottom: 0;
  z-index: 12;
  display: flex;
  flex-direction: row-reverse;
}

#footer.collapsed {
  z-index: 2;
}

#footer .bar {
  width: 25%;
  background: var(--cyan);
}

#footer .bar {
  display: flex;
}

#side-bar .bar, /* #side-bar .bar is invisible unless in portrait view appears in footer */
#footer .bar {
  border-top: 1px solid var(--cyan-highlight);
  overflow: hidden;
  cursor: pointer;
  height: var(--footer-height);
  flex-direction: row-reverse;
  justify-content: flex-end;
}

#side-bar .bar .text,
#footer .bar .text {
  font-size: 14pt;
  font-variant: all-small-caps;
  font-weight: bold;
  color: var(--pure-white);
  line-height: 64px;
}

#side-bar .bar .arrow,
#footer .bar .arrow {
  margin: 16px 10px;
  height: 34px;
  width: 34px;
  background-image: var(--down-white-chevron-arrow);
  background-size: cover;
  transform: rotate(270deg);
}

#footer.collapsed .bar .arrow {
  transform: rotate(90deg)
}

#footer-inner {
  background: var(--overlay-bg-color);
  position: fixed;
  bottom: 0;
  left: 0;
  width: 75%;
  overflow-y: auto;
  max-height: calc(50vh - var(--footer-height));
  padding: 8px 0;
}

#frames-panel {
  margin: 18px 0;
  padding: 0px 28px;
  color: var(--pure-white);
  font-size: var(--main-text-size);
}

#frames-panel .heading {
  margin: 12px 0;
}

#frames-panel .heading {
  margin: 12px 0;
}

#frames-panel .jump-to-node {
  display: block;
  float: right;
  font-weight: bold;
  color: var(--cyan);
  cursor: pointer;
  margin-right: 32px;
}

#frames-panel .sub-collapse-control {
  cursor: pointer;
  color: var(--cyan);
}

#frames-panel .this-node > .sub-collapse-control {
  font-weight: bold;
  color: var(--cyan-highlight);
}

#frames-panel .user > .sub-collapse-control {
  color: var(--cyan-highlight);
}

#frames-panel .this-node > .sub-collapse-control:hover,
#frames-panel .this-node > .sub-collapse-control:focus,
#frames-panel .user > .sub-collapse-control:hover,
#frames-panel .user > .sub-collapse-control:focus {
  color: var(--cyan-bright);
}

#frames-panel .sub-collapse-control:hover,
#frames-panel .sub-collapse-control:focus,
#frames-panel .jump-to-node:hover,
#frames-panel .jump-to-node:focus {
  color: var(--cyan-highlight);
}

#frames-panel .collapsed .frame-group .sub-collapse-control {
  display: none;
}

#frames-panel .collapsed .frame-item {
  display: none;
}

#frames-panel .frame-group .delays {
  font-weight: normal;
  color: var(--grey-highlight);
  padding-bottom: 3px;
  margin: 0;
}

#frames-panel .frame-group .delays .figure {
  color: var(--pure-white);
}

#frames-panel .frame-group.node-frame-group {
  padding: 3px 0 0 3px;
}

#frames-panel .node-frame-group .frame-group,
#frames-panel .frame-group .delays {
  border-left: 1px solid var(--nearform-grey);
  margin-left: 3px;
  padding-left: 15px;
}

#frames-panel .frame-group.collapsed .delays {
  border-left: none;
}

#frames-panel .frame-group:not(.collapsed) .frame-group:last-child,
#frames-panel pre.frame-item:last-child {
  padding-bottom: 9px;
}

#frames-panel .frame-item {
  margin: 0 0 0 4px;
  padding: 4px 0;
}

#frames-panel pre.frame-item {
  white-space: pre-wrap;
  padding-left: 14px;
}

#frames-panel div.frame-item {
  padding: 8px 20px;
}

#frames-panel .frame-group .frame-item {
  border-left: solid 1px var(--cyan);
}

#frames-panel .collapsed .sub-collapse-control .arrow {
  transform: rotate(90deg);
}

#frames-panel .sub-collapse-control .arrow {
  display: inline-block;
  margin: 0 6px -3px -3px;
}

#footer .close:before {
  content: '×';
}

#side-bar .close,
#footer .close {
  width: 24px;
  height: 24px;
  position: sticky;
  top: 0;
  float: right;
  display: block;
  line-height: 14px;
  font-size: 30px;
  cursor: pointer;
  color: var(--cyan-highlight);
}

/* View modes: 'maximised', 'fit', 'scroll'; */

body[data-view-mode='fit'] #node-link {
  position: sticky;
  top: var(--header-height);
  max-height: calc(100vh - var(--banner-height) - var(--header-height));
  min-height: calc(100vh - var(--banner-height) - var(--header-height));
}

/* New style node-link diagram and container */

svg.bubbleprof .node-group {
  cursor: pointer;
}

svg.bubbleprof .outer-path {
  fill: var(--lighten-bg-color);
  stroke: none;
}

svg.bubbleprof .node-group .text-label {
  font-size: 10pt;
  dominant-baseline: middle;
  text-anchor: middle;
  font-weight: normal;
}

svg.bubbleprof .node-group .on-line-label {
  text-anchor: middle
}

svg.bubbleprof .node-group .endpoint-label {
  text-anchor: start;
  opacity: 0.8;
}

svg.bubbleprof .node-group .flipped-label {
  text-anchor: end;
}

svg.bubbleprof .node-group .smaller-label {
  font-size: 9pt;
  opacity: 0.6;
}

svg.bubbleprof .node-group .time-label {
  font-size: 8pt;
}

svg.bubbleprof .node-group .lower-label {
  dominant-baseline: text-before-edge;
}

svg.bubbleprof .node-group .upper-label {
  dominant-baseline: auto;
}

svg.bubbleprof .node-group.shortcut .outer-path {
  fill: var(--translucent-black);
}

svg.bubbleprof .node-group.shortcut .name-label {
  font-size: 9pt;
}

svg.bubbleprof .node-group .inner-circle {
  fill: var(--main-bg-color);
  stroke: none;
}

/* Node-link diagram and container

svg.bubbleprof text.text-label {
  text-anchor: middle;
}

svg.bubbleprof .bubble-wrapper .time-label {
  dominant-baseline: middle;
}

svg.bubbleprof .bubble-wrapper .name-label {
  dominant-baseline: text-after-edge;
}

svg.bubbleprof .bubble-wrapper .name-label.flipped-label {
  dominant-baseline: text-before-edge;
}

svg.bubbleprof .name-label {
  font-weight: bold;
  font-size: 11pt;
}

svg.bubbleprof .bubble-wrapper text.name-label.pointing-right {
  text-anchor: start;
  dominant-baseline: middle;
}

svg.bubbleprof .bubble-wrapper text.name-label.pointing-left {
  text-anchor: end;
  dominant-baseline: middle;
}

svg.bubbleprof .below-threshold-1 .name-label {
  font-size: 10pt;
  opacity: 0.9;
}

svg.bubbleprof .below-threshold-2 .name-label {
  font-size: 9pt;
  opacity: 0.8;
}

svg.bubbleprof .below-threshold-3 .name-label {
  font-size: 8pt;
  opacity: 0.7;
}

svg.bubbleprof .time-label {
  font-size: 8pt;
  font-weight: bold;
  paint-order: stroke fill;
  stroke: var(--main-bg-color);
  stroke-width: 4px;
  stroke-opacity: 0.9;
}

svg.bubbleprof .link-wrapper .time-label {
  dominant-baseline: hanging;
}

svg.bubbleprof .below-threshold-1.bubble-wrapper .time-label {
  display: none;
}

svg.bubbleprof .bubble-wrapper,
svg.bubbleprof .link-wrapper {
  cursor: pointer;
}

svg.bubbleprof .bubble-wrapper .bubble-outer {
  fill: var(--pure-black);
  cursor: pointer;
}

svg.bubbleprof .bubble-wrapper .bubble-inner {
  fill: var(--main-bg-color);
  stroke: none;
}

svg.bubbleprof .bubble-wrapper.below-threshold-2 .bubble-inner {
  opacity: 0;
}

svg.bubbleprof .link-outer {
  fill: var(--pure-black);
  cursor: pointer;
}
*/

#sublayout-svg {
  position: absolute;
  background: var(--main-bg-color);
  top: 0;
}

#node-link {
  position: relative;
  width: 75%;
  z-index: 10;
}

#node-link:hover, #node-link:focus {
  /* hover boxes above #header when focus on this */
  z-index: 11;
}

#node-link .sublayout {
  z-index: 11;
}

#node-link.redraw {
  z-index: 1;
}

#node-link .sublayout .close-btn {
  display: block;
  top: 8px;
  right: 8px;
  height: 40px;
  background: var(--pure-black);
  color: var(--cyan);
  z-index: 20;
  position: absolute;
  padding: 2px 11px;
  line-height: 32px;
  font-size: 28px;
  cursor: pointer;
}

#node-link .back-btn {
  display: block;
  top: 8px;
  left: 30px;
  width: 40px;
  height: 40px;
  background: var(--pure-black);
  background-image: var(--down-cyan-chevron-arrow);
  background-size: cover;
  transform: rotate(270deg);
  z-index: 20;
  position: absolute;
  padding: 2px 11px;
  line-height: 32px;
  font-size: 28px;
  cursor: pointer;
}

#node-link .back-btn.hidden {
  display: none;
}

/* Temporary fix to https://github.com/nearform/node-clinic-bubbleprof/issues/92 for sublayouts */
section.sublayout:not(:last-child),
svg#node-link-svg:not(:nth-last-child(2)) {
  visibility: hidden;
}

/* Sidebar */

#side-bar {
  width: 25%;
  margin: 16px 0 89px 0;
  padding: 0 24px 0 16px;
  border-left: 1px solid var(--cyan);
  font-size: var(--main-text-size);
  color: var(--nearform-grey);
}

#side-bar .side-bar-item .collapse-control {
  cursor: pointer;
  color: var(--pure-white);
  border-bottom: 1px solid var(--cyan);
  position: relative;
  padding: 8px 16px 8px 8px;
}

#header .hover-box .collapse-control .arrow,
#side-bar .side-bar-item .collapse-control .arrow,
#frames-panel .sub-collapse-control .arrow {
  height: 14px;
  width: 16px;
  background-image: var(--down-white-chevron-arrow);
  background-size: cover;
  transform: scaleY(-1);
}

#side-bar .side-bar-item .collapse-control .arrow {
  position: absolute;
  top: 8px;
  right: 0px;
}

#header .hover-box .collapse-control .arrow {
  float: right;
}

#header .hover-box .collapsed .collapse-control .arrow,
#side-bar .side-bar-item.collapsed .collapse-control .arrow {
  transform: scaleY(1);
}

#side-bar .side-bar-item .collapsible-content-wrapper {
  margin-left: 8px;
}

#side-bar .key-bubble-sample {
  float: left;
  margin-right: 6px;
  margin-left: -12px;
  margin-bottom: 6px;
}

#side-bar strong,
#side-bar h4 {
  color: var(--grey-highlight);
}

body.spiderweb-layout svg.bubbleprof .link-inner {
  /* TODO: visible only in spiderweb layout */
  stroke: var(--pure-black);
  opacity: 0.5;
}

body[data-highlight-type='files-streams'] #node-link svg:not(:hover) .type-files-streams,
body[data-highlight-type='networks'] #node-link svg:not(:hover) .type-networks,
body[data-highlight-type='crypto'] #node-link svg:not(:hover) .type-crypto,
body[data-highlight-type='timing-promises'] #node-link svg:not(:hover) .type-timing-promises,
body[data-highlight-type='other'] #node-link svg:not(:hover) .type-other,

body[data-highlight-party='user'] #node-link svg:not(:hover) .party-user,
body[data-highlight-party='external'] #node-link svg:not(:hover) .party-external,
body[data-highlight-party='nodecore'] #node-link svg:not(:hover) .party-nodecore,
body[data-highlight-party='nodecore'] #node-link svg:not(:hover) .party-root {
  /* !important overrides the stroke-width style set from js line width settings */
  stroke-width: 4px !important;
}

/* Line / Area chart */

.line-chart-svg {
  width: 100%;
  height: 70px;
  display: block;
  position: relative;
  mix-blend-mode: screen;
  z-index: 2;
}

.line-chart {
  position: relative;
  font-size: var(--main-text-size);
}

.line-chart .slice-highlight {
  background: var(--cyan-bright);
  opacity: 0.2;
  position: absolute;
  z-index: 1;
}

.line-chart .hover-box {
  width: 135px;
  color: var(--grey-highlight);
}

.line-chart .hover-box .title-block {
  padding: 12px 8px;
}

.line-chart .hover-box strong {
  color: var(--pure-white);
}

.line-chart .hover-box .vertical-arrow {
  margin-left: 9px;
}

#node-link .line-chart .hover-box > .vertical-arrow {
  border-top-color: var(--main-bg-translucent);
}

#node-link .line-chart .hover-box {
  background: var(--main-bg-translucent);
  margin-top: -55px;
  margin-left: 6px;
}

#side-bar .line-chart .hover-box {
  margin-top: -32px;
}


/* Hover box */

.hover-box {
  position: absolute;
  width: 320px;
  background-color: var(--translucent-black);
  color: var(--nearform-grey);
  margin-left: 6px;
  z-index: 25;
  margin-top: -26px;
}

.hover-box .block {
  padding: 14px;
}

.hover-box .block:not(:last-child) {
  border-bottom: 2px solid var(--main-bg-color);
}

.hover-box .title-block {
  cursor: pointer;
  position: relative;
}

.hover-box.horizontal-flip {
  margin-left: -6px;
}

.hover-box .title-block:before {
  content: "";
  display: block;
  position: absolute;
  border: 10px solid transparent;
}

.hover-box:not(.horizontal-flip) .title-block:before {
  border-right-color: var(--pure-black);
  margin-left: -18px;
  left: 0;
}

.hover-box.horizontal-flip .title-block:before {
  border-left-color: var(--pure-black);
  margin-right: -18px;
  right: 0;
}

.hover-box.off-bottom .time-block {
  bottom: 100%;
  position: absolute;
  background: var(--pure-black);
  border-bottom: 2px solid var(--main-bg-color);
}

.hover-box.off-bottom .title-block {
  border-bottom: none;
}

.hover-box p {
  margin: 14px 0 0 0;
  font-size: var(--main-text-size)
}

.hover-box strong {
  font-weight: normal;
  color: var(--grey-highlight);
}

.hover-box h2 {
  margin: 0;
  font-size: 13pt;
  color: var(--pure-white);
  font-weight: bold;
}

.hover-box .click-message {
  display: block;
  position: relative;
  color: var(--cyan);
  font-size: var(--main-text-size);
  font-weight: bold;
}

.hover-box .vertical-arrow {
  display: none;
  margin-left: 6px;
  cursor: pointer;
}

.hover-box.use-vertical-arrow {
  margin: 0;
}

.hover-box.use-vertical-arrow .title-block:before {
  display: none;
}

.hover-box.use-vertical-arrow .vertical-arrow {
  display: block;
  position: absolute;
  left: 6px;
  width: 0;
  height: 0;
  border: 10px solid transparent;
}

.hover-box.use-vertical-arrow:not(.off-bottom) > .vertical-arrow {
  border-bottom-color: var(--pure-black);
  border-top: none;
  top: 0;
  margin-top: -9px;
}

.hover-box.use-vertical-arrow.off-bottom > .vertical-arrow {
  border-top-color: var(--pure-black);
  border-bottom: none;
  bottom: 0;
  margin-bottom: -9px;
}

/* Lookup box for text-based searches */

.lookup .collapsible-content-wrapper {
  position: relative;
}

.lookup .lookup-input {
  width: 100%;
  padding: 8px;
  margin: 12px 0 0 0;
  border: none;
  border-bottom: 2px solid var(--cyan);
}

.lookup .lookup-input.default-text {
  color: var(--nearform-grey);
}

.lookup .lookup-suggestions {
  margin: 0;
  padding: 0;
  width: calc(100%);
  cursor: pointer;
}

.lookup .results-count {
  background: var(--overlay-bg-color);
  color: var(--pure-white);
  padding: 8px 24px;
  list-style: none;
  font-size: var(--main-text-size);
}

.lookup .lookup-suggestions .suggestion {
  margin: 1px 0;
  padding: 8px 4px;
  background: var(--pure-black);
  color: var(--cyan);
  list-style: none;
  font-size: 8pt;
  font-family: monospace;
  white-space: pre-wrap;
}

.lookup .loading-indicator {
  margin: -24px 0 0 -62px;
}

.lookup.loading .loading-indicator {
  display: block;
}

/* Global classes linking styles to data properties */

.party-user .party-icon,
.line-segment.party-user,
.by-variable.party-user {
  border-color: var(--party-colour-1);
  stroke: var(--party-colour-1);
}
.party-external .party-icon,
.line-segment.party-external,
.by-variable.party-external {
  border-color: var(--party-colour-2);
  stroke: var(--party-colour-2);
}

.party-root .party-icon,
.line-segment.party-root,
.by-variable.party-root,
.party-nodecore .party-icon,
.line-segment.party-nodecore,
.by-variable.party-nodecore {
  border-color: var(--party-colour-3);
  stroke: var(--party-colour-3);
}

.party-user.text-label {
  fill: var(--party-colour-1);
}
.party-external.text-label {
  fill: var(--party-colour-2);
}
.party-root.text-label,
.party-nodecore.text-label {
  fill: var(--party-colour-3);
}

.type-files-streams,
.type-files-streams .by-variable {
  stroke: var(--type-colour-1);
}
.type-files-streams .type-icon,
.type-files-streams.by-variable {
  border-color: var(--type-colour-1);
}
.type-networks,
.type-networks .by-variable {
  stroke: var(--type-colour-2);
}
.type-networks .type-icon,
.type-networks.by-variable {
  border-color: var(--type-colour-2);
}
.type-crypto,
.type-crypto .by-variable {
  stroke: var(--type-colour-3);
}
.type-crypto .type-icon,
.type-crypto.by-variable {
  border-color: var(--type-colour-3);
}
.type-timing-promises,
.type-timing-promises .by-variable {
  stroke: var(--type-colour-4);
}
.type-timing-promises .type-icon,
.type-timing-promises.by-variable {
  border-color: var(--type-colour-4);
}
.type-other,
.type-other .by-variable {
  stroke: var(--type-colour-5);
}
.type-other .type-icon,
.type-other.by-variable {
  border-color: var(--type-colour-5);
}

/* In area chart specifically, apply to fill instead of stroke */

svg.line-chart-svg .area-line {
  stroke: none;
  opacity: 0.8;
  cursor: pointer;
}
svg.line-chart-svg .area-line-even {
  opacity: 0.6;
}
svg.line-chart-svg .area-line:hover {
  mix-blend-mode: screen;
  opacity: 1;
}
svg.line-chart-svg .area-line.type-files-streams {
  fill: var(--type-colour-1);
}
svg.line-chart-svg .area-line.type-networks {
  fill: var(--type-colour-2);
}
svg.line-chart-svg .area-line.type-crypto {
  fill: var(--type-colour-3);
}
svg.line-chart-svg .area-line.type-timing-promises {
  fill: var(--type-colour-4);
}
svg.line-chart-svg .area-line.type-other {
  fill: var(--type-colour-5);
}
svg.line-chart-svg.filter-applied .area-line {
  animation-name: fade-in;
  animation-duration: 0.4s;
  animation-fill-mode: forwards;
}
svg.line-chart-svg.filter-applied .area-line.not-emphasised {
  animation-name: half-fade-out;
}
svg.line-chart-svg.filter-applied .area-line.filtered {
  animation-name: mostly-fade-out;
  mix-blend-mode: luminosity;
}

@keyframes mostly-fade-out {
  to {
    opacity: 0.14;
  }
}
@keyframes half-fade-out {
  to {
    opacity: 0.45;
  }
}
@keyframes fade-in {
  to {
    opacity: 1;
  }
}

.hover-box .line-chart {
  background: var(--pure-black);
  opacity: 1;
}

.line-chart .x-axis .tick text {
  fill: var(--nearform-grey);
}

.line-chart .x-axis .tick line {
  stroke: var(--nearform-grey);
}

.hover-box .line-chart .x-axis .tick line {
  stroke: var(--main-bg-color);
}

.line-chart .x-axis .domain {
  display: none;
}

/* Loading indicator based on https://projects.lukehaas.me/css-loaders/#load8
   * Must * animate by transforms only, to keep animating when processor is busy */

.loading-indicator,
.loading-indicator:before,
.loading-indicator:after,
body:not(.initialized):before,
body:not(.initialized):after {
  width: 124px;
  height: 120px;
  position: absolute;
  left: 50%;
  margin: 80px 0 0 -60px;
  z-index: 3;
}

body:not(.initialized) {
  position: relative;
  z-index: 3;
}

body:not(.initialized):before,
.loading-indicator:before {
  content: "";
  border-radius: 50%;
  display: block;
  border-left: 1px solid var(--nearform-grey);
  border-right: 1px solid var(--nearform-grey);
  border-top: 4px solid var(--nearform-red);
  border-bottom: 4px solid var(--nearform-red);
  transform: translateZ(0);
  animation: loading 1.6s infinite linear;
}

body:not(.initialized):after,
.loading-indicator:after {
  font-size: 14pt;
  font-variant: all-small-caps;
  font-weight: bold;
  color: var(--nearform-red);
  text-align: center;

  display: block;
  position: absolute;
}

.loading-indicator:after {
  content: "Loading";
  top: 50px;
}

body:not(.initialized):before {
  top: var(--banner-height);
}
body:not(.initialized):after {
  content: "Preparing file";
  top: 115px;
}

#node-link .loading-indicator {
  background: var(--main-bg-translucent);
  width: 100%;
  height: calc(100% + var(--header-height));
  top: 0;
  left: 0;
  position: absolute;
  margin: 0;
}

#node-link.redraw .loading-indicator {
  display: block;
}

#node-link.redraw .loading-indicator:after {
  content: "Redrawing";
}

@keyframes loading {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@media only screen and (max-width: 910px){
  #header .highlight-bar *:not(.interactive-key) > label {
    display: none;
  }
  #header .panel {
    display: inline;
  }
  #header {
    display: block;
    margin: 0;
  }
  #header .hover-box {
    margin-left: 0;
  }
  #header .hover-box.use-vertical-arrow:not(.off-bottom) > .vertical-arrow {
    margin-top: -5px;
  }
  #header .hover-box.use-vertical-arrow .vertical-arrow {
    border-width: 6px;
  }
}

@media only screen and (max-width: 750px){
  #header .panel .interactive-key {
    font-size: 9pt;
    padding: 0;
  }
  #banner svg {
    margin: 0;
    transform: scale(0.9);
  }
  .breadcrumb-bar {
    padding-left: 7px;
  }
  .type-icon {
    width: 7px;
    margin-right: 3px;
  }
}

@media only screen and (max-width: 635px){
  body {
    --header-height: 75px;
  }
  #header .help-link-block {
    top: 6px;
  }
  #header .help-link-block .help-link:before {
    content: 'Help';
  }
  #header .highlight-bar .panel:last-child {
    margin-right: 75px;
  }
}

@media only screen and (max-width: 515px){
  #header .panel,
  #header .panel.breadcrumbs-panel {
    margin: 0;
    display: block;
    white-space: nowrap;
  }
  #header .highlight-bar {
    display: block;
  }
}

@media only screen and (max-width: 380px){
  #banner a:first-child {
    margin-left: -20px;
  }
  #banner a:last-child svg {
    right: 0;
  }
}

@media screen and (orientation: landscape) {
  .portrait-only {
    display: none !important;
  }
}

@media screen and (orientation: portrait) {
  .portrait-collapsed .collapsible-content-wrapper {
    display: none;
  }

  #header {
    margin: 0;
  }

  #side-bar,
  #node-link {
    width: 100%;
  }

  body[data-view-mode='fit'] #node-link {
    max-height: calc(100vh - var(--banner-height) - var(--footer-height) - var(--header-height));
    min-height: calc(100vh - var(--banner-height) - var(--footer-height) - var(--header-height));
  }

  #side-bar {
    position: fixed;
    bottom: 0;
    margin: 0;
    left: 0;
    z-index: 12;
    padding: 0;
    border: none;
  }

  #side-bar.portrait-collapsed {
    z-index: 2;
  }

  #footer {
    right: 0;
  }

  #footer .bar {
    width: 100%;
  }

  #footer,
  #side-bar {
    width: 50%;
    display: flex;
    flex-direction: column-reverse;
  }

  #side-bar .bar {
    height: var(--footer-height);
    display: flex;
    flex-direction: row-reverse;
    background: var(--cyan);
    border-right: 1px solid var(--main-bg-color);
  }

  #footer .bar .arrow,
  #side-bar .bar .arrow {
    transform: rotate(0deg)
  }

  #footer.collapsed .bar .arrow,
  #side-bar.portrait-collapsed .bar .arrow {
    transform: rotate(180deg)
  }

  #footer-inner {
    position: relative;
    width: 200%;
    left: -100%;
  }

  #side-bar-inner {
    max-height: calc(50vh - var(--footer-height));
    overflow: auto;
    width: 200%;
    padding: 8px 24px;
    border-top: 1px solid var(--cyan);
    background: var(--main-bg-translucent);
  }

  #side-bar .close {
    margin-right: -24px
  }

  .side-bar-item:first-of-type {
    margin-top: 12px;
  }
}
</style>
      <div id="banner">
        <a href="https://github.com/nearform/node-clinic-bubbleprof" title="Clinic Bubbleprof on GitHub" target="_blank">
          <svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="215px" height="40px" viewBox="0 0 215 40">
<path d="M75.554,21.596c1.263-0.07,2.315-0.563,3.157-1.404c0.771,0.841,1.191,1.193,1.191,3.226c0,2.385-2.593,4.911-4.978,4.911h-5.893c-1.895,0-3.508-1.684-3.508-3.647v-8.768c0-1.964,1.543-3.577,3.508-3.577h5.611c2.455,0,4.489,1.963,4.489,4.559c0,2.104-1.543,3.928-3.578,4.419C75.344,21.385,75.344,21.596,75.554,21.596z M80.185,20.823v-4.84c0-1.964,1.613-3.646,3.647-3.646c1.963,0,3.576,1.613,3.576,3.646c0,0.21,0,4.208,0,4.419c0,0.281,0.211,0.562,0.491,0.562c0.281,0,0.491-0.28,0.491-0.562v-4.419c0-1.964,1.613-3.646,3.648-3.646c1.893,0,3.576,1.613,3.576,3.646v4.84c0,4.208-3.508,7.646-7.645,7.646C83.621,28.539,80.185,25.031,80.185,20.823z M106.347,21.596c1.262-0.07,2.315-0.563,3.157-1.404c0.771,0.841,1.193,1.193,1.193,3.226c0,2.385-2.597,4.911-4.982,4.911h-5.891c-1.895,0-3.507-1.684-3.507-3.647v-8.768c0-1.964,1.542-3.577,3.507-3.577h5.612c2.453,0,4.488,1.963,4.488,4.559c0,2.104-1.544,3.928-3.578,4.419C106.138,21.385,106.138,21.596,106.347,21.596z M121.077,21.596c1.263-0.07,2.313-0.563,3.156-1.404c0.771,0.841,1.192,1.193,1.192,3.226c0,2.385-2.596,4.911-4.979,4.911h-5.893c-1.895,0-3.507-1.684-3.507-3.647v-8.768c0-1.964,1.543-3.577,3.507-3.577h5.611c2.455,0,4.489,1.963,4.489,4.559c0,2.104-1.543,3.928-3.577,4.419C120.866,21.385,120.866,21.596,121.077,21.596z M125.847,24.682v-8.768c0-1.964,1.613-3.577,3.577-3.577s3.577,1.613,3.577,3.577l-0.071,5.261h0.773c4.699,0,4.699,7.154,0,7.154h-4.209C127.39,28.329,125.776,26.785,125.847,24.682z M141.348,12.407h5.893c2.805,0,4.419,3.226,2.946,5.471c-0.703,1.192-1.754,1.542-3.087,1.612c-0.14,0-0.14,0.21,0,0.281c1.263,0.14,2.456-0.14,3.366-1.052c0.632,1.333,0.351,3.086-0.631,4.068c-0.7,0.771-1.544,0.981-2.525,1.121c-0.14,0-0.14,0.281,0,0.281c1.193,0.141,2.315-0.142,3.156-1.122c0.212,0.35,0.351,0.771,0.351,1.754c0,1.401-1.052,3.577-3.576,3.577h-5.893c-1.963,0-3.577-1.614-3.577-3.577v-8.839C137.701,14.02,139.244,12.407,141.348,12.407z M151.239,24.822v-8.769c0-1.964,1.611-3.646,3.716-3.646h4.42c3.577,0,6.383,2.875,6.383,6.382c0,3.578-2.946,6.453-6.523,6.383l-0.421-2.175c-0.07-0.209-0.21-0.141-0.21,0.071v1.823c0,1.965-1.613,3.647-3.648,3.647C152.922,28.539,151.239,26.856,151.239,24.822z M158.604,18.019v1.542c0.14,0.07,0.21,0.139,0.351,0.139c0.49,0,0.842-0.42,0.842-0.842c0-0.42-0.421-0.84-0.842-0.84C158.813,17.947,158.743,17.947,158.604,18.019z M166.179,24.752v-8.769c0-1.964,1.612-3.576,3.646-3.576h5.051c3.506,0,6.383,2.875,6.383,6.382c0,2.175-1.053,4.139-2.736,5.331c-0.141,0.07,0,0.281,0.141,0.211c0.772-0.351,1.403-0.843,2.035-1.475c0.981,1.405,0.842,3.298-0.421,4.63c-1.264,1.264-3.718,1.544-4.91-0.14l-1.964-2.315c-0.141,1.894-1.613,3.368-3.578,3.368C167.791,28.399,166.179,26.785,166.179,24.752z M173.333,18.158V19.7c0.141,0.071,0.21,0.071,0.42,0.071c0.491,0,0.843-0.351,0.843-0.841c0-0.492-0.352-0.842-0.843-0.842C173.543,18.088,173.403,18.088,173.333,18.158z M198.162,20.333c0,4.49-3.646,8.136-8.205,8.136c-4.419,0-8.136-3.646-8.136-8.136c0-4.489,3.717-8.136,8.136-8.136C194.445,12.196,198.162,15.843,198.162,20.333z M189.115,20.333c0,0.491,0.42,0.842,0.842,0.842c0.489,0,0.842-0.422,0.842-0.842c0-0.491-0.421-0.842-0.842-0.842C189.535,19.49,189.115,19.842,189.115,20.333z M202.231,12.407h5.892c1.964,0,3.577,1.612,3.577,3.576c0,1.544-1.052,3.016-2.524,3.437c-0.281,0.07-0.701,0.141-1.122,0.141c-0.212,0.07-0.212,0.281,0,0.281c0.771,0.14,1.543,0.07,2.313-0.21c0.14,0.35,0.281,0.842,0.281,1.402c0,1.964-1.612,3.577-3.577,3.577h-1.192v0.352c0,1.963-1.614,3.577-3.576,3.577c-1.965,0-3.579-1.614-3.579-3.577c0-2.945,0-6.032,0-8.908C198.724,13.669,199.986,12.407,202.231,12.407z"/>
<path d="M22.893,13.055L22.893,13.055L22.893,13.055z M22.323,12.39L22.323,12.39L22.323,12.39z M26.791,8.11L26.791,8.11L26.791,8.11z M22.989,12.864c-0.287-0.286-0.478-0.666-0.571-0.951C22.512,12.294,22.702,12.578,22.989,12.864L22.989,12.864z M22.228,12.009c-0.096-0.096-0.096-0.285-0.096-0.382C22.132,11.819,22.132,11.914,22.228,12.009z M22.228,11.343c0,0.19,0.095,0.284,0.095,0.476C22.323,11.627,22.228,11.534,22.228,11.343z M26.412,8.208c0.095,0,0.095,0,0.189,0.094l0,0C26.601,8.302,26.506,8.302,26.412,8.208L26.412,8.208z M28.597,26.934c0.095-0.093,0.285-0.093,0.38-0.093C28.882,26.841,28.692,26.841,28.597,26.934z M30.213,26.841L30.213,26.841c-0.095,0-0.19-0.098-0.381-0.098C29.928,26.743,30.118,26.841,30.213,26.841z M28.216,26.553L28.216,26.553c-0.095,0-0.095-0.095-0.189-0.095C28.122,26.458,28.216,26.458,28.216,26.553z M21.943,15.622L21.943,15.622L21.943,15.622L21.943,15.622z M21.088,14.101c0,0.188,0.095,0.285,0.095,0.38C21.183,14.386,21.088,14.196,21.088,14.101z M27.361,26.173c0.095,0,0.095,0.096,0.095,0.096S27.456,26.173,27.361,26.173z M21.943,15.432c-0.285-0.19-0.476-0.477-0.666-0.761C21.373,14.955,21.658,15.241,21.943,15.432z M48.084,17.998c0-0.096,0-0.096-0.096-0.19C47.989,17.902,47.989,17.998,48.084,17.998z M48.274,18.569c0-0.097-0.095-0.19-0.095-0.286C48.179,18.378,48.179,18.472,48.274,18.569z M53.028,18.569c0,0,0,0.095-0.095,0.095C53.028,18.664,53.028,18.569,53.028,18.569z M53.217,18.092v0.095C53.217,18.187,53.217,18.187,53.217,18.092z M48.559,18.949c-0.096-0.097-0.189-0.191-0.189-0.286C48.37,18.758,48.463,18.853,48.559,18.949z M48.939,19.329c-0.095-0.096-0.189-0.19-0.285-0.286C48.655,19.139,48.75,19.233,48.939,19.329z M48.939,19.329c0.381,0.284,0.857,0.476,1.332,0.57l0,0C49.7,19.899,49.32,19.613,48.939,19.329z M30.213,5.925c-0.19-0.285-0.476-0.476-0.857-0.571C29.737,5.545,30.023,5.733,30.213,5.925z M29.262,5.354c-0.095-0.094-0.284-0.094-0.379-0.188C28.978,5.26,29.167,5.26,29.262,5.354z M25.651,7.827c0.189,0,0.378,0.095,0.57,0.095C26.03,7.827,25.84,7.827,25.651,7.827z M52.077,19.52c-0.095,0-0.095,0.094-0.189,0.094C51.982,19.613,52.077,19.613,52.077,19.52z M52.743,19.043L52.743,19.043L52.743,19.043z M52.457,19.329c-0.095,0-0.095,0.095-0.189,0.095C52.362,19.424,52.457,19.329,52.457,19.329z M55.214,8.967c0.095,0.095,0.189,0.19,0.379,0.284C55.498,9.158,55.404,9.062,55.214,8.967z M26.506,26.458c0-0.095,0.095-0.189,0.095-0.189l0,0C26.506,26.363,26.506,26.363,26.506,26.458z M51.602,24.558L51.602,24.558L51.602,24.558z M30.689,26.934L30.689,26.934c0.095,0,0.285,0,0.381,0C30.974,26.841,30.878,26.841,30.689,26.934z M54.833,8.777c-0.095,0-0.19-0.096-0.38-0.096C54.548,8.777,54.643,8.777,54.833,8.777L54.833,8.777z M54.833,8.777c0.095,0,0.285,0.094,0.381,0.19C55.023,8.872,54.928,8.872,54.833,8.777z M53.123,20.089v-0.094V20.089c-1.045-0.094-1.331,0.57-1.331,0.57c0,0.096-0.095,0.096-0.095,0.096c-0.096,0-0.096,0-0.19,0c-0.095-0.096-0.19-0.191-0.095-0.286c0,0,0.095-0.095,0.189-0.284l-1.046,0.094l-4.276,0.381c0,0.189,0,0.286,0,0.476c-0.096,1.614-0.856,3.138-2.187,4.279c-1.237,0.949-2.757,1.52-4.373,1.52c-0.19,0-0.286,0-0.476,0c-0.665,0-1.331-0.19-1.996-0.381v0.097c0,0.284-0.095,0.568-0.285,0.854c0,0.098-0.096,0.098-0.19,0.098l0,0h-0.096c-0.094-0.098-0.094-0.191-0.094-0.288c0.094-0.189,0.189-0.472,0.189-0.663c0-0.097,0-0.191,0-0.286v-0.095c-0.096-0.19-0.189-0.476-0.381-0.666c-0.285-0.285-0.57-0.477-1.045-0.477c-0.095,0-0.285,0-0.381,0h-0.094c-0.191,0.097-0.38,0.191-0.572,0.288h-0.095c-0.095,0-0.095,0-0.095-0.097c0,0-0.096-0.095,0-0.095c0-0.097,0-0.097,0.095-0.097c0.095-0.094,0.286-0.189,0.475-0.282c-1.045-1.047-1.615-2.472-1.71-3.898c-0.096-0.097-0.19-0.19-0.285-0.19c-0.096,0-0.191,0-0.286,0.094c-0.094,0.763-0.285,1.427-0.665,2.091l0,0l0,0c0.189-0.094,0.476-0.094,0.759-0.094c0.096,0,0.191,0.094,0.191,0.19c0,0.096-0.096,0.189-0.191,0.189l0,0c-0.379,0-0.759,0.095-1.045,0.285l0,0c0,0-0.095,0-0.095,0.095l0,0c-0.57,0.287-0.856,0.761-1.045,1.331v0.096c0,0.094,0,0.19,0,0.285c0,0.569,0.189,1.141,0.57,1.616l0.096,0.096c0.096,0,0.285,0,0.379,0s0.285,0,0.381,0.094c0.855,0.189,1.331,1.141,1.045,1.901c-0.286,0.76-1.141,1.331-1.901,1.046c-0.476-0.189-0.855-0.569-1.046-1.046c-0.284,0.097-0.57,0.191-0.854,0.097c-0.476-0.097-0.761-0.571-0.761-0.951c-0.095,0-0.189,0-0.285,0c-0.379-0.097-0.57-0.381-0.57-0.761c-0.096,0-0.096,0-0.19,0c-0.285-0.097-0.476-0.38-0.38-0.76c0-0.097,0.095-0.191,0.095-0.191c-0.19,0-0.379,0-0.474,0c-0.096,0-0.286,0-0.381,0c-1.332-0.095-2.662-0.665-3.613-1.521c0.855,3.137,2.567,5.895,4.943,7.891c0-0.095,0-0.19,0.095-0.285c0.096-0.095,0.285-0.095,0.38,0.095c0.38,0.571,0.856,1.142,1.426,1.616c0,0,0,0,0.095,0c1.618,1.427,3.708,2.377,5.99,2.47c1.141,0.098,2.187,0,3.233-0.378c1.236-0.381,2.376-0.855,3.326-1.712c0.096,0,0.096-0.094,0.19-0.094c0.095,0,0.095,0,0.19,0.094l0,0c0,0.096,0.096,0.096,0.096,0.189c0,0.097,0,0.097-0.096,0.191c-0.474,0.38-0.95,0.666-1.521,0.95c5.418-1.331,9.791-5.514,11.218-11.027l0,0l0,0c0-0.093,0-0.093,0.095-0.188c0,0,0,0,0.096,0l0,0h-0.761l0.285-0.191c0.38-0.285,1.045-0.761,1.71-1.618c0.476-0.567,0.666-1.423,0.476-2.091C53.788,20.374,53.502,20.185,53.123,20.089z M32.97,27.789L32.97,27.789c0,0,0-0.097,0.095-0.188c0.096-0.098,0.189-0.191,0.285-0.288c0.189-0.189,0.476-0.379,0.761-0.569c0.855-0.475,1.521,0.098,1.331,0.569c0.19,0.19,0.38,0.38,0.475,0.571c0.19-0.283,0.476-0.475,0.856-0.571c0.38-0.095,0.76,0.097,1.045,0.38c0.096-0.283,0.381-0.475,0.666-0.475s0.57,0.095,0.76,0.285l0,0c0-0.38,0.38-0.662,0.76-0.569c0.381,0.096,0.666,0.379,0.571,0.759c0,0.381-0.382,0.668-0.76,0.571c-0.096,0-0.191-0.094-0.286-0.094c0,0.475-0.285,0.854-0.76,0.951c-0.19,0-0.38,0-0.57-0.097c-0.096,0.477-0.475,0.856-1.045,0.951c-0.476,0.095-0.856-0.095-1.141-0.475c-0.19,0.569-0.76,0.949-1.332,1.044c-0.951,0.097-1.806-0.475-1.995-1.424C32.589,28.55,32.78,28.17,32.97,27.789z M42.761,30.07c-0.95,1.616-5.133,3.518-5.324,3.612l0,0c-1.236,0.476-2.472,0.665-3.802,0.665c-1.045-0.095-2.187-0.38-3.232-0.854c-1.806-0.856-3.327-2.282-3.708-3.612c-0.094-0.571-0.094-0.856,0.096-0.95c0.189-0.189,0.665,0,1.331,0.379c1.045,0.571,2.757,1.427,4.943,1.617c4.088,0.189,5.704-0.665,7.128-1.332l0.382-0.19c0.76-0.38,1.995-0.951,2.471-0.474C43.142,29.121,43.046,29.501,42.761,30.07z M41.715,34.729L41.715,34.729L41.715,34.729z M30.878,23.226L30.878,23.226L30.878,23.226L30.878,23.226c0.57-0.854,0.856-1.805,0.856-2.757c0.095-1.52-0.381-2.946-1.426-4.087c-1.046-1.14-2.377-1.806-3.896-1.9c-1.522-0.096-2.948,0.38-4.088,1.425c-1.141,1.044-1.807,2.376-1.901,3.898c-0.095,1.426,0.38,2.853,1.331,3.992l0.096,0.096c1.044,1.14,2.376,1.805,3.897,1.9c0.95,0.094,1.9-0.096,2.756-0.476c0,0,0,0,0.096,0c0.285-0.285,0.665-0.568,1.045-0.568c0.095-0.096,0.189-0.096,0.285-0.191C30.023,23.986,30.403,23.511,30.878,23.226z M24.604,21.611c-0.379,0-0.665-0.381-0.665-0.763c0-0.38,0.38-0.664,0.76-0.664c0.381,0,0.666,0.379,0.666,0.761C25.365,21.325,24.985,21.611,24.604,21.611z M28.597,26.934L28.597,26.934c0.095-0.093,0.285-0.093,0.38-0.093c0.094,0,0.284,0,0.379,0l0,0c0-0.098,0.191-0.098,0.476-0.098c0.096,0,0.191,0.098,0.381,0.098c-0.381-0.478-0.571-1.048-0.476-1.618c0-0.097,0-0.097,0-0.19c-0.381,0-0.666,0.19-0.855,0.475l0,0l0,0c-0.095,0.19-0.19,0.38-0.19,0.571l0,0l0,0c0,0.19,0,0.285,0.096,0.475C28.692,26.743,28.692,26.841,28.597,26.934L28.597,26.934z M35.346,24.653c0.76,0.096,1.426,0.569,1.616,1.33c0.665,0.285,1.331,0.475,2.091,0.475c1.617,0.095,3.232-0.38,4.468-1.426s1.997-2.375,2.092-3.897c0.19-3.137-2.377-5.894-5.798-6.083c-3.423-0.19-6.371,2.186-6.561,5.322c-0.094,1.617,0.571,3.137,1.807,4.375C35.156,24.653,35.251,24.653,35.346,24.653z M38.103,20.849c0.381,0,0.761,0.382,0.666,0.763c0,0.38-0.38,0.761-0.761,0.664c-0.38,0-0.76-0.38-0.665-0.759C37.248,21.135,37.627,20.755,38.103,20.849z M28.216,25.887c-0.285,0.097-0.571,0.191-0.855,0.286c0.095,0,0.095,0.096,0.095,0.096c0.096,0.095,0.096,0.095,0.096,0.189c0.189-0.095,0.284-0.095,0.475,0c0.095,0,0.095,0.095,0.189,0.095c0-0.095,0-0.189,0-0.38l0,0l0,0l0,0V25.887z M54.453,8.493c-0.475,0-0.951,0.095-1.331,0.378c-0.475-0.57-1.045-0.95-1.806-0.95c-0.379,0-0.761,0.094-1.14,0.188c-0.379-1.044-1.332-1.71-2.377-1.71c-0.854-0.096-1.616,0.285-2.186,0.856h0.095l-0.095,0.095c-0.096,0.095-0.096,0.095-0.19,0.19l-0.095,0.096l-0.095-0.096c-2.188-1.521-4.849-2.473-7.51-2.567C31.07,4.595,24.794,8.777,22.512,15.241c1.141-0.855,2.568-1.236,3.995-1.14c3.326,0.188,5.893,2.946,5.798,6.273l0,0v0.095c0.094,0,0.189,0,0.285,0s0.19,0,0.19,0.095v-0.095l0,0c0,0,0,0,0-0.095c0.19-3.423,3.327-5.988,7.035-5.799c3.327,0.191,5.988,2.662,6.273,5.799l3.042-0.285l0,0l1.141-0.094c-0.474-0.096-0.951-0.286-1.332-0.571l0,0c-0.095-0.095-0.189-0.19-0.285-0.285c0,0,0-0.096-0.096-0.096c-0.096-0.094-0.189-0.19-0.189-0.285c0-0.094-0.096-0.094-0.096-0.189c0-0.097-0.095-0.19-0.095-0.286s-0.095-0.19-0.095-0.285c0-0.096,0-0.096-0.096-0.19c0-0.189,0-0.285,0-0.476c0-0.38,0.19-0.854,0.381-1.138c0.855,0,1.711-0.382,2.377-1.046c0.379,0.665,1.141,1.046,1.901,1.141c0.095,0,0.189,0,0.285,0c0.284,0.474,0.379,0.95,0.379,1.425c0,0.189,0,0.285-0.095,0.475v0.096c0,0.096-0.095,0.189-0.095,0.286c0,0,0,0.095-0.095,0.095c-0.095,0.094-0.19,0.189-0.19,0.379l-0.095,0.096c-0.095,0.095-0.095,0.095-0.189,0.19c-0.097,0-0.097,0.095-0.191,0.095c-0.094,0-0.094,0.096-0.189,0.096c-0.096,0-0.096,0.094-0.19,0.094c-0.095,0.096-0.285,0.096-0.381,0.191l0.666-0.096v-0.096h0.094c0,0,0,0,0.095,0c0.666-0.475,1.142-1.141,1.142-1.995c0-0.476-0.097-0.951-0.381-1.425c1.141-0.191,1.997-1.046,1.997-2.188c0-0.476-0.096-0.856-0.286-1.236c0.856-0.285,1.427-1.045,1.522-1.996C56.545,9.632,55.688,8.588,54.453,8.493z M45.613,7.542l0.095-0.096c0.475-0.57,1.236-0.95,2.09-0.856c0.952,0.095,1.807,0.667,2.187,1.618c-0.57,0.285-0.951,0.759-1.141,1.33c-0.094,0-0.19,0-0.286,0c-1.235-0.096-2.28,0.475-2.946,1.426c-0.38-0.477-0.57-1.141-0.57-1.806C45.043,8.493,45.233,8.016,45.613,7.542z M50.651,15.146C50.651,15.052,50.651,15.052,50.651,15.146C50.651,15.052,50.651,15.052,50.651,15.146c0-0.095,0-0.095,0-0.095C50.651,14.955,50.651,14.955,50.651,15.146C50.651,15.052,50.651,15.052,50.651,15.146C50.651,15.052,50.651,15.052,50.651,15.146z M55.023,14.101c-0.095,1.14-1.14,2.092-2.375,1.995c-0.76,0-1.427-0.475-1.807-1.141l0,0c0,0,0,0,0-0.094c-0.095,0-0.095,0-0.19,0l0,0l0,0c0,0,0,0-0.096,0.094c-0.095,0.097-0.095,0.097-0.189,0.191s-0.095,0.095-0.189,0.095c-0.095,0.096-0.095,0.096-0.191,0.096c-0.095,0-0.188,0.095-0.188,0.095c-0.097,0-0.191,0.095-0.191,0.095s-0.095,0-0.095,0.095c-0.19,0.095-0.286,0.095-0.477,0.095h-0.095c-0.189,0-0.285,0-0.476,0l0,0c-0.094,0-0.094,0-0.189,0c-1.71-0.095-3.041-1.615-2.946-3.327c0.095-1.712,1.616-3.042,3.327-2.948c0.096,0,0.096,0,0.19,0c0,0.19-0.094,0.286-0.094,0.475v0.096l0,0l0,0c0,0.286,0.094,0.571,0.189,0.855c0,0.096,0.095,0.189,0.095,0.189c0,0.096,0.096,0.096,0.096,0.19c0,0.096,0.095,0.096,0.095,0.191c0.096,0.095,0.096,0.188,0.19,0.188l0.096,0.097c0.095,0.095,0.095,0.095,0.189,0.189c0.097,0.096,0.097,0.096,0.19,0.096c0.19,0.189,0.475,0.285,0.76,0.285c0-0.096,0.096-0.189,0.096-0.189c-1.141-0.191-1.902-1.237-1.807-2.377c0.095-1.235,1.142-2.187,2.377-2.187c0.666,0,1.237,0.38,1.617,0.856c-0.477,0.38-0.76,0.95-0.76,1.615c0,0.38,0,0.665,0.189,1.044c0,0.096,0.095,0.19,0.095,0.19c0.381,0.666,0.951,1.046,1.806,1.142c0.19,0,0.38,0,0.571,0C54.928,13.245,55.023,13.625,55.023,14.101z M56.259,11.057c0,0.096,0,0.19-0.095,0.286c-0.189,0.762-0.855,1.332-1.616,1.426c-0.095,0-0.19,0-0.19,0c-0.096,0-0.096,0-0.19,0s-0.189,0-0.285,0c-0.095,0-0.095,0-0.19,0c-0.855-0.285-1.425-1.045-1.331-1.996c0-0.571,0.286-1.141,0.761-1.426c0,0,0,0,0.095-0.096c0.381-0.284,0.761-0.38,1.236-0.38c0.095,0,0.286,0,0.38,0.096l0,0l0,0l0,0c0.095,0,0.285,0.095,0.381,0.19c0,0,0,0,0.095,0c0.095,0.094,0.189,0.189,0.379,0.284l0,0c0.096,0.096,0.19,0.19,0.286,0.286l0,0c0.189,0.285,0.284,0.571,0.284,0.856c0,0.094,0,0.189,0,0.284C56.259,10.964,56.259,10.964,56.259,11.057C56.259,10.964,56.259,10.964,56.259,11.057z M21.183,12.198c-0.19,0.38-0.285,0.763-0.381,1.236c-0.095,1.047,0.381,1.903,1.046,2.282h0.095l0,0l0,0l-0.095-0.095v-0.095l0,0l0,0c-0.286-0.19-0.476-0.475-0.666-0.76v-0.096c-0.095-0.096-0.095-0.285-0.095-0.382c0-0.188-0.096-0.379,0-0.664c0.095-0.761,0.474-1.521,0.95-1.807c0,0.095,0.095,0.286,0.095,0.379c0,0.096,0.096,0.191,0.191,0.286c0,0,0,0,0,0.094c0.095,0.286,0.285,0.477,0.475,0.667l0,0l0.095-0.284l0,0v-0.097l0,0c-0.284-0.286-0.475-0.666-0.569-0.951v-0.095c-0.095-0.191-0.095-0.285-0.095-0.476s0-0.379,0-0.57c0-0.761,0.38-1.426,0.95-1.902l0,0c0.572-0.57,1.426-0.856,2.377-0.856c0.191,0,0.38,0,0.475,0.095l0,0l0,0c0.096,0,0.191,0.098,0.286,0.098l0,0h0.096c0.095,0,0.095,0,0.189,0.094c0,0,0,0,0.094,0l0.096-0.094l0,0l0.095-0.098l0,0c-0.19-0.095-0.379-0.188-0.57-0.188c-0.19-0.095-0.381-0.095-0.57-0.095c-0.094-0.19-0.094-0.476-0.094-0.667c0.094-1.236,1.329-2.092,2.755-1.995c0.19,0,0.381,0,0.571,0.095c0.094,0,0.284,0.094,0.379,0.189h0.097c0.284,0.19,0.57,0.381,0.855,0.571l0,0l0,0h0.095l0,0h0.095c-0.474-0.571-1.236-0.952-2.091-0.952c-0.666,0-1.236,0.097-1.711,0.38c-0.379-0.189-0.855-0.38-1.235-0.38c-0.57,0-1.141,0.097-1.617,0.38c-0.474-0.38-0.854-0.57-1.332-0.57c-1.139-0.096-2.185,0.76-2.185,1.901c-0.096,0.476,0.095,0.95,0.475,1.427c-0.57,0.38-0.855,1.043-0.855,1.615C19.852,10.868,20.327,11.724,21.183,12.198z M25.365,5.069c0.38,0,0.76,0.097,1.046,0.285C25.84,5.733,25.46,6.4,25.365,7.066c0,0.19,0,0.476,0.095,0.665c-0.856,0-1.71,0.285-2.282,0.763c-0.38-0.285-0.476-0.763-0.476-1.237C22.798,6.021,23.939,5.069,25.365,5.069z M20.517,6.781c0.096-0.951,0.951-1.712,1.995-1.712c0.097,0,0.097,0,0.19,0l0,0c0.096,0,0.096,0,0.19,0l0,0l0,0c0.19,0.191,0.381,0.285,0.571,0.38c-0.286,0.19-0.571,0.476-0.762,0.855c0,0.096-0.094,0.096-0.094,0.191c-0.097,0.189-0.097,0.474-0.097,0.76v0.095v0.095l-0.094,0.096l0,0l0,0c-0.286,0-0.57,0.096-0.856,0.189c-0.095,0-0.095,0.097-0.189,0.097c-0.096,0-0.096,0.095-0.19,0.095c0,0-0.095,0-0.095,0.094l0,0C20.612,7.637,20.517,7.256,20.517,6.781z M20.992,8.302c0.475-0.38,0.951-0.571,1.52-0.475c0.097,0.381,0.19,0.666,0.381,0.95c-0.569,0.57-0.855,1.235-0.95,1.996c0,0.19,0,0.474,0,0.666c-0.285,0.095-0.476,0.38-0.666,0.57c-0.76-0.382-1.236-1.236-1.141-2.092C20.231,9.251,20.517,8.682,20.992,8.302z M20.041,15.146c0.473,0,0.856,0.383,0.856,0.855s-0.384,0.856-0.856,0.856c-0.472,0-0.855-0.384-0.855-0.856S19.569,15.146,20.041,15.146z M21.183,32.257c-0.666,0-1.236,0.476-1.331,1.142c0,0.663,0.475,1.234,1.14,1.234c0.666,0,1.236-0.475,1.331-1.14C22.418,32.827,21.848,32.257,21.183,32.257z M45.423,6.21c1.235,0.095,2.281-0.856,2.376-1.997c0.095-1.139-0.854-2.185-1.996-2.28c-1.236-0.096-2.187,0.856-2.282,1.995C43.331,5.069,44.282,6.116,45.423,6.21z M55.404,16.193c-0.189-0.097-0.476-0.191-0.665-0.097c-0.19,0.097-0.38,0.191-0.571,0.475c-0.285,0.476-0.189,0.951,0.285,1.236c0.095,0.095,0.19,0.095,0.38,0.095c0.095,0,0.189,0,0.285,0c0.19-0.095,0.379-0.189,0.57-0.474c0.19-0.285,0.19-0.477,0.096-0.666C55.784,16.571,55.688,16.381,55.404,16.193z M53.313,7.066c1.616,0.095,2.946-0.95,3.043-2.377c0.095-1.426-1.141-2.661-2.757-2.756c-1.616-0.096-2.948,0.952-3.043,2.376C50.46,5.733,51.697,6.97,53.313,7.066z"/>
</svg>

        </a>
        <a href="https://nearform.com" title="nearForm" target="_blank">
          <?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 202.2 62.4" style="enable-background:new 0 0 202.2 62.4;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#ED1828;}
	.st1{fill:#797A7C;}
</style>
<g>
	<g>
		<path class="st0" d="M54.3,10.3c-0.5,2.8-2.4,5.1-4.9,6.2C48.6,17,48,18,48,19.1v23.3c0,1.2,0.8,2.3,1.8,2.8
			c2.5,1.3,4.4,3.8,4.7,6.8c5-5.5,8-12.8,8-20.8C62.4,23.1,59.3,15.8,54.3,10.3z"/>
		<path class="st0" d="M12.1,45.2L12.1,45.2c1-0.4,1.7-1.5,1.7-2.8V31.8c0-1.1-0.6-2.2-1.5-2.7c-0.1,0-0.1-0.1-0.2-0.1c0,0,0,0,0,0
			h0c-2.7-1.4-4.6-4.3-4.6-7.6c0-4.7,3.9-8.6,8.6-8.6c4.7,0,8.6,3.9,8.6,8.6c0,1.1-0.2,2.1-0.6,3.2h0c-0.2,0.9,0,2.2,0.7,3
			l15.4,15.7h0c0.6,0.6,1.4,0.9,2.3,0.9c0.2,0,0.5,0,0.7-0.1c0.3-0.5,0.4-1.1,0.4-1.7V19.1c0-1.1-0.5-2.2-1.4-2.7
			c-0.1,0-0.1-0.1-0.2-0.1c0,0,0,0,0,0h0c-2.7-1.5-4.6-4.3-4.6-7.6c0-2.9,1.5-5.5,3.7-7.1C38,0.6,34.7,0,31.2,0C14,0,0,14,0,31.2
			C0,39,2.9,46.1,7.6,51.6C8,48.8,9.7,46.5,12.1,45.2z"/>
		<path class="st0" d="M45.9,12.9c2.3,0,4.2-1.9,4.2-4.2s-1.9-4.2-4.2-4.2c-2.3,0-4.2,1.9-4.2,4.2S43.6,12.9,45.9,12.9z"/>
		<path class="st1" d="M41.7,52.9c0,2.3,1.9,4.2,4.2,4.2c2.3,0,4.2-1.9,4.2-4.2c0-2.3-1.9-4.2-4.2-4.2
			C43.6,48.7,41.7,50.5,41.7,52.9z"/>
		<path class="st0" d="M37.4,52.8c0-1.1,0.2-2.1,0.6-3l0,0c0.1-0.4,0.2-0.7,0.2-1.1c0-0.9-0.4-1.7-1-2.3l0,0L21.7,30.6
			c-1.4-1.4-3.5-1.2-3.5,1.2v10.6c0,1.2,0.7,2.3,1.8,2.8c2.8,1.4,4.7,4.3,4.7,7.6c0,3.3-1.8,6.1-4.5,7.5c3.4,1.3,7.1,2,11,2
			c3.8,0,7.4-0.7,10.8-1.9C39.2,59,37.4,56.1,37.4,52.8z"/>
		<path class="st0" d="M16.1,48.7c-2.3,0-4.2,1.9-4.2,4.2c0,2.3,1.9,4.2,4.2,4.2c2.3,0,4.2-1.9,4.2-4.2
			C20.3,50.5,18.4,48.7,16.1,48.7z"/>
		<path class="st1" d="M20.3,21.4c0-2.3-1.9-4.2-4.2-4.2c-2.3,0-4.2,1.9-4.2,4.2s1.9,4.2,4.2,4.2C18.4,25.6,20.3,23.7,20.3,21.4z"/>
	</g>
	<g>
		<path class="st1" d="M79.8,39.7V29.7c0-4.1-1.5-6.2-4.5-6.2c-1.7,0-3,0.6-4.1,1.8c-1.1,1.2-1.6,2.7-1.6,4.5v9.9h-1.6V22.4h1.6v3.1
			h0.1c1.3-2.4,3.2-3.6,5.9-3.6c1.9,0,3.3,0.6,4.3,1.9c1,1.2,1.5,3,1.5,5.3v10.5H79.8z"/>
		<path class="st1" d="M86.9,31.1c0,2.4,0.5,4.2,1.6,5.6c1.1,1.3,2.6,2,4.5,2c1.9,0,3.8-0.7,5.7-2.1v1.7c-1.8,1.3-3.8,1.9-6,1.9
			c-2.2,0-4-0.8-5.4-2.4c-1.4-1.6-2.1-3.9-2.1-6.8c0-2.5,0.7-4.6,2.1-6.4c1.4-1.7,3.3-2.6,5.6-2.6c2.1,0,3.8,0.8,4.9,2.3
			c1.1,1.5,1.7,3.6,1.7,6.2v0.7H86.9z M98.1,29.7c-0.1-2-0.5-3.5-1.4-4.6c-0.9-1.1-2.1-1.7-3.7-1.7c-1.6,0-3,0.5-4,1.6
			c-1.1,1.1-1.7,2.6-2,4.7H98.1z"/>
		<path class="st1" d="M114.3,39.7v-3.5h-0.1c-0.6,1.2-1.4,2.1-2.4,2.8c-1.1,0.7-2.2,1.1-3.5,1.1c-1.6,0-2.9-0.5-3.9-1.4
			c-1-0.9-1.4-2.1-1.4-3.5c0-3,2-4.8,6-5.5l5.3-0.8c0-3.7-1.4-5.6-4.2-5.6c-1.9,0-3.7,0.8-5.5,2.3v-1.9c0.6-0.5,1.5-0.9,2.6-1.3
			c1.1-0.4,2.1-0.5,3.1-0.5c1.8,0,3.2,0.6,4.1,1.7c1,1.1,1.5,2.7,1.5,4.8v11.2H114.3z M109.6,31.1c-1.8,0.3-3.1,0.7-3.8,1.3
			c-0.7,0.6-1.1,1.5-1.1,2.8c0,1,0.3,1.9,1,2.5c0.7,0.7,1.6,1,2.8,1c1.7,0,3-0.6,4.1-1.8c1.1-1.2,1.7-2.8,1.7-4.8v-1.7L109.6,31.1z"
			/>
		<path class="st1" d="M129.2,24.1c-0.5-0.4-1.1-0.6-1.8-0.6c-1.4,0-2.5,0.7-3.4,2.1c-0.9,1.4-1.4,3.4-1.4,6v8.1h-1.5V22.4h1.5v3.8
			h0.1c0.4-1.3,1-2.3,1.9-3.1c0.9-0.7,1.8-1.1,3-1.1c0.6,0,1.2,0.1,1.7,0.3V24.1z"/>
		<path class="st0" d="M134.5,17.1v9.9h8.9v1.5h-8.9v11.3h-1.7V15.5h11.3v1.5H134.5z"/>
		<path class="st0" d="M155.4,40.1c-2.5,0-4.5-0.8-6-2.5c-1.5-1.7-2.2-3.8-2.2-6.5c0-2.9,0.8-5.1,2.3-6.7c1.5-1.6,3.6-2.4,6.1-2.4
			c2.5,0,4.4,0.8,5.8,2.4c1.4,1.6,2.1,3.8,2.1,6.7c0,2.7-0.7,4.9-2.2,6.5C160,39.3,158,40.1,155.4,40.1z M155.6,23.4
			c-2,0-3.7,0.7-4.9,2.1c-1.2,1.4-1.8,3.3-1.8,5.7c0,2.3,0.6,4.1,1.8,5.4c1.2,1.4,2.8,2.1,4.8,2.1c2.1,0,3.7-0.7,4.8-2
			c1.1-1.3,1.7-3.2,1.7-5.6c0-2.5-0.6-4.4-1.7-5.7C159.2,24.1,157.6,23.4,155.6,23.4z"/>
		<path class="st0" d="M176,24.1c-0.5-0.4-1.1-0.6-1.8-0.6c-1.4,0-2.5,0.7-3.4,2.1c-0.9,1.4-1.4,3.4-1.4,6v8.1h-1.5V22.4h1.5v3.8
			h0.1c0.4-1.3,1-2.3,1.9-3.1c0.9-0.7,1.8-1.1,3-1.1c0.6,0,1.2,0.1,1.7,0.3V24.1z"/>
		<path class="st0" d="M200.6,39.7V29.3c0-2.2-0.3-3.7-1-4.6c-0.7-0.9-1.8-1.3-3.2-1.3c-1.4,0-2.5,0.6-3.5,1.8
			c-1,1.2-1.5,2.6-1.5,4.4v10.1h-1.6V29.2c0-3.8-1.5-5.8-4.4-5.8c-1.4,0-2.6,0.6-3.5,1.8c-0.9,1.2-1.4,2.7-1.4,4.6v10H179V22.4h1.6
			v2.9h0.1c1.2-2.2,3-3.3,5.3-3.3c1.3,0,2.3,0.4,3.2,1.1c0.9,0.7,1.5,1.7,1.8,2.9c0.5-1.2,1.3-2.2,2.3-2.9c1-0.7,2.1-1,3.3-1
			c3.8,0,5.7,2.3,5.7,7v10.7H200.6z"/>
	</g>
</g>
</svg>

        </a>
      </div>
      <script>require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports=[
{"clusterId":1,"parentClusterId":0,"name":"miscellaneous","children":[2],"nodes":[{"aggregateId":1,"parentAggregateId":0,"name":null,"children":[2,3,4],"mark":["root",null,null],"type":null,"frames":[],"sources":[{"asyncId":1,"parentAsyncId":null,"triggerAsyncId":null,"executionAsyncId":null,"init":null,"before":[],"after":[],"destroy":null}]},{"aggregateId":2,"parentAggregateId":1,"name":"Object","children":[],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"typeName":"Object","fileName":"./node_modules/thunky/index.js","lineNumber":4,"columnNumber":9},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.require","typeName":"Module","fileName":"module.js","lineNumber":596,"columnNumber":17},{"functionName":"require","isToplevel":true,"fileName":"internal/module.js","lineNumber":11,"columnNumber":18},{"typeName":"Object","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":2,"columnNumber":14},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.require","typeName":"Module","fileName":"module.js","lineNumber":596,"columnNumber":17},{"functionName":"require","isToplevel":true,"fileName":"internal/module.js","lineNumber":11,"columnNumber":18},{"typeName":"Object","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":4,"columnNumber":14},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.require","typeName":"Module","fileName":"module.js","lineNumber":596,"columnNumber":17},{"functionName":"require","isToplevel":true,"fileName":"internal/module.js","lineNumber":11,"columnNumber":18},{"typeName":"Object","fileName":"./node_modules/mongojs/lib/database.js","lineNumber":1,"columnNumber":80},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.require","typeName":"Module","fileName":"module.js","lineNumber":596,"columnNumber":17},{"functionName":"require","isToplevel":true,"fileName":"internal/module.js","lineNumber":11,"columnNumber":18},{"typeName":"Object","fileName":"./node_modules/mongojs/index.js","lineNumber":1,"columnNumber":78},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.require","typeName":"Module","fileName":"module.js","lineNumber":596,"columnNumber":17},{"functionName":"require","isToplevel":true,"fileName":"internal/module.js","lineNumber":11,"columnNumber":18},{"typeName":"Object","fileName":"./1.js","lineNumber":1,"columnNumber":79},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":693,"columnNumber":10},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":9,"parentAsyncId":1,"triggerAsyncId":1,"executionAsyncId":1,"init":102403764.156,"before":[102404133.241],"after":[102404133.294],"destroy":102404156.552}]}]},
{"clusterId":2,"parentClusterId":1,"name":"nextTick + promise","children":[3,4,5,6,7,8],"nodes":[{"aggregateId":3,"parentAggregateId":1,"name":"Object","children":[5,6],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Boot.start","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":161,"columnNumber":11},{"functionName":"Promise","isToplevel":true,"fileName":"./node_modules/avvio/boot.js","lineNumber":270,"columnNumber":10},{"functionName":"Promise","isToplevel":true},{"functionName":"Boot.ready","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":268,"columnNumber":10},{"functionName":"server.(anonymous function)","typeName":"Object","fileName":"./node_modules/avvio/boot.js","lineNumber":46,"columnNumber":21},{"functionName":"listenPromise","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":274,"columnNumber":20},{"functionName":"listen","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":313,"columnNumber":34},{"typeName":"Object","fileName":"./1.js","lineNumber":34,"columnNumber":5},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":693,"columnNumber":10},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":15,"parentAsyncId":1,"triggerAsyncId":1,"executionAsyncId":1,"init":102404131.779,"before":[102404133.554],"after":[102404136.802],"destroy":102404156.598}]},{"aggregateId":4,"parentAggregateId":1,"name":"Object","children":[7],"mark":["user",null,null],"type":"PROMISE","frames":[{"functionName":"Promise","isToplevel":true},{"functionName":"Boot.ready","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":268,"columnNumber":10},{"functionName":"server.(anonymous function)","typeName":"Object","fileName":"./node_modules/avvio/boot.js","lineNumber":46,"columnNumber":21},{"functionName":"listenPromise","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":274,"columnNumber":20},{"functionName":"listen","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":313,"columnNumber":34},{"typeName":"Object","fileName":"./1.js","lineNumber":34,"columnNumber":5},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":693,"columnNumber":10},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":13,"parentAsyncId":1,"triggerAsyncId":1,"executionAsyncId":1,"init":102404131.038,"before":[],"after":[],"destroy":null}]},{"aggregateId":7,"parentAggregateId":4,"name":"Object","children":[9,10,11,12],"mark":["user",null,null],"type":"PROMISE","frames":[{"functionName":"then","typeName":"Promise"},{"functionName":"listenPromise","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":274,"columnNumber":28},{"functionName":"listen","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":313,"columnNumber":34},{"typeName":"Object","fileName":"./1.js","lineNumber":34,"columnNumber":5},{"functionName":"Module._compile","typeName":"Module","fileName":"module.js","lineNumber":652,"columnNumber":30},{"functionName":"Module._extensions..js","typeName":"Object","fileName":"module.js","lineNumber":663,"columnNumber":10},{"functionName":"Module.load","typeName":"Module","fileName":"module.js","lineNumber":565,"columnNumber":32},{"functionName":"tryModuleLoad","isToplevel":true,"fileName":"module.js","lineNumber":505,"columnNumber":12},{"functionName":"Module._load","typeName":"Function","fileName":"module.js","lineNumber":497,"columnNumber":3},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":693,"columnNumber":10},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":17,"parentAsyncId":13,"triggerAsyncId":13,"executionAsyncId":1,"init":102404132.177,"before":[102404140.357],"after":[102404142.753],"destroy":102406893.561}]}]},
{"clusterId":3,"parentClusterId":2,"name":"avvio","children":[],"nodes":[{"aggregateId":5,"parentAggregateId":3,"name":"Plugin.finish@avvio","children":[],"mark":["external","avvio",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Plugin.finish","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":112,"columnNumber":11},{"functionName":"toLoad.exec","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":126,"columnNumber":12},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":67,"columnNumber":5},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":19,"parentAsyncId":15,"triggerAsyncId":15,"executionAsyncId":15,"init":102404133.709,"before":[102404136.85],"after":[102404136.979],"destroy":102404156.625}]}]},
{"clusterId":4,"parentClusterId":2,"name":"avvio > fastify > fastq","children":[],"nodes":[{"aggregateId":6,"parentAggregateId":3,"name":"Plugin.finish@avvio","children":[8],"mark":["external","avvio",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Plugin.finish","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":112,"columnNumber":11},{"functionName":"toLoad.exec","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":126,"columnNumber":12},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":67,"columnNumber":5},{"functionName":"after","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":797,"columnNumber":7},{"functionName":"_encapsulateThreeParam","typeName":"Object","fileName":"./node_modules/avvio/boot.js","lineNumber":360,"columnNumber":7},{"functionName":"callWithCbOrNextTick","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":308,"columnNumber":5},{"functionName":"_after","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":212,"columnNumber":26},{"functionName":"Plugin.exec","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":45,"columnNumber":17},{"functionName":"loadPlugin","typeName":"Boot","fileName":"./node_modules/avvio/plugin.js","lineNumber":125,"columnNumber":10},{"functionName":"release","isToplevel":true,"fileName":"./node_modules/fastq/queue.js","lineNumber":127,"columnNumber":16},{"functionName":"resume","typeName":"Object","fileName":"./node_modules/fastq/queue.js","lineNumber":61,"columnNumber":7},{"functionName":"Plugin.finish","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":116,"columnNumber":10},{"functionName":"toLoad.exec","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":126,"columnNumber":12},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":67,"columnNumber":5},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":22,"parentAsyncId":15,"triggerAsyncId":15,"executionAsyncId":15,"init":102404136.339,"before":[102404137.034],"after":[102404138.208],"destroy":102404156.651}]},{"aggregateId":8,"parentAggregateId":6,"name":"Plugin.finish@avvio","children":[13],"mark":["external","avvio",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Plugin.finish","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":112,"columnNumber":11},{"functionName":"toLoad.exec","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":126,"columnNumber":12},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":67,"columnNumber":5},{"functionName":"afterRouteAdded","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":608,"columnNumber":7},{"functionName":"_encapsulateThreeParam","typeName":"Object","fileName":"./node_modules/avvio/boot.js","lineNumber":360,"columnNumber":7},{"functionName":"callWithCbOrNextTick","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":308,"columnNumber":5},{"functionName":"_after","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":212,"columnNumber":26},{"functionName":"Plugin.exec","typeName":"Plugin","fileName":"./node_modules/avvio/plugin.js","lineNumber":45,"columnNumber":17},{"functionName":"loadPlugin","typeName":"Boot","fileName":"./node_modules/avvio/plugin.js","lineNumber":125,"columnNumber":10},{"functionName":"release","typeName":"Task","fileName":"./node_modules/fastq/queue.js","lineNumber":127,"columnNumber":16},{"functionName":"worked","isToplevel":true,"fileName":"./node_modules/fastq/queue.js","lineNumber":169,"columnNumber":10},{"functionName":"toLoad.finish","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":128,"columnNumber":7},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":86,"columnNumber":5},{"functionName":"check","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":97,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":24,"parentAsyncId":22,"triggerAsyncId":22,"executionAsyncId":22,"init":102404137.754,"before":[102404138.239],"after":[102404138.6],"destroy":102404156.67}]},{"aggregateId":13,"parentAggregateId":8,"name":"q.drain@avvio","children":[19],"mark":["external","avvio",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"q.drain","typeName":"Object","fileName":"./node_modules/avvio/plugin.js","lineNumber":107,"columnNumber":17},{"functionName":"release","typeName":"Task","fileName":"./node_modules/fastq/queue.js","lineNumber":135,"columnNumber":12},{"functionName":"worked","isToplevel":true,"fileName":"./node_modules/fastq/queue.js","lineNumber":169,"columnNumber":10},{"functionName":"toLoad.finish","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":128,"columnNumber":7},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":86,"columnNumber":5},{"functionName":"check","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":97,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":27,"parentAsyncId":24,"triggerAsyncId":24,"executionAsyncId":24,"init":102404138.309,"before":[102404138.648],"after":[102404140.126],"destroy":102404156.696}]},{"aggregateId":19,"parentAggregateId":13,"name":"readyPromiseCB@avvio","children":[],"mark":["external","avvio",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"readyPromiseCB","isToplevel":true,"fileName":"./node_modules/avvio/boot.js","lineNumber":278,"columnNumber":15},{"functionName":"callWithCbOrNextTick","typeName":"Boot","fileName":"./node_modules/avvio/boot.js","lineNumber":310,"columnNumber":5},{"functionName":"release","isToplevel":true,"fileName":"./node_modules/fastq/queue.js","lineNumber":127,"columnNumber":16},{"functionName":"resume","typeName":"Object","fileName":"./node_modules/fastq/queue.js","lineNumber":61,"columnNumber":7},{"functionName":"Boot.Plugin.loadPlugin.call","isToplevel":true,"fileName":"./node_modules/avvio/boot.js","lineNumber":150,"columnNumber":20},{"functionName":"toLoad.finish","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":128,"columnNumber":7},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":86,"columnNumber":5},{"functionName":"check","isToplevel":true,"fileName":"./node_modules/avvio/plugin.js","lineNumber":97,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":29,"parentAsyncId":27,"triggerAsyncId":27,"executionAsyncId":27,"init":102404139.755,"before":[102404140.16],"after":[102404140.231],"destroy":102404156.714}]}]},
{"clusterId":5,"parentClusterId":2,"name":"fastify","children":[9,10],"nodes":[{"aggregateId":9,"parentAggregateId":7,"name":"Promise@fastify","children":[14,15],"mark":["external","fastify",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"lookup","typeName":"Object","fileName":"dns.js","lineNumber":171,"columnNumber":15},{"functionName":"lookupAndListen","isToplevel":true,"fileName":"net.js","lineNumber":1500,"columnNumber":7},{"functionName":"Server.listen","typeName":"Server","fileName":"net.js","lineNumber":1476,"columnNumber":7},{"functionName":"Promise","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":284,"columnNumber":16},{"functionName":"Promise","isToplevel":true},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":283,"columnNumber":20},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":37,"parentAsyncId":17,"triggerAsyncId":17,"executionAsyncId":17,"init":102404141.588,"before":[102404143.243],"after":[102404144.725],"destroy":102404156.77}]},{"aggregateId":14,"parentAggregateId":9,"name":"init@on-net-listen","children":[],"mark":["external","on-net-listen",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"init","typeName":"AsyncHook","fileName":"../../../.nvm/versions/node/v8.11.3/lib/node_modules/@nearform/clinic/node_modules/on-net-listen/index.js","lineNumber":13,"columnNumber":17},{"functionName":"createServerHandle","isToplevel":true,"fileName":"net.js","lineNumber":1279,"columnNumber":14},{"functionName":"setupListenHandle","typeName":"Server","fileName":"net.js","lineNumber":1335,"columnNumber":14},{"functionName":"listenInCluster","isToplevel":true,"fileName":"net.js","lineNumber":1396,"columnNumber":12},{"functionName":"doListen","isToplevel":true,"fileName":"net.js","lineNumber":1505,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":141,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":50,"parentAsyncId":37,"triggerAsyncId":37,"executionAsyncId":37,"init":102404143.929,"before":[102404144.859],"after":[102404144.924],"destroy":102404156.842}]},{"aggregateId":15,"parentAggregateId":9,"name":null,"children":[20,21],"mark":["nodecore","net","server"],"type":"TCPSERVERWRAP","frames":[{"functionName":"createServerHandle","isToplevel":true,"fileName":"net.js","lineNumber":1279,"columnNumber":14},{"functionName":"setupListenHandle","typeName":"Server","fileName":"net.js","lineNumber":1335,"columnNumber":14},{"functionName":"listenInCluster","isToplevel":true,"fileName":"net.js","lineNumber":1396,"columnNumber":12},{"functionName":"doListen","isToplevel":true,"fileName":"net.js","lineNumber":1505,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":141,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":47,"parentAsyncId":37,"triggerAsyncId":37,"executionAsyncId":37,"init":102404143.637,"before":[102404497.363,102404501.179],"after":[102404500.988,102404502.723],"destroy":null}]},{"aggregateId":20,"parentAggregateId":15,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"internalNextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":305,"columnNumber":7},{"functionName":"setupListenHandle","typeName":"Server","fileName":"net.js","lineNumber":1369,"columnNumber":3},{"functionName":"listenInCluster","isToplevel":true,"fileName":"net.js","lineNumber":1396,"columnNumber":12},{"functionName":"doListen","isToplevel":true,"fileName":"net.js","lineNumber":1505,"columnNumber":7},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":141,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":52,"parentAsyncId":47,"triggerAsyncId":47,"executionAsyncId":37,"init":102404144.492,"before":[102404144.952],"after":[102404145.824],"destroy":102404156.86}]},{"aggregateId":21,"parentAggregateId":15,"name":null,"children":[22,23,24,25,26],"mark":["nodecore","net","onconnection"],"type":"TCPWRAP","frames":[],"sources":[{"asyncId":57,"parentAsyncId":47,"triggerAsyncId":47,"executionAsyncId":0,"init":102404497.107,"before":[102409508.108,102409510.173],"after":[102409510.079,102409510.456],"destroy":102409510.464},{"asyncId":71,"parentAsyncId":47,"triggerAsyncId":47,"executionAsyncId":0,"init":102404501.08,"before":[102409510.481,102409511.404],"after":[102409511.284,102409511.46],"destroy":102409511.464}]},{"aggregateId":22,"parentAggregateId":21,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"resume","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":815,"columnNumber":13},{"functionName":"Readable.resume","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":807,"columnNumber":5},{"functionName":"Readable.on","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":777,"columnNumber":12},{"functionName":"connectionListenerInternal","isToplevel":true,"fileName":"_http_server.js","lineNumber":350,"columnNumber":10},{"functionName":"connectionListener","typeName":"Server","fileName":"_http_server.js","lineNumber":296,"columnNumber":3},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"onconnection","typeName":"TCP","fileName":"net.js","lineNumber":1565,"columnNumber":8}],"sources":[{"asyncId":69,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":47,"init":102404500.411,"before":[102404500.882],"after":[102404500.959],"destroy":102404501.037},{"asyncId":80,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":47,"init":102404502.27,"before":[102404502.67],"after":[102404502.699],"destroy":102404523.321}]},{"aggregateId":23,"parentAggregateId":21,"name":null,"children":[],"mark":["nodecore",null,null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"connectionListenerInternal","isToplevel":true,"fileName":"_http_server.js","lineNumber":315,"columnNumber":12},{"functionName":"connectionListener","typeName":"Server","fileName":"_http_server.js","lineNumber":296,"columnNumber":3},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"onconnection","typeName":"TCP","fileName":"net.js","lineNumber":1565,"columnNumber":8}],"sources":[{"asyncId":63,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":47,"init":102404499.486,"before":[],"after":[],"destroy":102405375.456},{"asyncId":74,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":47,"init":102404501.357,"before":[],"after":[],"destroy":102405345.296}]},{"aggregateId":24,"parentAggregateId":21,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"endReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":1055,"columnNumber":13},{"functionName":"Readable.read","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":393,"columnNumber":7},{"functionName":"flow","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":846,"columnNumber":34},{"functionName":"emitReadable_","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":514,"columnNumber":3},{"functionName":"emitReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":507,"columnNumber":7},{"functionName":"onEofChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":492,"columnNumber":3},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":220,"columnNumber":5},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":626,"columnNumber":8}],"sources":[{"asyncId":1738,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":57,"init":102409508.227,"before":[102409508.983],"after":[102409509.968],"destroy":102409510.089},{"asyncId":1744,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":71,"init":102409510.52,"before":[102409511.03],"after":[102409511.192],"destroy":102409511.355}]},{"aggregateId":25,"parentAggregateId":21,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"endReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":1055,"columnNumber":13},{"functionName":"Readable.read","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":393,"columnNumber":7},{"functionName":"onSocketEnd","typeName":"Socket","fileName":"net.js","lineNumber":346,"columnNumber":10},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":106,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":636,"columnNumber":8}],"sources":[{"asyncId":1742,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":57,"init":102409508.753,"before":[102409510.037],"after":[102409510.048],"destroy":102409510.133},{"asyncId":1747,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":71,"init":102409510.821,"before":[102409511.248],"after":[102409511.257],"destroy":102409511.386}]},{"aggregateId":26,"parentAggregateId":21,"name":null,"children":[27,28,29,30,31,32,33],"mark":["nodecore","net","onrequest"],"type":"HTTPPARSER","frames":[{"functionName":"connectionListenerInternal","isToplevel":true,"fileName":"_http_server.js","lineNumber":319,"columnNumber":10},{"functionName":"connectionListener","typeName":"Server","fileName":"_http_server.js","lineNumber":296,"columnNumber":3},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"onconnection","typeName":"TCP","fileName":"net.js","lineNumber":1565,"columnNumber":8}],"sources":[{"asyncId":67,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":47,"init":102404500.198,"before":[102404502.811,102404522.346,102404522.752,102405371.003,102405373.096,102405373.326,102406138.476,102406140.21,102406140.427,102406897.478,102406898.177,102406898.298,102407683.608,102407684.24,102407684.357,102408437.121,102408437.815,102408437.948,102409196.658,102409197.391,102409197.526],"after":[102404522.339,102404522.745,102404523.271,102405373.089,102405373.32,102405375.404,102406140.203,102406140.421,102406142.492,102406898.172,102406898.294,102406900.115,102407684.235,102407684.352,102407685.723,102408437.811,102408437.944,102408439.679,102409197.386,102409197.522,102409199.43],"destroy":102409510.401},{"asyncId":65,"parentAsyncId":57,"triggerAsyncId":57,"executionAsyncId":47,"init":102404499.912,"before":[],"after":[],"destroy":null},{"asyncId":78,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":47,"init":102404502.054,"before":[102404524.347,102404525.951,102404526.302,102405342.223,102405342.994,102405343.136,102406124.491,102406125.267,102406125.457,102406875.873,102406876.574,102406876.704,102407650.473,102407651.252,102407651.373,102408398.261,102408398.966,102408399.142,102409143.216,102409143.909,102409144.033],"after":[102404525.941,102404526.294,102404526.464,102405342.99,102405343.132,102405344.674,102406125.263,102406125.433,102406127.318,102406876.57,102406876.7,102406878.359,102407651.247,102407651.368,102407652.758,102408398.962,102408399.136,102408400.782,102409143.905,102409144.029,102409145.587],"destroy":102409511.443},{"asyncId":76,"parentAsyncId":71,"triggerAsyncId":71,"executionAsyncId":47,"init":102404501.622,"before":[],"after":[],"destroy":null}]},{"aggregateId":28,"parentAggregateId":26,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"emitReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":505,"columnNumber":15},{"functionName":"onEofChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":492,"columnNumber":3},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":220,"columnNumber":5},{"functionName":"Readable.push","typeName":"IncomingMessage","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"parserOnMessageComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":151,"columnNumber":12}],"sources":[{"asyncId":96,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102404522.509,"before":[102404523.206],"after":[102404523.234],"destroy":102404523.397},{"asyncId":424,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102405373.12,"before":[102405373.817],"after":[102405373.829],"destroy":102405375.615},{"asyncId":685,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406140.23,"before":[102406140.919],"after":[102406140.931],"destroy":102406142.704},{"asyncId":946,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406898.19,"before":[102406898.597],"after":[102406898.608],"destroy":102406900.321},{"asyncId":1206,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102407684.252,"before":[102407684.641],"after":[102407684.649],"destroy":102407685.953},{"asyncId":1463,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102408437.828,"before":[102408438.259],"after":[102408438.266],"destroy":102408439.889},{"asyncId":1724,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102409197.402,"before":[102409197.834],"after":[102409197.841],"destroy":102409199.571},{"asyncId":105,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102404526.002,"before":[102404526.421],"after":[102404526.433],"destroy":102404526.503},{"asyncId":349,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102405343.008,"before":[102405343.458],"after":[102405343.467],"destroy":102405345.482},{"asyncId":609,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406125.281,"before":[102406125.825],"after":[102406125.834],"destroy":102406127.509},{"asyncId":870,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406876.587,"before":[102406877.011],"after":[102406877.019],"destroy":102406878.588},{"asyncId":1127,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102407651.264,"before":[102407651.671],"after":[102407651.679],"destroy":102407652.967},{"asyncId":1388,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102408398.979,"before":[102408399.584],"after":[102408399.593],"destroy":102408400.991},{"asyncId":1648,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102409143.921,"before":[102409144.342],"after":[102409144.349],"destroy":102409145.821}]},{"aggregateId":31,"parentAggregateId":26,"name":null,"children":[],"mark":["nodecore",null,null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"resetSocketTimeout","isToplevel":true,"fileName":"_http_server.js","lineNumber":628,"columnNumber":10},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":563,"columnNumber":3},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":417,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102405371.095,"before":[],"after":[],"destroy":102406142.544},{"asyncId":678,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406138.521,"before":[],"after":[],"destroy":102406900.17},{"asyncId":939,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406897.524,"before":[],"after":[],"destroy":102407685.793},{"asyncId":1199,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102407683.647,"before":[],"after":[],"destroy":102408439.73},{"asyncId":1456,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102408437.158,"before":[],"after":[],"destroy":102409199.466},{"asyncId":1717,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102409196.713,"before":[],"after":[],"destroy":102409510.098},{"asyncId":342,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102405342.297,"before":[],"after":[],"destroy":102406127.371},{"asyncId":602,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406124.544,"before":[],"after":[],"destroy":102406878.429},{"asyncId":863,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406875.919,"before":[],"after":[],"destroy":102407652.81},{"asyncId":1120,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102407650.519,"before":[],"after":[],"destroy":102408400.833},{"asyncId":1381,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102408398.307,"before":[],"after":[],"destroy":102409145.665},{"asyncId":1641,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102409143.255,"before":[],"after":[],"destroy":102409511.364}]}]},
{"clusterId":6,"parentClusterId":2,"name":"fastify","children":[],"nodes":[{"aggregateId":10,"parentAggregateId":7,"name":"fastify.ready.then@fastify","children":[16],"mark":["external","fastify",null],"type":"PROMISE","frames":[{"functionName":"Promise","isToplevel":true},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":276,"columnNumber":22},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":32,"parentAsyncId":17,"triggerAsyncId":17,"executionAsyncId":17,"init":102404140.441,"before":[],"after":[],"destroy":102406893.57}]},{"aggregateId":16,"parentAggregateId":10,"name":"fastify.ready.then@fastify","children":[],"mark":["external","fastify",null],"type":"PROMISE","frames":[{"functionName":"then","typeName":"Promise"},{"functionName":"race","typeName":"Function"},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":292,"columnNumber":22},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":41,"parentAsyncId":32,"triggerAsyncId":32,"executionAsyncId":17,"init":102404142.267,"before":[],"after":[],"destroy":102406893.582}]}]},
{"clusterId":7,"parentClusterId":2,"name":"fastify","children":[],"nodes":[{"aggregateId":11,"parentAggregateId":7,"name":"fastify.ready.then@fastify","children":[17],"mark":["external","fastify",null],"type":"PROMISE","frames":[{"functionName":"Promise","isToplevel":true},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":283,"columnNumber":20},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":35,"parentAsyncId":17,"triggerAsyncId":17,"executionAsyncId":17,"init":102404140.728,"before":[],"after":[],"destroy":102406893.574}]},{"aggregateId":17,"parentAggregateId":11,"name":"fastify.ready.then@fastify","children":[],"mark":["external","fastify",null],"type":"PROMISE","frames":[{"functionName":"then","typeName":"Promise"},{"functionName":"race","typeName":"Function"},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":292,"columnNumber":22},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":43,"parentAsyncId":35,"triggerAsyncId":35,"executionAsyncId":17,"init":102404142.497,"before":[102404145.865],"after":[102404145.872],"destroy":102406893.585}]}]},
{"clusterId":8,"parentClusterId":2,"name":"fastify","children":[],"nodes":[{"aggregateId":12,"parentAggregateId":7,"name":"fastify.ready.then@fastify","children":[18],"mark":["external","fastify",null],"type":"PROMISE","frames":[{"functionName":"race","typeName":"Function"},{"functionName":"fastify.ready.then","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":292,"columnNumber":22},{"isToplevel":true},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":39,"parentAsyncId":17,"triggerAsyncId":17,"executionAsyncId":17,"init":102404142.061,"before":[],"after":[],"destroy":102406893.578}]},{"aggregateId":18,"parentAggregateId":12,"name":null,"children":[],"mark":["nodecore",null,null],"type":"PROMISE","frames":[{"functionName":"then","typeName":"Promise"},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":188,"columnNumber":7},{"functionName":"Module.runMain","typeName":"Function","fileName":"module.js","lineNumber":695,"columnNumber":11},{"functionName":"startup","isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":191,"columnNumber":16},{"isToplevel":true,"fileName":"bootstrap_node.js","lineNumber":612,"columnNumber":3}],"sources":[{"asyncId":45,"parentAsyncId":39,"triggerAsyncId":39,"executionAsyncId":1,"init":102404142.762,"before":[102404145.879],"after":[102404145.884],"destroy":102406893.588}]}]},
{"clusterId":9,"parentClusterId":5,"name":"nextTick + timeout + connection","children":[11,12,13,14,15,16],"nodes":[{"aggregateId":27,"parentAggregateId":26,"name":"Object","children":[],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"resume","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":815,"columnNumber":13},{"functionName":"Readable.resume","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":807,"columnNumber":5},{"functionName":"Readable.on","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":777,"columnNumber":12},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":487,"columnNumber":19},{"functionName":"Pool.connect","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":666,"columnNumber":16},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":399,"columnNumber":17},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb/lib/server.js","lineNumber":368,"columnNumber":17},{"functionName":"open","isToplevel":true,"fileName":"./node_modules/mongodb/lib/db.js","lineNumber":229,"columnNumber":19},{"functionName":"Db.open","typeName":"Db","fileName":"./node_modules/mongodb/lib/db.js","lineNumber":252,"columnNumber":44},{"functionName":"createServer","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":391,"columnNumber":6},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":512,"columnNumber":14},{"functionName":"parseHandler","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":118,"columnNumber":38},{"functionName":"module.exports","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":98,"columnNumber":5},{"functionName":"connect","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":485,"columnNumber":3},{"functionName":"MongoClient.connect","typeName":"Function","fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":250,"columnNumber":3},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/database.js","lineNumber":29,"columnNumber":15},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":35},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":94,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102404521.553,"before":[102404523.106],"after":[102404523.167],"destroy":102404523.379}]},{"aggregateId":29,"parentAggregateId":26,"name":"Object","children":[],"mark":["user",null,null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":424,"columnNumber":19},{"functionName":"Pool.connect","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":666,"columnNumber":16},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":399,"columnNumber":17},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb/lib/server.js","lineNumber":368,"columnNumber":17},{"functionName":"open","isToplevel":true,"fileName":"./node_modules/mongodb/lib/db.js","lineNumber":229,"columnNumber":19},{"functionName":"Db.open","typeName":"Db","fileName":"./node_modules/mongodb/lib/db.js","lineNumber":252,"columnNumber":44},{"functionName":"createServer","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":391,"columnNumber":6},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":512,"columnNumber":14},{"functionName":"parseHandler","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":118,"columnNumber":38},{"functionName":"module.exports","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":98,"columnNumber":5},{"functionName":"connect","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":485,"columnNumber":3},{"functionName":"MongoClient.connect","typeName":"Function","fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":250,"columnNumber":3},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/database.js","lineNumber":29,"columnNumber":15},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":35},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":92,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102404519.52,"before":[],"after":[],"destroy":102404537.902}]},{"aggregateId":30,"parentAggregateId":26,"name":"Object","children":[34],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":35},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":422,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102405372.603,"before":[102405373.423],"after":[102405373.782],"destroy":102405375.598},{"asyncId":683,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406139.737,"before":[102406140.523],"after":[102406140.885],"destroy":102406142.689},{"asyncId":944,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406897.924,"before":[102406898.359],"after":[102406898.565],"destroy":102406900.306},{"asyncId":1204,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102407684.01,"before":[102407684.42],"after":[102407684.619],"destroy":102407685.937},{"asyncId":1461,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102408437.55,"before":[102408438.011],"after":[102408438.235],"destroy":102408439.871},{"asyncId":1722,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102409197.119,"before":[102409197.585],"after":[102409197.807],"destroy":102409199.561},{"asyncId":347,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102405342.741,"before":[102405343.206],"after":[102405343.433],"destroy":102405345.464},{"asyncId":607,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406124.979,"before":[102406125.534],"after":[102406125.8],"destroy":102406127.495},{"asyncId":868,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406876.316,"before":[102406876.768],"after":[102406876.987],"destroy":102406878.573},{"asyncId":1125,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102407650.878,"before":[102407651.434],"after":[102407651.648],"destroy":102407652.952},{"asyncId":1386,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102408398.711,"before":[102408399.229],"after":[102408399.559],"destroy":102408400.976},{"asyncId":1646,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102409143.654,"before":[102409144.1],"after":[102409144.319],"destroy":102409145.805}]},{"aggregateId":33,"parentAggregateId":26,"name":"Object","children":[39,40,41,42,43,44],"mark":["user",null,null],"type":"TCPWRAP","frames":[{"functionName":"Socket.connect","typeName":"Socket","fileName":"net.js","lineNumber":997,"columnNumber":7},{"functionName":"connect","typeName":"Object","fileName":"net.js","lineNumber":113,"columnNumber":35},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":420,"columnNumber":25},{"functionName":"Pool.connect","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":666,"columnNumber":16},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":399,"columnNumber":17},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb/lib/server.js","lineNumber":368,"columnNumber":17},{"functionName":"open","isToplevel":true,"fileName":"./node_modules/mongodb/lib/db.js","lineNumber":229,"columnNumber":19},{"functionName":"Db.open","typeName":"Db","fileName":"./node_modules/mongodb/lib/db.js","lineNumber":252,"columnNumber":44},{"functionName":"createServer","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":391,"columnNumber":6},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":512,"columnNumber":14},{"functionName":"parseHandler","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":118,"columnNumber":38},{"functionName":"module.exports","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":98,"columnNumber":5},{"functionName":"connect","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":485,"columnNumber":3},{"functionName":"MongoClient.connect","typeName":"Function","fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":250,"columnNumber":3},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/database.js","lineNumber":29,"columnNumber":15},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":35},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":86,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102404514.838,"before":[102404538.208,102404978.146,102405362.044,102405769.821,102406130.546,102406541.83,102406888.647,102407311.684,102407676.72,102408085.279,102408430.431,102408849.245,102409188.053],"after":[102404560.963,102404980.86,102405363.241,102405771.081,102406131.965,102406543.09,102406890.033,102407313.123,102407677.85,102408086.588,102408431.612,102408850.431,102409189.853],"destroy":null}]},{"aggregateId":39,"parentAggregateId":33,"name":"Object","children":[],"mark":["user",null,null],"type":"GETADDRINFOREQWRAP","frames":[{"functionName":"lookup","isToplevel":true,"fileName":"dns.js","lineNumber":182,"columnNumber":19},{"isToplevel":true,"fileName":"net.js","lineNumber":1087,"columnNumber":5},{"functionName":"lookupAndConnect","isToplevel":true,"fileName":"net.js","lineNumber":1086,"columnNumber":3},{"functionName":"Socket.connect","typeName":"Socket","fileName":"net.js","lineNumber":1021,"columnNumber":5},{"functionName":"connect","typeName":"Object","fileName":"net.js","lineNumber":113,"columnNumber":35},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":420,"columnNumber":25},{"functionName":"Pool.connect","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":666,"columnNumber":16},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":399,"columnNumber":17},{"functionName":"Server.connect","typeName":"Server","fileName":"./node_modules/mongodb/lib/server.js","lineNumber":368,"columnNumber":17},{"functionName":"open","isToplevel":true,"fileName":"./node_modules/mongodb/lib/db.js","lineNumber":229,"columnNumber":19},{"functionName":"Db.open","typeName":"Db","fileName":"./node_modules/mongodb/lib/db.js","lineNumber":252,"columnNumber":44},{"functionName":"createServer","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":391,"columnNumber":6},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":512,"columnNumber":14},{"functionName":"parseHandler","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":118,"columnNumber":38},{"functionName":"module.exports","isToplevel":true,"fileName":"./node_modules/mongodb/lib/url_parser.js","lineNumber":98,"columnNumber":5},{"functionName":"connect","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":485,"columnNumber":3},{"functionName":"MongoClient.connect","typeName":"Function","fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":250,"columnNumber":3},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/database.js","lineNumber":29,"columnNumber":15},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":35},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":88,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":67,"init":102404517.209,"before":[102404523.557],"after":[102404524.313],"destroy":102404524.319}]}]},
{"clusterId":10,"parentClusterId":5,"name":"mongojs:cursor","children":[17,18,19,20,21,22],"nodes":[{"aggregateId":32,"parentAggregateId":26,"name":"Object","children":[35,36,37,38],"mark":["user",null,null],"type":"mongojs:cursor","frames":[{"functionName":"Cursor","isConstructor":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":17,"columnNumber":25},{"functionName":"Collection.find","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":39,"columnNumber":16},{"typeName":"Object","fileName":"./1.js","lineNumber":11,"columnNumber":7},{"functionName":"preHandlerCallback","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":85,"columnNumber":30},{"functionName":"handler","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":69,"columnNumber":5},{"functionName":"handleRequest","isToplevel":true,"fileName":"./node_modules/fastify/lib/handleRequest.js","lineNumber":18,"columnNumber":5},{"functionName":"onRunMiddlewares","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":395,"columnNumber":5},{"functionName":"middlewareCallback","isToplevel":true,"fileName":"./node_modules/fastify/fastify.js","lineNumber":383,"columnNumber":7},{"functionName":"routeHandler","typeName":"Object","fileName":"./node_modules/fastify/fastify.js","lineNumber":243,"columnNumber":7},{"functionName":"lookup","typeName":"Router","fileName":"./node_modules/find-my-way/index.js","lineNumber":307,"columnNumber":17},{"functionName":"emitTwo","isToplevel":true,"fileName":"events.js","lineNumber":126,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":214,"columnNumber":7},{"functionName":"parserOnIncoming","isToplevel":true,"fileName":"_http_server.js","lineNumber":619,"columnNumber":12},{"functionName":"parserOnHeadersComplete","typeName":"HTTPParser","fileName":"_http_common.js","lineNumber":112,"columnNumber":17}],"sources":[{"asyncId":83,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102404506.563,"before":[102404980.331,102404981.15,102404981.794,102404982.392,102404982.95,102404983.514],"after":[102404980.703,102404981.372,102404982.008,102404982.611,102404983.157,102404984.038],"destroy":null},{"asyncId":420,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102405371.558,"before":[102405770.708,102405771.386,102405771.935,102405772.474,102405772.996,102405773.522],"after":[102405770.955,102405771.596,102405772.144,102405772.678,102405773.201,102405774.048],"destroy":null},{"asyncId":681,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406138.723,"before":[102406542.797,102406543.336,102406543.876,102406544.387,102406544.934,102406545.887],"after":[102406543.007,102406543.547,102406544.078,102406544.588,102406545.398,102406546.463],"destroy":null},{"asyncId":942,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102406897.713,"before":[102407312.833,102407313.354,102407313.843,102407314.328,102407314.828,102407315.319],"after":[102407313.038,102407313.537,102407314.029,102407314.507,102407315.009,102407315.763],"destroy":null},{"asyncId":1202,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102407683.831,"before":[102408086.277,102408086.824,102408087.479,102408087.985,102408088.474,102408088.98],"after":[102408086.501,102408087.054,102408087.666,102408088.165,102408088.66,102408089.435],"destroy":null},{"asyncId":1459,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102408437.347,"before":[102408850.131,102408850.676,102408851.2,102408851.866,102408852.398,102408852.924],"after":[102408850.343,102408850.879,102408851.528,102408852.067,102408852.598,102408853.467],"destroy":null},{"asyncId":1720,"parentAsyncId":67,"triggerAsyncId":67,"executionAsyncId":67,"init":102409196.907,"before":[],"after":[],"destroy":null},{"asyncId":102,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102404525.165,"before":[102404955.424,102404956.602,102404957.437,102404958.164,102404958.803,102404959.791],"after":[102404956.008,102404956.859,102404957.657,102404958.448,102404959.009,102404960.44],"destroy":null},{"asyncId":345,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102405342.53,"before":[102405756.673,102405757.307,102405757.869,102405758.421,102405758.96,102405759.742],"after":[102405756.888,102405757.533,102405758.082,102405758.631,102405759.324,102405760.279],"destroy":null},{"asyncId":605,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406124.756,"before":[102406528.192,102406528.744,102406529.372,102406529.895,102406530.433,102406530.969],"after":[102406528.4,102406529.033,102406529.574,102406530.093,102406530.633,102406531.489],"destroy":null},{"asyncId":866,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102406876.115,"before":[102407283.588,102407284.09,102407284.598,102407285.093,102407285.588,102407286.076],"after":[102407283.776,102407284.276,102407284.781,102407285.281,102407285.768,102407286.524],"destroy":null},{"asyncId":1123,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102407650.698,"before":[102408057.639,102408058.151,102408058.654,102408059.2,102408059.953,102408060.45],"after":[102408057.825,102408058.331,102408058.836,102408059.53,102408060.144,102408060.901],"destroy":null},{"asyncId":1384,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102408398.506,"before":[102408806.352,102408806.889,102408807.416,102408807.955,102408808.507,102408809.033],"after":[102408806.558,102408807.096,102408807.621,102408808.157,102408808.71,102408809.685],"destroy":null},{"asyncId":1644,"parentAsyncId":78,"triggerAsyncId":78,"executionAsyncId":78,"init":102409143.448,"before":[],"after":[],"destroy":null}]},{"aggregateId":37,"parentAggregateId":32,"name":"finished@thunky","children":[48],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Collection","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Collection._getCollection","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":17,"columnNumber":10},{"functionName":"getCursor","isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":32,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":19,"columnNumber":5},{"functionName":"run","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":19,"columnNumber":5},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"Cursor.toArray","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":81,"columnNumber":3},{"functionName":"Cursor.(anonymous function)","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":126,"columnNumber":25},{"isToplevel":true,"fileName":"./1.js","lineNumber":13,"columnNumber":36},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":73,"columnNumber":24},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"setCursorDeadAndNotified","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":505,"columnNumber":3},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":608,"columnNumber":12},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":269,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404983.767,"before":[102404984.1],"after":[102404984.326],"destroy":102404985.667},{"asyncId":531,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405773.767,"before":[102405774.106],"after":[102405774.332],"destroy":102405775.586},{"asyncId":792,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406546.186,"before":[102406546.522],"after":[102406546.751],"destroy":102406548.153},{"asyncId":1053,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407315.53,"before":[102407315.821],"after":[102407316.027],"destroy":102407317.17},{"asyncId":1314,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408089.202,"before":[102408089.493],"after":[102408089.7],"destroy":102408090.854},{"asyncId":1570,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408853.192,"before":[102408853.525],"after":[102408853.751],"destroy":102408855.104},{"asyncId":216,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404960.14,"before":[102404960.505],"after":[102404960.735],"destroy":102404962.099},{"asyncId":478,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405760.002,"before":[102405760.341],"after":[102405760.568],"destroy":102405761.935},{"asyncId":739,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406531.21,"before":[102406531.547],"after":[102406531.777],"destroy":102406533.025},{"asyncId":1000,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407286.29,"before":[102407286.581],"after":[102407286.797],"destroy":102407288.073},{"asyncId":1261,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408060.667,"before":[102408060.96],"after":[102408061.167],"destroy":102408062.368},{"asyncId":1517,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408809.274,"before":[102408809.747],"after":[102408809.998],"destroy":102408811.225}]},{"aggregateId":38,"parentAggregateId":32,"name":"Cursor@mongojs","children":[49,50,51,52,53],"mark":["user",null,null],"type":"mongojs:cursor","frames":[{"functionName":"Cursor","isConstructor":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":17,"columnNumber":25},{"functionName":"Collection.find","typeName":"Collection","fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":39,"columnNumber":16},{"isToplevel":true,"fileName":"./1.js","lineNumber":13,"columnNumber":9},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":73,"columnNumber":24},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"setCursorDeadAndNotified","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":505,"columnNumber":3},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":608,"columnNumber":12},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":267,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404983.538,"before":[102405362.945,102405363.494,102405364.019,102405364.556,102405366.127,102405366.981],"after":[102405363.154,102405363.699,102405364.224,102405365.637,102405366.482,102405369.202],"destroy":null},{"asyncId":529,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405773.543,"before":[102406131.603,102406132.273,102406132.961,102406133.652,102406134.286,102406134.845],"after":[102406131.862,102406132.537,102406133.284,102406133.878,102406134.509,102406137.365],"destroy":null},{"asyncId":790,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406545.918,"before":[102406889.67,102406890.34,102406891.004,102406891.647,102406892.27,102406894.265],"after":[102406889.936,102406890.6,102406891.25,102406891.877,102406893.898,102406896.349],"destroy":null},{"asyncId":1051,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407315.341,"before":[102407677.578,102407678.077,102407678.576,102407679.358,102407679.931,102407680.421],"after":[102407677.765,102407678.26,102407678.755,102407679.57,102407680.119,102407682.645],"destroy":null},{"asyncId":1312,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408089.011,"before":[102408431.316,102408431.853,102408432.383,102408432.903,102408433.418,102408433.953],"after":[102408431.522,102408432.061,102408432.59,102408433.104,102408433.62,102408436.112],"destroy":null},{"asyncId":1568,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408852.945,"before":[102409189.392,102409190.226,102409191.058,102409192.111,102409192.827,102409193.365],"after":[102409189.733,102409190.575,102409191.398,102409192.462,102409193.034,102409195.619],"destroy":null},{"asyncId":214,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404959.882,"before":[102405331.554,102405332.115,102405332.684,102405333.226,102405333.76,102405334.3],"after":[102405331.77,102405332.32,102405332.89,102405333.43,102405333.971,102405339.7],"destroy":null},{"asyncId":476,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405759.773,"before":[102406116.532,102406117.383,102406118.176,102406118.806,102406119.653,102406120.253],"after":[102406116.872,102406117.685,102406118.448,102406119.2,102406119.889,102406123.353],"destroy":null},{"asyncId":737,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406530.994,"before":[102406869.407,102406869.952,102406870.514,102406871.049,102406871.586,102406872.103],"after":[102406869.614,102406870.164,102406870.718,102406871.254,102406871.792,102406874.805],"destroy":null},{"asyncId":998,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407286.099,"before":[102407645.132,102407645.635,102407646.174,102407646.671,102407647.154,102407647.743],"after":[102407645.32,102407645.825,102407646.355,102407646.85,102407647.333,102407649.517],"destroy":null},{"asyncId":1259,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408060.473,"before":[102408391.403,102408391.912,102408392.416,102408392.926,102408394.169,102408394.95],"after":[102408391.59,102408392.093,102408392.597,102408393.71,102408394.487,102408397.211],"destroy":null},{"asyncId":1515,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408809.062,"before":[102409136.413,102409136.993,102409137.524,102409138.053,102409138.573,102409139.309],"after":[102409136.661,102409137.196,102409137.729,102409138.261,102409138.775,102409142.16],"destroy":null}]}]},
{"clusterId":11,"parentClusterId":9,"name":"thunky > mongojs","children":[],"nodes":[{"aggregateId":34,"parentAggregateId":30,"name":"finished@thunky","children":[45],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":28,"columnNumber":28},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":29,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":35,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":20,"columnNumber":7},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":426,"parentAsyncId":422,"triggerAsyncId":422,"executionAsyncId":422,"init":102405373.524,"before":[102405373.863],"after":[102405374.287],"destroy":102405375.631},{"asyncId":687,"parentAsyncId":683,"triggerAsyncId":683,"executionAsyncId":683,"init":102406140.64,"before":[102406140.961],"after":[102406141.368],"destroy":102406142.719},{"asyncId":948,"parentAsyncId":944,"triggerAsyncId":944,"executionAsyncId":944,"init":102406898.431,"before":[102406898.639],"after":[102406898.901],"destroy":102406900.341},{"asyncId":1208,"parentAsyncId":1204,"triggerAsyncId":1204,"executionAsyncId":1204,"init":102407684.491,"before":[102407684.67],"after":[102407684.9],"destroy":102407685.968},{"asyncId":1465,"parentAsyncId":1461,"triggerAsyncId":1461,"executionAsyncId":1461,"init":102408438.086,"before":[102408438.287],"after":[102408438.558],"destroy":102408439.906},{"asyncId":1726,"parentAsyncId":1722,"triggerAsyncId":1722,"executionAsyncId":1722,"init":102409197.662,"before":[102409197.861],"after":[102409198.128],"destroy":102409199.581},{"asyncId":351,"parentAsyncId":347,"triggerAsyncId":347,"executionAsyncId":347,"init":102405343.281,"before":[102405343.489],"after":[102405343.748],"destroy":102405345.499},{"asyncId":611,"parentAsyncId":607,"triggerAsyncId":607,"executionAsyncId":607,"init":102406125.62,"before":[102406125.855],"after":[102406126.135],"destroy":102406127.52},{"asyncId":872,"parentAsyncId":868,"triggerAsyncId":868,"executionAsyncId":868,"init":102406876.846,"before":[102406877.04],"after":[102406877.297],"destroy":102406878.603},{"asyncId":1129,"parentAsyncId":1125,"triggerAsyncId":1125,"executionAsyncId":1125,"init":102407651.508,"before":[102407651.699],"after":[102407651.953],"destroy":102407652.981},{"asyncId":1390,"parentAsyncId":1386,"triggerAsyncId":1386,"executionAsyncId":1386,"init":102408399.345,"before":[102408399.614],"after":[102408399.897],"destroy":102408401.005},{"asyncId":1650,"parentAsyncId":1646,"triggerAsyncId":1646,"executionAsyncId":1646,"init":102409144.171,"before":[102409144.37],"after":[102409144.624],"destroy":102409145.837}]},{"aggregateId":45,"parentAggregateId":34,"name":"Pool.write@mongodb-core","children":[58],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Pool.write","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1027,"columnNumber":13},{"functionName":"Cursor._find","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":286,"columnNumber":22},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":593,"columnNumber":10},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":429,"parentAsyncId":426,"triggerAsyncId":426,"executionAsyncId":426,"init":102405373.991,"before":[102405374.346],"after":[102405375.259],"destroy":102405375.656},{"asyncId":690,"parentAsyncId":687,"triggerAsyncId":687,"executionAsyncId":687,"init":102406141.093,"before":[102406141.421],"after":[102406142.318],"destroy":102406142.745},{"asyncId":951,"parentAsyncId":948,"triggerAsyncId":948,"executionAsyncId":948,"init":102406898.742,"before":[102406898.938],"after":[102406899.978],"destroy":102406900.365},{"asyncId":1211,"parentAsyncId":1208,"triggerAsyncId":1208,"executionAsyncId":1208,"init":102407684.758,"before":[102407684.941],"after":[102407685.577],"destroy":102407685.994},{"asyncId":1468,"parentAsyncId":1465,"triggerAsyncId":1465,"executionAsyncId":1465,"init":102408438.382,"before":[102408438.595],"after":[102408439.538],"destroy":102408439.931},{"asyncId":1729,"parentAsyncId":1726,"triggerAsyncId":1726,"executionAsyncId":1726,"init":102409197.958,"before":[102409198.164],"after":[102409198.922],"destroy":102409199.598},{"asyncId":354,"parentAsyncId":351,"triggerAsyncId":351,"executionAsyncId":351,"init":102405343.583,"before":[102405343.792],"after":[102405344.525],"destroy":102405345.527},{"asyncId":614,"parentAsyncId":611,"triggerAsyncId":611,"executionAsyncId":611,"init":102406125.956,"before":[102406126.178],"after":[102406127.149],"destroy":102406127.538},{"asyncId":875,"parentAsyncId":872,"triggerAsyncId":872,"executionAsyncId":872,"init":102406877.138,"before":[102406877.338],"after":[102406878.221],"destroy":102406878.628},{"asyncId":1132,"parentAsyncId":1129,"triggerAsyncId":1129,"executionAsyncId":1129,"init":102407651.791,"before":[102407651.99],"after":[102407652.621],"destroy":102407653.012},{"asyncId":1393,"parentAsyncId":1390,"triggerAsyncId":1390,"executionAsyncId":1390,"init":102408399.717,"before":[102408399.934],"after":[102408400.672],"destroy":102408401.029},{"asyncId":1653,"parentAsyncId":1650,"triggerAsyncId":1650,"executionAsyncId":1650,"init":102409144.463,"before":[102409144.668],"after":[102409145.442],"destroy":102409145.861}]},{"aggregateId":58,"parentAggregateId":45,"name":"Connection.write@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"writeOrBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":383,"columnNumber":5},{"functionName":"Writable.write","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":290,"columnNumber":11},{"functionName":"Socket.write","typeName":"Socket","fileName":"net.js","lineNumber":707,"columnNumber":40},{"functionName":"Connection.write","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":543,"columnNumber":23},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1298,"columnNumber":44},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":431,"parentAsyncId":429,"triggerAsyncId":429,"executionAsyncId":429,"init":102405374.51,"before":[102405375.299],"after":[102405375.309],"destroy":102405375.671},{"asyncId":434,"parentAsyncId":429,"triggerAsyncId":429,"executionAsyncId":429,"init":102405374.935,"before":[102405375.364],"after":[102405375.373],"destroy":102405375.701},{"asyncId":692,"parentAsyncId":690,"triggerAsyncId":690,"executionAsyncId":690,"init":102406141.547,"before":[102406142.392],"after":[102406142.402],"destroy":102406142.761},{"asyncId":695,"parentAsyncId":690,"triggerAsyncId":690,"executionAsyncId":690,"init":102406141.991,"before":[102406142.454],"after":[102406142.464],"destroy":102406142.785},{"asyncId":953,"parentAsyncId":951,"triggerAsyncId":951,"executionAsyncId":951,"init":102406899.017,"before":[102406900.016],"after":[102406900.026],"destroy":102406900.38},{"asyncId":956,"parentAsyncId":951,"triggerAsyncId":951,"executionAsyncId":951,"init":102406899.654,"before":[102406900.078],"after":[102406900.087],"destroy":102406900.403},{"asyncId":1213,"parentAsyncId":1211,"triggerAsyncId":1211,"executionAsyncId":1211,"init":102407684.993,"before":[102407685.614],"after":[102407685.624],"destroy":102407686.012},{"asyncId":1216,"parentAsyncId":1211,"triggerAsyncId":1211,"executionAsyncId":1211,"init":102407685.283,"before":[102407685.681],"after":[102407685.691],"destroy":102407686.038},{"asyncId":1470,"parentAsyncId":1468,"triggerAsyncId":1468,"executionAsyncId":1468,"init":102408438.651,"before":[102408439.567],"after":[102408439.576],"destroy":102408439.946},{"asyncId":1473,"parentAsyncId":1468,"triggerAsyncId":1468,"executionAsyncId":1468,"init":102408439.02,"before":[102408439.64],"after":[102408439.65],"destroy":102408439.975},{"asyncId":1731,"parentAsyncId":1729,"triggerAsyncId":1729,"executionAsyncId":1729,"init":102409198.221,"before":[102409198.961],"after":[102409198.971],"destroy":102409199.608},{"asyncId":1734,"parentAsyncId":1729,"triggerAsyncId":1729,"executionAsyncId":1729,"init":102409198.628,"before":[102409199.402],"after":[102409199.408],"destroy":102409199.624},{"asyncId":356,"parentAsyncId":354,"triggerAsyncId":354,"executionAsyncId":354,"init":102405343.857,"before":[102405344.564],"after":[102405344.575],"destroy":102405345.543},{"asyncId":359,"parentAsyncId":354,"triggerAsyncId":354,"executionAsyncId":354,"init":102405344.207,"before":[102405344.634],"after":[102405344.644],"destroy":102405345.571},{"asyncId":616,"parentAsyncId":614,"triggerAsyncId":614,"executionAsyncId":614,"init":102406126.242,"before":[102406127.189],"after":[102406127.201],"destroy":102406127.549},{"asyncId":619,"parentAsyncId":614,"triggerAsyncId":614,"executionAsyncId":614,"init":102406126.807,"before":[102406127.285],"after":[102406127.292],"destroy":102406127.566},{"asyncId":877,"parentAsyncId":875,"triggerAsyncId":875,"executionAsyncId":875,"init":102406877.393,"before":[102406878.248],"after":[102406878.256],"destroy":102406878.643},{"asyncId":880,"parentAsyncId":875,"triggerAsyncId":875,"executionAsyncId":875,"init":102406877.806,"before":[102406878.316],"after":[102406878.326],"destroy":102406878.666},{"asyncId":1134,"parentAsyncId":1132,"triggerAsyncId":1132,"executionAsyncId":1132,"init":102407652.047,"before":[102407652.651],"after":[102407652.662],"destroy":102407653.026},{"asyncId":1137,"parentAsyncId":1132,"triggerAsyncId":1132,"executionAsyncId":1132,"init":102407652.357,"before":[102407652.72],"after":[102407652.73],"destroy":102407653.049},{"asyncId":1395,"parentAsyncId":1393,"triggerAsyncId":1393,"executionAsyncId":1393,"init":102408400.004,"before":[102408400.703],"after":[102408400.71],"destroy":102408401.042},{"asyncId":1398,"parentAsyncId":1393,"triggerAsyncId":1393,"executionAsyncId":1393,"init":102408400.365,"before":[102408400.755],"after":[102408400.761],"destroy":102408401.071},{"asyncId":1655,"parentAsyncId":1653,"triggerAsyncId":1653,"executionAsyncId":1653,"init":102409144.721,"before":[102409145.482],"after":[102409145.492],"destroy":102409145.876},{"asyncId":1658,"parentAsyncId":1653,"triggerAsyncId":1653,"executionAsyncId":1653,"init":102409145.058,"before":[102409145.546],"after":[102409145.558],"destroy":102409145.905}]}]},
{"clusterId":12,"parentClusterId":9,"name":"connection.connect","children":[],"nodes":[{"aggregateId":40,"parentAggregateId":33,"name":null,"children":[54,55],"mark":["nodecore",null,null],"type":"TCPCONNECTWRAP","frames":[{"functionName":"internalConnect","isToplevel":true,"fileName":"net.js","lineNumber":941,"columnNumber":26},{"functionName":"emitLookup","typeName":"GetAddrInfoReqWrap","fileName":"net.js","lineNumber":1106,"columnNumber":9},{"functionName":"onlookup","typeName":"GetAddrInfoReqWrap","fileName":"dns.js","lineNumber":97,"columnNumber":10}],"sources":[{"asyncId":99,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":88,"init":102404523.933,"before":[102404526.704],"after":[102404537.874],"destroy":102404537.886}]},{"aggregateId":54,"parentAggregateId":40,"name":"Pool.write@mongodb-core","children":[64,65],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Pool.write","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1027,"columnNumber":13},{"typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":254,"columnNumber":19},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Pool","fileName":"events.js","lineNumber":211,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":654,"columnNumber":14},{"functionName":"authenticate","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":179,"columnNumber":36},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":637,"columnNumber":7},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":219,"columnNumber":38},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"MongoCR.reauthenticate","typeName":"MongoCR","fileName":"./node_modules/mongodb-core/lib/auth/mongocr.js","lineNumber":160,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"X509.reauthenticate","typeName":"X509","fileName":"./node_modules/mongodb-core/lib/auth/x509.js","lineNumber":143,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"Plain.reauthenticate","typeName":"Plain","fileName":"./node_modules/mongodb-core/lib/auth/plain.js","lineNumber":147,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"GSSAPI.reauthenticate","typeName":"GSSAPI","fileName":"./node_modules/mongodb-core/lib/auth/gssapi.js","lineNumber":241,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"SSPI.reauthenticate","typeName":"SSPI","fileName":"./node_modules/mongodb-core/lib/auth/sspi.js","lineNumber":229,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"ScramSHA1.reauthenticate","typeName":"ScramSHA1","fileName":"./node_modules/mongodb-core/lib/auth/scram.js","lineNumber":325,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"functionName":"reauthenticate","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":233,"columnNumber":3},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":625,"columnNumber":5},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":315,"columnNumber":30},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Connection","fileName":"events.js","lineNumber":211,"columnNumber":7},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":479,"columnNumber":12},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":313,"columnNumber":30},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":111,"columnNumber":20},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"afterConnect","typeName":"TCPConnectWrap","fileName":"net.js","lineNumber":1173,"columnNumber":10}],"sources":[{"asyncId":113,"parentAsyncId":99,"triggerAsyncId":99,"executionAsyncId":99,"init":102404531.023,"before":[102404534.845],"after":[102404537.685],"destroy":102404537.94}]},{"aggregateId":55,"parentAggregateId":40,"name":"Socket@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":477,"columnNumber":23},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":313,"columnNumber":30},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":111,"columnNumber":20},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"afterConnect","typeName":"TCPConnectWrap","fileName":"net.js","lineNumber":1173,"columnNumber":10}],"sources":[{"asyncId":111,"parentAsyncId":99,"triggerAsyncId":99,"executionAsyncId":99,"init":102404527.39,"before":[],"after":[],"destroy":102404537.95}]},{"aggregateId":64,"parentAggregateId":54,"name":"Connection.write@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"writeOrBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":383,"columnNumber":5},{"functionName":"Writable.write","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":290,"columnNumber":11},{"functionName":"Socket.write","typeName":"Socket","fileName":"net.js","lineNumber":707,"columnNumber":40},{"functionName":"Connection.write","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":543,"columnNumber":23},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1298,"columnNumber":44},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":118,"parentAsyncId":113,"triggerAsyncId":113,"executionAsyncId":113,"init":102404536.533,"before":[102404537.783],"after":[102404537.794],"destroy":102404538.022},{"asyncId":120,"parentAsyncId":113,"triggerAsyncId":113,"executionAsyncId":113,"init":102404537.194,"before":[102404537.831],"after":[102404537.841],"destroy":102404538.055}]},{"aggregateId":65,"parentAggregateId":54,"name":"Connection.setSocketTimeout@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"Connection.setSocketTimeout","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":148,"columnNumber":21},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1289,"columnNumber":24},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":115,"parentAsyncId":113,"triggerAsyncId":113,"executionAsyncId":113,"init":102404535.712,"before":[],"after":[],"destroy":102404560.981}]}]},
{"clusterId":13,"parentClusterId":9,"name":"mongodb-core","children":[],"nodes":[{"aggregateId":41,"parentAggregateId":33,"name":"authenticateStragglers@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":480,"columnNumber":17},{"functionName":"authenticateStragglers","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":443,"columnNumber":16},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":477,"columnNumber":5},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":333,"columnNumber":22},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":263,"columnNumber":12},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":126,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404540.584,"before":[102404545.565],"after":[102404545.641],"destroy":102404561.011},{"asyncId":229,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404978.331,"before":[102404980.162],"after":[102404980.181],"destroy":102404980.868},{"asyncId":363,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405362.18,"before":[102405362.869],"after":[102405362.883],"destroy":102405363.248},{"asyncId":491,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405769.924,"before":[102405770.635],"after":[102405770.647],"destroy":102405771.095},{"asyncId":624,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406130.655,"before":[102406131.512],"after":[102406131.532],"destroy":102406131.973},{"asyncId":752,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406541.934,"before":[102406542.724],"after":[102406542.736],"destroy":102406543.097},{"asyncId":885,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406888.749,"before":[102406889.585],"after":[102406889.598],"destroy":102406890.04},{"asyncId":1013,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407311.779,"before":[102407312.758],"after":[102407312.77],"destroy":102407313.13},{"asyncId":1141,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407676.806,"before":[102407677.504],"after":[102407677.517],"destroy":102407677.857},{"asyncId":1274,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408085.391,"before":[102408086.173],"after":[102408086.191],"destroy":102408086.595},{"asyncId":1402,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408430.533,"before":[102408431.237],"after":[102408431.254],"destroy":102408431.62},{"asyncId":1530,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408849.375,"before":[102408850.057],"after":[102408850.07],"destroy":102408850.439},{"asyncId":1663,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102409188.146,"before":[102409189.292],"after":[102409189.309],"destroy":102409189.863}]}]},
{"clusterId":14,"parentClusterId":9,"name":"mongodb-core","children":[],"nodes":[{"aggregateId":42,"parentAggregateId":33,"name":"handleOperationCallback@mongodb-core","children":[56,57],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"handleOperationCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":468,"columnNumber":24},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":504,"columnNumber":9},{"functionName":"authenticateStragglers","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":443,"columnNumber":16},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":477,"columnNumber":5},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":333,"columnNumber":22},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":263,"columnNumber":12},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":128,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404542.95,"before":[102404545.669],"after":[102404549.955],"destroy":102404561.033},{"asyncId":233,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404978.958,"before":[102404980.242],"after":[102404980.716],"destroy":102404980.888},{"asyncId":367,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405362.556,"before":[102405362.922],"after":[102405363.162],"destroy":102405363.265},{"asyncId":495,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405770.319,"before":[102405770.686],"after":[102405770.963],"destroy":102405771.121},{"asyncId":628,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406131.122,"before":[102406131.575],"after":[102406131.871],"destroy":102406131.997},{"asyncId":756,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406542.358,"before":[102406542.775],"after":[102406543.014],"destroy":102406543.114},{"asyncId":889,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406889.222,"before":[102406889.642],"after":[102406889.944],"destroy":102406890.06},{"asyncId":1017,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407312.367,"before":[102407312.809],"after":[102407313.046],"destroy":102407313.147},{"asyncId":1145,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407677.205,"before":[102407677.555],"after":[102407677.773],"destroy":102407677.874},{"asyncId":1278,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408085.759,"before":[102408086.247],"after":[102408086.51],"destroy":102408086.612},{"asyncId":1406,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408430.921,"before":[102408431.293],"after":[102408431.53],"destroy":102408431.636},{"asyncId":1534,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408849.746,"before":[102408850.108],"after":[102408850.351],"destroy":102408850.455},{"asyncId":1667,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102409188.531,"before":[102409189.363],"after":[102409189.743],"destroy":102409189.887}]},{"aggregateId":56,"parentAggregateId":42,"name":"connectHandler@mongodb","children":[66],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":428,"columnNumber":22},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":409,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/db.js","lineNumber":239,"columnNumber":5},{"functionName":"connectHandler","typeName":"Server","fileName":"./node_modules/mongodb/lib/server.js","lineNumber":324,"columnNumber":7},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":315,"columnNumber":30},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Server","fileName":"events.js","lineNumber":211,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":300,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":469,"columnNumber":18},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":137,"parentAsyncId":128,"triggerAsyncId":128,"executionAsyncId":128,"init":102404549.596,"before":[102404550.077],"after":[102404550.817],"destroy":102404561.097}]},{"aggregateId":57,"parentAggregateId":42,"name":null,"children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"Timeout","isConstructor":true,"fileName":"timers.js","lineNumber":602,"columnNumber":5},{"functionName":"createSingleTimeout","isToplevel":true,"fileName":"timers.js","lineNumber":482,"columnNumber":15},{"functionName":"setTimeout","isToplevel":true,"fileName":"timers.js","lineNumber":466,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/topologies/server.js","lineNumber":279,"columnNumber":38},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":469,"columnNumber":18},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":132,"parentAsyncId":128,"triggerAsyncId":128,"executionAsyncId":128,"init":102404546.206,"before":[],"after":[],"destroy":null}]},{"aggregateId":66,"parentAggregateId":56,"name":"finished@thunky","children":[71],"mark":["external","mongodb",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":28,"columnNumber":28},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/database.js","lineNumber":36,"columnNumber":9},{"functionName":"connectCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":527,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/mongo_client.js","lineNumber":430,"columnNumber":11},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":139,"parentAsyncId":137,"triggerAsyncId":137,"executionAsyncId":137,"init":102404550.317,"before":[102404550.852],"after":[102404554.177],"destroy":102404561.115},{"asyncId":142,"parentAsyncId":137,"triggerAsyncId":137,"executionAsyncId":137,"init":102404550.586,"before":[102404554.284],"after":[102404555.165],"destroy":102404561.142}]},{"aggregateId":71,"parentAggregateId":66,"name":"finished@thunky","children":[72],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":28,"columnNumber":28},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":29,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":35,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":20,"columnNumber":7},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":144,"parentAsyncId":139,"triggerAsyncId":139,"executionAsyncId":139,"init":102404553.846,"before":[102404555.196],"after":[102404557.871],"destroy":102404561.159},{"asyncId":146,"parentAsyncId":142,"triggerAsyncId":142,"executionAsyncId":142,"init":102404554.913,"before":[102404557.904],"after":[102404558.349],"destroy":102404561.177}]},{"aggregateId":72,"parentAggregateId":71,"name":"Pool.write@mongodb-core","children":[73,74,75,76],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Pool.write","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1027,"columnNumber":13},{"functionName":"Cursor._find","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":286,"columnNumber":22},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":593,"columnNumber":10},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":149,"parentAsyncId":144,"triggerAsyncId":144,"executionAsyncId":144,"init":102404557.431,"before":[102404558.4],"after":[102404560.658],"destroy":102404561.207},{"asyncId":151,"parentAsyncId":146,"triggerAsyncId":146,"executionAsyncId":146,"init":102404558.122,"before":[102404560.776],"after":[102404560.79],"destroy":102404561.228}]},{"aggregateId":73,"parentAggregateId":72,"name":"Connection.write@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"writeOrBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":383,"columnNumber":5},{"functionName":"Writable.write","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":290,"columnNumber":11},{"functionName":"Socket.write","typeName":"Socket","fileName":"net.js","lineNumber":707,"columnNumber":40},{"functionName":"Connection.write","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":543,"columnNumber":23},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1298,"columnNumber":44},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":153,"parentAsyncId":149,"triggerAsyncId":149,"executionAsyncId":149,"init":102404558.515,"before":[102404560.825],"after":[102404560.836],"destroy":102404561.248},{"asyncId":156,"parentAsyncId":149,"triggerAsyncId":149,"executionAsyncId":149,"init":102404558.981,"before":[102404560.889],"after":[102404560.902],"destroy":102404561.276}]},{"aggregateId":74,"parentAggregateId":72,"name":"Connection.connect@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"resume","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":815,"columnNumber":13},{"functionName":"Readable.resume","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":807,"columnNumber":5},{"functionName":"Readable.on","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":777,"columnNumber":12},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":487,"columnNumber":19},{"functionName":"_createConnection","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1133,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1263,"columnNumber":15},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":160,"parentAsyncId":149,"triggerAsyncId":149,"executionAsyncId":149,"init":102404560.496,"before":[102404560.913],"after":[102404560.948],"destroy":102404561.285}]},{"aggregateId":75,"parentAggregateId":72,"name":"Connection.connect@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":424,"columnNumber":19},{"functionName":"_createConnection","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1133,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1263,"columnNumber":15},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":159,"parentAsyncId":149,"triggerAsyncId":149,"executionAsyncId":149,"init":102404560.311,"before":[],"after":[],"destroy":102404570.778}]},{"aggregateId":76,"parentAggregateId":72,"name":"Connection.connect@mongodb-core","children":[77,78,79,80,81],"mark":["external","mongodb-core",null],"type":"TCPWRAP","frames":[{"functionName":"Socket.connect","typeName":"Socket","fileName":"net.js","lineNumber":997,"columnNumber":7},{"functionName":"connect","typeName":"Object","fileName":"net.js","lineNumber":113,"columnNumber":35},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":420,"columnNumber":25},{"functionName":"_createConnection","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1133,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1263,"columnNumber":15},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":157,"parentAsyncId":149,"triggerAsyncId":149,"executionAsyncId":149,"init":102404559.956,"before":[102404953.281,102405330.607,102405755.746,102406115.31,102406527.255,102406868.498,102407282.73,102407644.295,102408056.766,102408390.581,102408805.407,102409135.52],"after":[102404956.107,102405331.861,102405756.989,102406116.993,102406528.491,102406869.7,102407283.86,102407645.405,102408057.91,102408391.674,102408806.648,102409136.746],"destroy":null}]},{"aggregateId":77,"parentAggregateId":76,"name":"Connection.connect@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"GETADDRINFOREQWRAP","frames":[{"functionName":"lookup","isToplevel":true,"fileName":"dns.js","lineNumber":182,"columnNumber":19},{"isToplevel":true,"fileName":"net.js","lineNumber":1087,"columnNumber":5},{"functionName":"lookupAndConnect","isToplevel":true,"fileName":"net.js","lineNumber":1086,"columnNumber":3},{"functionName":"Socket.connect","typeName":"Socket","fileName":"net.js","lineNumber":1021,"columnNumber":5},{"functionName":"connect","typeName":"Object","fileName":"net.js","lineNumber":113,"columnNumber":35},{"functionName":"Connection.connect","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":420,"columnNumber":25},{"functionName":"_createConnection","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1133,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1263,"columnNumber":15},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":158,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":149,"init":102404560.152,"before":[102404562.781],"after":[102404563.27],"destroy":102404563.275}]},{"aggregateId":78,"parentAggregateId":76,"name":null,"children":[82,83],"mark":["nodecore",null,null],"type":"TCPCONNECTWRAP","frames":[{"functionName":"internalConnect","isToplevel":true,"fileName":"net.js","lineNumber":941,"columnNumber":26},{"functionName":"emitLookup","typeName":"GetAddrInfoReqWrap","fileName":"net.js","lineNumber":1106,"columnNumber":9},{"functionName":"onlookup","typeName":"GetAddrInfoReqWrap","fileName":"dns.js","lineNumber":97,"columnNumber":10}],"sources":[{"asyncId":164,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":158,"init":102404562.863,"before":[102404563.444],"after":[102404570.757],"destroy":102404570.763}]},{"aggregateId":79,"parentAggregateId":76,"name":"authenticateStragglers@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":480,"columnNumber":17},{"functionName":"authenticateStragglers","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":443,"columnNumber":16},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":477,"columnNumber":5},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":333,"columnNumber":22},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":263,"columnNumber":12},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":176,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102404953.596,"before":[102404954.583],"after":[102404954.6],"destroy":102404956.115},{"asyncId":282,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405330.725,"before":[102405331.471],"after":[102405331.485],"destroy":102405331.869},{"asyncId":438,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405755.871,"before":[102405756.595],"after":[102405756.608],"destroy":102405757.013},{"asyncId":544,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406115.415,"before":[102406116.432],"after":[102406116.449],"destroy":102406117.002},{"asyncId":699,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406527.433,"before":[102406528.118],"after":[102406528.131],"destroy":102406528.498},{"asyncId":805,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406868.612,"before":[102406869.328],"after":[102406869.341],"destroy":102406869.707},{"asyncId":960,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407282.843,"before":[102407283.513],"after":[102407283.526],"destroy":102407283.867},{"asyncId":1066,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407644.401,"before":[102407645.058],"after":[102407645.071],"destroy":102407645.412},{"asyncId":1221,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408056.886,"before":[102408057.564],"after":[102408057.577],"destroy":102408057.918},{"asyncId":1327,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408390.687,"before":[102408391.327],"after":[102408391.34],"destroy":102408391.681},{"asyncId":1477,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408805.573,"before":[102408806.274],"after":[102408806.291],"destroy":102408806.655},{"asyncId":1583,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102409135.636,"before":[102409136.339],"after":[102409136.352],"destroy":102409136.754}]},{"aggregateId":80,"parentAggregateId":76,"name":"handleOperationCallback@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"handleOperationCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":468,"columnNumber":24},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":504,"columnNumber":9},{"functionName":"authenticateStragglers","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":443,"columnNumber":16},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":477,"columnNumber":5},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":333,"columnNumber":22},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":263,"columnNumber":12},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":180,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102404954.243,"before":[102404954.661],"after":[102404956.019],"destroy":102404956.134},{"asyncId":286,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405331.154,"before":[102405331.526],"after":[102405331.778],"destroy":102405331.888},{"asyncId":442,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405756.271,"before":[102405756.646],"after":[102405756.895],"destroy":102405757.035},{"asyncId":548,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406115.936,"before":[102406116.503],"after":[102406116.883],"destroy":102406117.027},{"asyncId":703,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406527.811,"before":[102406528.17],"after":[102406528.407],"destroy":102406528.515},{"asyncId":809,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406869.016,"before":[102406869.38],"after":[102406869.622],"destroy":102406869.724},{"asyncId":964,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407283.23,"before":[102407283.564],"after":[102407283.783],"destroy":102407283.884},{"asyncId":1070,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407644.768,"before":[102407645.109],"after":[102407645.327],"destroy":102407645.429},{"asyncId":1225,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408057.274,"before":[102408057.616],"after":[102408057.833],"destroy":102408057.935},{"asyncId":1331,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408391.047,"before":[102408391.38],"after":[102408391.598],"destroy":102408391.698},{"asyncId":1481,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408805.969,"before":[102408806.329],"after":[102408806.566],"destroy":102408806.672},{"asyncId":1587,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102409136.011,"before":[102409136.39],"after":[102409136.668],"destroy":102409136.77}]},{"aggregateId":81,"parentAggregateId":76,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"maybeReadMore","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":527,"columnNumber":13},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":276,"columnNumber":3},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":182,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102404954.447,"before":[102404956.047],"after":[102404956.054],"destroy":102404956.145},{"asyncId":288,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405331.345,"before":[102405331.803],"after":[102405331.81],"destroy":102405331.899},{"asyncId":444,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102405756.466,"before":[102405756.919],"after":[102405756.926],"destroy":102405757.045},{"asyncId":550,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406116.229,"before":[102406116.915],"after":[102406116.924],"destroy":102406117.042},{"asyncId":705,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406527.998,"before":[102406528.435],"after":[102406528.442],"destroy":102406528.525},{"asyncId":811,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102406869.205,"before":[102406869.647],"after":[102406869.653],"destroy":102406869.735},{"asyncId":966,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407283.402,"before":[102407283.807],"after":[102407283.813],"destroy":102407283.894},{"asyncId":1072,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102407644.946,"before":[102407645.35],"after":[102407645.357],"destroy":102407645.439},{"asyncId":1227,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408057.452,"before":[102408057.856],"after":[102408057.862],"destroy":102408057.945},{"asyncId":1333,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408391.217,"before":[102408391.621],"after":[102408391.628],"destroy":102408391.709},{"asyncId":1483,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102408806.157,"before":[102408806.591],"after":[102408806.597],"destroy":102408806.682},{"asyncId":1589,"parentAsyncId":157,"triggerAsyncId":157,"executionAsyncId":157,"init":102409136.202,"before":[102409136.693],"after":[102409136.699],"destroy":102409136.781}]},{"aggregateId":82,"parentAggregateId":78,"name":"Connection.write@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"writeOrBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":383,"columnNumber":5},{"functionName":"Writable.write","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":290,"columnNumber":11},{"functionName":"Socket.write","typeName":"Socket","fileName":"net.js","lineNumber":707,"columnNumber":40},{"functionName":"Connection.write","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":543,"columnNumber":23},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1298,"columnNumber":44},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1119,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":219,"columnNumber":38},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"MongoCR.reauthenticate","typeName":"MongoCR","fileName":"./node_modules/mongodb-core/lib/auth/mongocr.js","lineNumber":160,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"X509.reauthenticate","typeName":"X509","fileName":"./node_modules/mongodb-core/lib/auth/x509.js","lineNumber":143,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"Plain.reauthenticate","typeName":"Plain","fileName":"./node_modules/mongodb-core/lib/auth/plain.js","lineNumber":147,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"GSSAPI.reauthenticate","typeName":"GSSAPI","fileName":"./node_modules/mongodb-core/lib/auth/gssapi.js","lineNumber":241,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"SSPI.reauthenticate","typeName":"SSPI","fileName":"./node_modules/mongodb-core/lib/auth/sspi.js","lineNumber":229,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":228,"columnNumber":7},{"functionName":"ScramSHA1.reauthenticate","typeName":"ScramSHA1","fileName":"./node_modules/mongodb-core/lib/auth/scram.js","lineNumber":325,"columnNumber":25},{"functionName":"authenticateAgainstProvider","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":224,"columnNumber":14},{"functionName":"reauthenticate","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":233,"columnNumber":3},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1098,"columnNumber":7},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":315,"columnNumber":30},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Connection","fileName":"events.js","lineNumber":211,"columnNumber":7},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":479,"columnNumber":12},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":313,"columnNumber":30},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":111,"columnNumber":20},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"afterConnect","typeName":"TCPConnectWrap","fileName":"net.js","lineNumber":1173,"columnNumber":10}],"sources":[{"asyncId":171,"parentAsyncId":164,"triggerAsyncId":164,"executionAsyncId":164,"init":102404566.229,"before":[102404570.666],"after":[102404570.678],"destroy":102404570.807},{"asyncId":173,"parentAsyncId":164,"triggerAsyncId":164,"executionAsyncId":164,"init":102404568.812,"before":[102404570.712],"after":[102404570.723],"destroy":102404570.826}]},{"aggregateId":83,"parentAggregateId":78,"name":"Socket@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":477,"columnNumber":23},{"functionName":"onceWrapper","typeName":"Object","fileName":"events.js","lineNumber":313,"columnNumber":30},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":111,"columnNumber":20},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"afterConnect","typeName":"TCPConnectWrap","fileName":"net.js","lineNumber":1173,"columnNumber":10}],"sources":[{"asyncId":168,"parentAsyncId":164,"triggerAsyncId":164,"executionAsyncId":164,"init":102404563.521,"before":[],"after":[],"destroy":null}]}]},
{"clusterId":15,"parentClusterId":9,"name":"nextTick","children":[],"nodes":[{"aggregateId":43,"parentAggregateId":33,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"maybeReadMore","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":527,"columnNumber":13},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":276,"columnNumber":3},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":130,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404543.239,"before":[102404549.99],"after":[102404549.999],"destroy":102404561.052},{"asyncId":235,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404979.941,"before":[102404980.784],"after":[102404980.794],"destroy":102404980.899},{"asyncId":369,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405362.746,"before":[102405363.186],"after":[102405363.193],"destroy":102405363.275},{"asyncId":497,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102405770.512,"before":[102405770.986],"after":[102405770.993],"destroy":102405771.136},{"asyncId":630,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406131.357,"before":[102406131.9],"after":[102406131.907],"destroy":102406132.009},{"asyncId":758,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406542.598,"before":[102406543.037],"after":[102406543.044],"destroy":102406543.124},{"asyncId":891,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102406889.428,"before":[102406889.972],"after":[102406889.979],"destroy":102406890.071},{"asyncId":1019,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407312.586,"before":[102407313.069],"after":[102407313.076],"destroy":102407313.157},{"asyncId":1147,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102407677.383,"before":[102407677.796],"after":[102407677.802],"destroy":102407677.884},{"asyncId":1280,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408085.963,"before":[102408086.534],"after":[102408086.541],"destroy":102408086.622},{"asyncId":1408,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408431.118,"before":[102408431.554],"after":[102408431.561],"destroy":102408431.646},{"asyncId":1536,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102408849.934,"before":[102408850.378],"after":[102408850.384],"destroy":102408850.466},{"asyncId":1669,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102409188.728,"before":[102409189.776],"after":[102409189.786],"destroy":102409189.903}]}]},
{"clusterId":16,"parentClusterId":9,"name":"mongodb-core","children":[],"nodes":[{"aggregateId":44,"parentAggregateId":33,"name":"Connection.resetSocketTimeout@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"Connection.resetSocketTimeout","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":154,"columnNumber":21},{"typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":411,"columnNumber":18},{"typeName":"Socket","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":333,"columnNumber":22},{"functionName":"emitOne","isToplevel":true,"fileName":"events.js","lineNumber":116,"columnNumber":13},{"functionName":"emit","typeName":"Socket","fileName":"events.js","lineNumber":211,"columnNumber":7},{"functionName":"addChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":263,"columnNumber":12},{"functionName":"readableAddChunk","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":250,"columnNumber":11},{"functionName":"Readable.push","typeName":"Socket","fileName":"_stream_readable.js","lineNumber":208,"columnNumber":10},{"functionName":"onread","typeName":"TCP","fileName":"net.js","lineNumber":597,"columnNumber":20}],"sources":[{"asyncId":123,"parentAsyncId":86,"triggerAsyncId":86,"executionAsyncId":86,"init":102404539.884,"before":[],"after":[],"destroy":null}]}]},
{"clusterId":17,"parentClusterId":10,"name":"mongojs > mongodb > mongodb-core","children":[],"nodes":[{"aggregateId":35,"parentAggregateId":32,"name":"runInAsyncScope@mongojs","children":[46],"mark":["external","mongodb-core",null],"type":"Immediate","frames":[{"functionName":"Immediate","isConstructor":true,"fileName":"timers.js","lineNumber":837,"columnNumber":5},{"functionName":"createImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":879,"columnNumber":19},{"functionName":"setImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":866,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":77,"columnNumber":7},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":691,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":602,"columnNumber":7},{"functionName":"queryCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":232,"columnNumber":18},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":469,"columnNumber":18},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":237,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404980.359,"before":[102404980.927],"after":[102404981.116],"destroy":102404981.497},{"asyncId":499,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405770.72,"before":[102405771.174],"after":[102405771.358],"destroy":102405771.71},{"asyncId":760,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406542.809,"before":[102406543.149],"after":[102406543.308],"destroy":102406543.655},{"asyncId":1021,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407312.845,"before":[102407313.182],"after":[102407313.326],"destroy":102407313.646},{"asyncId":1282,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408086.295,"before":[102408086.648],"after":[102408086.796],"destroy":102408087.21},{"asyncId":1538,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408850.143,"before":[102408850.491],"after":[102408850.648],"destroy":102408850.989},{"asyncId":184,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404955.668,"before":[102404956.265],"after":[102404956.519],"destroy":102404957.172},{"asyncId":446,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405756.685,"before":[102405757.074],"after":[102405757.276],"destroy":102405757.645},{"asyncId":707,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406528.204,"before":[102406528.55],"after":[102406528.702],"destroy":102406529.15},{"asyncId":968,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407283.6,"before":[102407283.919],"after":[102407284.062],"destroy":102407284.388},{"asyncId":1229,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408057.652,"before":[102408057.971],"after":[102408058.122],"destroy":102408058.444},{"asyncId":1485,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408806.364,"before":[102408806.708],"after":[102408806.862],"destroy":102408807.203}]},{"aggregateId":46,"parentAggregateId":35,"name":"finished@thunky","children":[],"mark":["external","mongojs",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","typeName":"Immediate","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"runCallback","isToplevel":true,"fileName":"timers.js","lineNumber":810,"columnNumber":20},{"functionName":"tryOnImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":768,"columnNumber":5},{"functionName":"processImmediate","typeName":"process","fileName":"timers.js","lineNumber":745,"columnNumber":5}],"sources":[{"asyncId":240,"parentAsyncId":237,"triggerAsyncId":237,"executionAsyncId":237,"init":102404980.943,"before":[102404981.13],"after":[102404981.381],"destroy":102404981.503},{"asyncId":502,"parentAsyncId":499,"triggerAsyncId":499,"executionAsyncId":499,"init":102405771.192,"before":[102405771.37],"after":[102405771.603],"destroy":102405771.716},{"asyncId":763,"parentAsyncId":760,"triggerAsyncId":760,"executionAsyncId":760,"init":102406543.162,"before":[102406543.319],"after":[102406543.554],"destroy":102406543.662},{"asyncId":1024,"parentAsyncId":1021,"triggerAsyncId":1021,"executionAsyncId":1021,"init":102407313.195,"before":[102407313.338],"after":[102407313.544],"destroy":102407313.652},{"asyncId":1285,"parentAsyncId":1282,"triggerAsyncId":1282,"executionAsyncId":1282,"init":102408086.66,"before":[102408086.808],"after":[102408087.065],"destroy":102408087.219},{"asyncId":1541,"parentAsyncId":1538,"triggerAsyncId":1538,"executionAsyncId":1538,"init":102408850.502,"before":[102408850.659],"after":[102408850.886],"destroy":102408850.996},{"asyncId":187,"parentAsyncId":184,"triggerAsyncId":184,"executionAsyncId":184,"init":102404956.351,"before":[102404956.538],"after":[102404956.867],"destroy":102404957.183},{"asyncId":449,"parentAsyncId":446,"triggerAsyncId":446,"executionAsyncId":446,"init":102405757.096,"before":[102405757.289],"after":[102405757.541],"destroy":102405757.651},{"asyncId":710,"parentAsyncId":707,"triggerAsyncId":707,"executionAsyncId":707,"init":102406528.562,"before":[102406528.723],"after":[102406529.042],"destroy":102406529.157},{"asyncId":971,"parentAsyncId":968,"triggerAsyncId":968,"executionAsyncId":968,"init":102407283.931,"before":[102407284.073],"after":[102407284.283],"destroy":102407284.397},{"asyncId":1232,"parentAsyncId":1229,"triggerAsyncId":1229,"executionAsyncId":1229,"init":102408057.983,"before":[102408058.134],"after":[102408058.339],"destroy":102408058.453},{"asyncId":1488,"parentAsyncId":1485,"triggerAsyncId":1485,"executionAsyncId":1485,"init":102408806.72,"before":[102408806.873],"after":[102408807.104],"destroy":102408807.209}]}]},
{"clusterId":18,"parentClusterId":10,"name":"... > mongodb > mongodb-core > thunky","children":[],"nodes":[{"aggregateId":36,"parentAggregateId":32,"name":"runInAsyncScope@mongojs","children":[47],"mark":["external","thunky",null],"type":"Immediate","frames":[{"functionName":"Immediate","isConstructor":true,"fileName":"timers.js","lineNumber":837,"columnNumber":5},{"functionName":"createImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":879,"columnNumber":19},{"functionName":"setImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":866,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":77,"columnNumber":7},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":691,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":243,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404981.162,"before":[102404981.557],"after":[102404981.763],"destroy":102404982.139},{"asyncId":249,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404981.805,"before":[102404982.194],"after":[102404982.364],"destroy":102404982.723},{"asyncId":255,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404982.402,"before":[102404982.763],"after":[102404982.923],"destroy":102404983.268},{"asyncId":261,"parentAsyncId":83,"triggerAsyncId":83,"executionAsyncId":83,"init":102404982.961,"before":[102404983.306],"after":[102404983.469],"destroy":102404985.62},{"asyncId":505,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405771.396,"before":[102405771.741],"after":[102405771.909],"destroy":102405772.249},{"asyncId":511,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405771.948,"before":[102405772.279],"after":[102405772.448],"destroy":102405772.78},{"asyncId":517,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405772.484,"before":[102405772.811],"after":[102405772.971],"destroy":102405773.303},{"asyncId":523,"parentAsyncId":420,"triggerAsyncId":420,"executionAsyncId":420,"init":102405773.006,"before":[102405773.334],"after":[102405773.496],"destroy":102405775.543},{"asyncId":766,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406543.345,"before":[102406543.694],"after":[102406543.851],"destroy":102406544.179},{"asyncId":772,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406543.886,"before":[102406544.209],"after":[102406544.361],"destroy":102406544.692},{"asyncId":778,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406544.396,"before":[102406544.723],"after":[102406544.875],"destroy":102406545.538},{"asyncId":784,"parentAsyncId":681,"triggerAsyncId":681,"executionAsyncId":681,"init":102406544.949,"before":[102406545.586],"after":[102406545.846],"destroy":102406548.11},{"asyncId":1027,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407313.365,"before":[102407313.678],"after":[102407313.817],"destroy":102407314.13},{"asyncId":1033,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407313.852,"before":[102407314.163],"after":[102407314.302],"destroy":102407314.614},{"asyncId":1039,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407314.338,"before":[102407314.654],"after":[102407314.802],"destroy":102407315.114},{"asyncId":1045,"parentAsyncId":942,"triggerAsyncId":942,"executionAsyncId":942,"init":102407314.838,"before":[102407315.152],"after":[102407315.293],"destroy":102407317.133},{"asyncId":1288,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408086.835,"before":[102408087.255],"after":[102408087.451],"destroy":102408087.777},{"asyncId":1294,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408087.49,"before":[102408087.815],"after":[102408087.959],"destroy":102408088.272},{"asyncId":1300,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408087.995,"before":[102408088.308],"after":[102408088.448],"destroy":102408088.765},{"asyncId":1306,"parentAsyncId":1202,"triggerAsyncId":1202,"executionAsyncId":1202,"init":102408088.483,"before":[102408088.811],"after":[102408088.953],"destroy":102408090.817},{"asyncId":1544,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408850.686,"before":[102408851.022],"after":[102408851.174],"destroy":102408851.641},{"asyncId":1550,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408851.209,"before":[102408851.682],"after":[102408851.837],"destroy":102408852.175},{"asyncId":1556,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408851.876,"before":[102408852.214],"after":[102408852.368],"destroy":102408852.706},{"asyncId":1562,"parentAsyncId":1459,"triggerAsyncId":1459,"executionAsyncId":1459,"init":102408852.407,"before":[102408852.741],"after":[102408852.894],"destroy":102408855.065},{"asyncId":190,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404956.639,"before":[102404957.219],"after":[102404957.403],"destroy":102404957.771},{"asyncId":196,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404957.452,"before":[102404957.807],"after":[102404958.121],"destroy":102404958.569},{"asyncId":202,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404958.182,"before":[102404958.611],"after":[102404958.775],"destroy":102404959.355},{"asyncId":208,"parentAsyncId":102,"triggerAsyncId":102,"executionAsyncId":102,"init":102404958.813,"before":[102404959.407],"after":[102404959.592],"destroy":102404962.054},{"asyncId":452,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405757.317,"before":[102405757.677],"after":[102405757.842],"destroy":102405758.191},{"asyncId":458,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405757.879,"before":[102405758.229],"after":[102405758.395],"destroy":102405758.738},{"asyncId":464,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405758.431,"before":[102405758.773],"after":[102405758.934],"destroy":102405759.495},{"asyncId":470,"parentAsyncId":345,"triggerAsyncId":345,"executionAsyncId":345,"init":102405758.97,"before":[102405759.535],"after":[102405759.714],"destroy":102405761.894},{"asyncId":713,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406528.76,"before":[102406529.183],"after":[102406529.34],"destroy":102406529.684},{"asyncId":719,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406529.382,"before":[102406529.717],"after":[102406529.869],"destroy":102406530.197},{"asyncId":725,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406529.904,"before":[102406530.233],"after":[102406530.406],"destroy":102406530.744},{"asyncId":731,"parentAsyncId":605,"triggerAsyncId":605,"executionAsyncId":605,"init":102406530.443,"before":[102406530.781],"after":[102406530.942],"destroy":102406532.985},{"asyncId":974,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407284.1,"before":[102407284.429],"after":[102407284.572],"destroy":102407284.889},{"asyncId":980,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407284.608,"before":[102407284.926],"after":[102407285.068],"destroy":102407285.385},{"asyncId":986,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407285.103,"before":[102407285.422],"after":[102407285.563],"destroy":102407285.873},{"asyncId":992,"parentAsyncId":866,"triggerAsyncId":866,"executionAsyncId":866,"init":102407285.598,"before":[102407285.91],"after":[102407286.05],"destroy":102407288.032},{"asyncId":1235,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408058.16,"before":[102408058.485],"after":[102408058.628],"destroy":102408058.936},{"asyncId":1241,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408058.664,"before":[102408058.967],"after":[102408059.163],"destroy":102408059.707},{"asyncId":1247,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408059.214,"before":[102408059.747],"after":[102408059.923],"destroy":102408060.249},{"asyncId":1253,"parentAsyncId":1123,"triggerAsyncId":1123,"executionAsyncId":1123,"init":102408059.963,"before":[102408060.281],"after":[102408060.423],"destroy":102408062.325},{"asyncId":1491,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408806.903,"before":[102408807.239],"after":[102408807.39],"destroy":102408807.731},{"asyncId":1497,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408807.425,"before":[102408807.775],"after":[102408807.929],"destroy":102408808.261},{"asyncId":1503,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408807.964,"before":[102408808.297],"after":[102408808.481],"destroy":102408808.814},{"asyncId":1509,"parentAsyncId":1384,"triggerAsyncId":1384,"executionAsyncId":1384,"init":102408808.516,"before":[102408808.85],"after":[102408809.006],"destroy":102408811.183}]},{"aggregateId":47,"parentAggregateId":36,"name":"finished@thunky","children":[],"mark":["external","mongojs",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","typeName":"Immediate","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"runCallback","isToplevel":true,"fileName":"timers.js","lineNumber":810,"columnNumber":20},{"functionName":"tryOnImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":768,"columnNumber":5},{"functionName":"processImmediate","typeName":"process","fileName":"timers.js","lineNumber":745,"columnNumber":5}],"sources":[{"asyncId":246,"parentAsyncId":243,"triggerAsyncId":243,"executionAsyncId":243,"init":102404981.576,"before":[102404981.777],"after":[102404982.017],"destroy":102404982.15},{"asyncId":252,"parentAsyncId":249,"triggerAsyncId":249,"executionAsyncId":249,"init":102404982.21,"before":[102404982.377],"after":[102404982.619],"destroy":102404982.733},{"asyncId":258,"parentAsyncId":255,"triggerAsyncId":255,"executionAsyncId":255,"init":102404982.775,"before":[102404982.935],"after":[102404983.166],"destroy":102404983.278},{"asyncId":264,"parentAsyncId":261,"triggerAsyncId":261,"executionAsyncId":261,"init":102404983.318,"before":[102404983.481],"after":[102404984.047],"destroy":102404985.63},{"asyncId":508,"parentAsyncId":505,"triggerAsyncId":505,"executionAsyncId":505,"init":102405771.752,"before":[102405771.921],"after":[102405772.151],"destroy":102405772.254},{"asyncId":514,"parentAsyncId":511,"triggerAsyncId":511,"executionAsyncId":511,"init":102405772.291,"before":[102405772.459],"after":[102405772.686],"destroy":102405772.786},{"asyncId":520,"parentAsyncId":517,"triggerAsyncId":517,"executionAsyncId":517,"init":102405772.822,"before":[102405772.982],"after":[102405773.208],"destroy":102405773.309},{"asyncId":526,"parentAsyncId":523,"triggerAsyncId":523,"executionAsyncId":523,"init":102405773.345,"before":[102405773.507],"after":[102405774.056],"destroy":102405775.552},{"asyncId":769,"parentAsyncId":766,"triggerAsyncId":766,"executionAsyncId":766,"init":102406543.706,"before":[102406543.862],"after":[102406544.085],"destroy":102406544.185},{"asyncId":775,"parentAsyncId":772,"triggerAsyncId":772,"executionAsyncId":772,"init":102406544.221,"before":[102406544.372],"after":[102406544.596],"destroy":102406544.698},{"asyncId":781,"parentAsyncId":778,"triggerAsyncId":778,"executionAsyncId":778,"init":102406544.734,"before":[102406544.909],"after":[102406545.411],"destroy":102406545.547},{"asyncId":787,"parentAsyncId":784,"triggerAsyncId":784,"executionAsyncId":784,"init":102406545.61,"before":[102406545.864],"after":[102406546.471],"destroy":102406548.118},{"asyncId":1030,"parentAsyncId":1027,"triggerAsyncId":1027,"executionAsyncId":1027,"init":102407313.689,"before":[102407313.828],"after":[102407314.037],"destroy":102407314.136},{"asyncId":1036,"parentAsyncId":1033,"triggerAsyncId":1033,"executionAsyncId":1033,"init":102407314.175,"before":[102407314.313],"after":[102407314.515],"destroy":102407314.623},{"asyncId":1042,"parentAsyncId":1039,"triggerAsyncId":1039,"executionAsyncId":1039,"init":102407314.666,"before":[102407314.814],"after":[102407315.016],"destroy":102407315.123},{"asyncId":1048,"parentAsyncId":1045,"triggerAsyncId":1045,"executionAsyncId":1045,"init":102407315.163,"before":[102407315.304],"after":[102407315.77],"destroy":102407317.143},{"asyncId":1291,"parentAsyncId":1288,"triggerAsyncId":1288,"executionAsyncId":1288,"init":102408087.272,"before":[102408087.464],"after":[102408087.674],"destroy":102408087.786},{"asyncId":1297,"parentAsyncId":1294,"triggerAsyncId":1294,"executionAsyncId":1294,"init":102408087.827,"before":[102408087.971],"after":[102408088.173],"destroy":102408088.281},{"asyncId":1303,"parentAsyncId":1300,"triggerAsyncId":1300,"executionAsyncId":1300,"init":102408088.319,"before":[102408088.46],"after":[102408088.668],"destroy":102408088.774},{"asyncId":1309,"parentAsyncId":1306,"triggerAsyncId":1306,"executionAsyncId":1306,"init":102408088.823,"before":[102408088.964],"after":[102408089.443],"destroy":102408090.826},{"asyncId":1547,"parentAsyncId":1544,"triggerAsyncId":1544,"executionAsyncId":1544,"init":102408851.033,"before":[102408851.186],"after":[102408851.536],"destroy":102408851.65},{"asyncId":1553,"parentAsyncId":1550,"triggerAsyncId":1550,"executionAsyncId":1550,"init":102408851.694,"before":[102408851.852],"after":[102408852.075],"destroy":102408852.184},{"asyncId":1559,"parentAsyncId":1556,"triggerAsyncId":1556,"executionAsyncId":1556,"init":102408852.225,"before":[102408852.38],"after":[102408852.606],"destroy":102408852.715},{"asyncId":1565,"parentAsyncId":1562,"triggerAsyncId":1562,"executionAsyncId":1562,"init":102408852.753,"before":[102408852.905],"after":[102408853.475],"destroy":102408855.073},{"asyncId":193,"parentAsyncId":190,"triggerAsyncId":190,"executionAsyncId":190,"init":102404957.234,"before":[102404957.419],"after":[102404957.665],"destroy":102404957.778},{"asyncId":199,"parentAsyncId":196,"triggerAsyncId":196,"executionAsyncId":196,"init":102404957.82,"before":[102404958.139],"after":[102404958.456],"destroy":102404958.579},{"asyncId":205,"parentAsyncId":202,"triggerAsyncId":202,"executionAsyncId":202,"init":102404958.625,"before":[102404958.787],"after":[102404959.049],"destroy":102404959.365},{"asyncId":211,"parentAsyncId":208,"triggerAsyncId":208,"executionAsyncId":208,"init":102404959.422,"before":[102404959.605],"after":[102404960.45],"destroy":102404962.063},{"asyncId":455,"parentAsyncId":452,"triggerAsyncId":452,"executionAsyncId":452,"init":102405757.693,"before":[102405757.854],"after":[102405758.089],"destroy":102405758.2},{"asyncId":461,"parentAsyncId":458,"triggerAsyncId":458,"executionAsyncId":458,"init":102405758.245,"before":[102405758.407],"after":[102405758.639],"destroy":102405758.747},{"asyncId":467,"parentAsyncId":464,"triggerAsyncId":464,"executionAsyncId":464,"init":102405758.785,"before":[102405758.945],"after":[102405759.335],"destroy":102405759.505},{"asyncId":473,"parentAsyncId":470,"triggerAsyncId":470,"executionAsyncId":470,"init":102405759.549,"before":[102405759.726],"after":[102405760.29],"destroy":102405761.904},{"asyncId":716,"parentAsyncId":713,"triggerAsyncId":713,"executionAsyncId":713,"init":102406529.195,"before":[102406529.356],"after":[102406529.581],"destroy":102406529.69},{"asyncId":722,"parentAsyncId":719,"triggerAsyncId":719,"executionAsyncId":719,"init":102406529.728,"before":[102406529.88],"after":[102406530.1],"destroy":102406530.202},{"asyncId":728,"parentAsyncId":725,"triggerAsyncId":725,"executionAsyncId":725,"init":102406530.25,"before":[102406530.418],"after":[102406530.641],"destroy":102406530.753},{"asyncId":734,"parentAsyncId":731,"triggerAsyncId":731,"executionAsyncId":731,"init":102406530.793,"before":[102406530.954],"after":[102406531.496],"destroy":102406532.994},{"asyncId":977,"parentAsyncId":974,"triggerAsyncId":974,"executionAsyncId":974,"init":102407284.441,"before":[102407284.584],"after":[102407284.788],"destroy":102407284.898},{"asyncId":983,"parentAsyncId":980,"triggerAsyncId":980,"executionAsyncId":980,"init":102407284.938,"before":[102407285.079],"after":[102407285.288],"destroy":102407285.395},{"asyncId":989,"parentAsyncId":986,"triggerAsyncId":986,"executionAsyncId":986,"init":102407285.433,"before":[102407285.574],"after":[102407285.775],"destroy":102407285.882},{"asyncId":995,"parentAsyncId":992,"triggerAsyncId":992,"executionAsyncId":992,"init":102407285.922,"before":[102407286.062],"after":[102407286.531],"destroy":102407288.041},{"asyncId":1238,"parentAsyncId":1235,"triggerAsyncId":1235,"executionAsyncId":1235,"init":102408058.497,"before":[102408058.639],"after":[102408058.843],"destroy":102408058.942},{"asyncId":1244,"parentAsyncId":1241,"triggerAsyncId":1241,"executionAsyncId":1241,"init":102408058.979,"before":[102408059.18],"after":[102408059.559],"destroy":102408059.716},{"asyncId":1250,"parentAsyncId":1247,"triggerAsyncId":1247,"executionAsyncId":1247,"init":102408059.761,"before":[102408059.935],"after":[102408060.152],"destroy":102408060.255},{"asyncId":1256,"parentAsyncId":1253,"triggerAsyncId":1253,"executionAsyncId":1253,"init":102408060.293,"before":[102408060.435],"after":[102408060.908],"destroy":102408062.337},{"asyncId":1494,"parentAsyncId":1491,"triggerAsyncId":1491,"executionAsyncId":1491,"init":102408807.25,"before":[102408807.401],"after":[102408807.628],"destroy":102408807.74},{"asyncId":1500,"parentAsyncId":1497,"triggerAsyncId":1497,"executionAsyncId":1497,"init":102408807.786,"before":[102408807.94],"after":[102408808.164],"destroy":102408808.27},{"asyncId":1506,"parentAsyncId":1503,"triggerAsyncId":1503,"executionAsyncId":1503,"init":102408808.312,"before":[102408808.492],"after":[102408808.717],"destroy":102408808.823},{"asyncId":1512,"parentAsyncId":1509,"triggerAsyncId":1509,"executionAsyncId":1509,"init":102408808.866,"before":[102408809.018],"after":[102408809.694],"destroy":102408811.192}]}]},
{"clusterId":19,"parentClusterId":10,"name":"thunky > mongojs","children":[],"nodes":[{"aggregateId":48,"parentAggregateId":37,"name":"finished@thunky","children":[59],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"done","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":28,"columnNumber":28},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":29,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":35,"columnNumber":7},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/collection.js","lineNumber":20,"columnNumber":7},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":271,"parentAsyncId":269,"triggerAsyncId":269,"executionAsyncId":269,"init":102404984.175,"before":[102404984.351],"after":[102404984.609],"destroy":102404985.688},{"asyncId":533,"parentAsyncId":531,"triggerAsyncId":531,"executionAsyncId":531,"init":102405774.181,"before":[102405774.355],"after":[102405774.617],"destroy":102405775.602},{"asyncId":794,"parentAsyncId":792,"triggerAsyncId":792,"executionAsyncId":792,"init":102406546.602,"before":[102406546.775],"after":[102406547.049],"destroy":102406548.169},{"asyncId":1055,"parentAsyncId":1053,"triggerAsyncId":1053,"executionAsyncId":1053,"init":102407315.894,"before":[102407316.051],"after":[102407316.29],"destroy":102407317.18},{"asyncId":1316,"parentAsyncId":1314,"triggerAsyncId":1314,"executionAsyncId":1314,"init":102408089.567,"before":[102408089.723],"after":[102408089.976],"destroy":102408090.865},{"asyncId":1572,"parentAsyncId":1570,"triggerAsyncId":1570,"executionAsyncId":1570,"init":102408853.603,"before":[102408853.775],"after":[102408854.032],"destroy":102408855.12},{"asyncId":218,"parentAsyncId":216,"triggerAsyncId":216,"executionAsyncId":216,"init":102404960.585,"before":[102404960.76],"after":[102404961.041],"destroy":102404962.116},{"asyncId":480,"parentAsyncId":478,"triggerAsyncId":478,"executionAsyncId":478,"init":102405760.421,"before":[102405760.592],"after":[102405760.859],"destroy":102405761.95},{"asyncId":741,"parentAsyncId":739,"triggerAsyncId":739,"executionAsyncId":739,"init":102406531.625,"before":[102406531.8],"after":[102406532.061],"destroy":102406533.036},{"asyncId":1002,"parentAsyncId":1000,"triggerAsyncId":1000,"executionAsyncId":1000,"init":102407286.653,"before":[102407286.821],"after":[102407287.061],"destroy":102407288.091},{"asyncId":1263,"parentAsyncId":1261,"triggerAsyncId":1261,"executionAsyncId":1261,"init":102408061.034,"before":[102408061.191],"after":[102408061.446],"destroy":102408062.384},{"asyncId":1519,"parentAsyncId":1517,"triggerAsyncId":1517,"executionAsyncId":1517,"init":102408809.827,"before":[102408810.025],"after":[102408810.292],"destroy":102408811.241}]},{"aggregateId":59,"parentAggregateId":48,"name":"Pool.write@mongodb-core","children":[67],"mark":["external","thunky",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"Pool.write","typeName":"Pool","fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1027,"columnNumber":13},{"functionName":"Cursor._find","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":286,"columnNumber":22},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":593,"columnNumber":10},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":274,"parentAsyncId":271,"triggerAsyncId":271,"executionAsyncId":271,"init":102404984.441,"before":[102404984.651],"after":[102404985.421],"destroy":102404985.714},{"asyncId":536,"parentAsyncId":533,"triggerAsyncId":533,"executionAsyncId":533,"init":102405774.45,"before":[102405774.655],"after":[102405775.378],"destroy":102405775.624},{"asyncId":797,"parentAsyncId":794,"triggerAsyncId":794,"executionAsyncId":794,"init":102406546.883,"before":[102406547.086],"after":[102406547.89],"destroy":102406548.192},{"asyncId":1058,"parentAsyncId":1055,"triggerAsyncId":1055,"executionAsyncId":1055,"init":102407316.141,"before":[102407316.33],"after":[102407316.969],"destroy":102407317.197},{"asyncId":1319,"parentAsyncId":1316,"triggerAsyncId":1316,"executionAsyncId":1316,"init":102408089.821,"before":[102408090.014],"after":[102408090.631],"destroy":102408090.887},{"asyncId":1575,"parentAsyncId":1572,"triggerAsyncId":1572,"executionAsyncId":1572,"init":102408853.864,"before":[102408854.07],"after":[102408854.907],"destroy":102408855.138},{"asyncId":221,"parentAsyncId":218,"triggerAsyncId":218,"executionAsyncId":218,"init":102404960.864,"before":[102404961.082],"after":[102404961.831],"destroy":102404962.142},{"asyncId":483,"parentAsyncId":480,"triggerAsyncId":480,"executionAsyncId":480,"init":102405760.689,"before":[102405760.901],"after":[102405761.671],"destroy":102405761.974},{"asyncId":744,"parentAsyncId":741,"triggerAsyncId":741,"executionAsyncId":741,"init":102406531.896,"before":[102406532.098],"after":[102406532.817],"destroy":102406533.052},{"asyncId":1005,"parentAsyncId":1002,"triggerAsyncId":1002,"executionAsyncId":1002,"init":102407286.911,"before":[102407287.099],"after":[102407287.815],"destroy":102407288.111},{"asyncId":1266,"parentAsyncId":1263,"triggerAsyncId":1263,"executionAsyncId":1263,"init":102408061.295,"before":[102408061.484],"after":[102408062.116],"destroy":102408062.41},{"asyncId":1522,"parentAsyncId":1519,"triggerAsyncId":1519,"executionAsyncId":1519,"init":102408810.116,"before":[102408810.33],"after":[102408810.976],"destroy":102408811.265}]},{"aggregateId":67,"parentAggregateId":59,"name":"Connection.write@mongodb-core","children":[],"mark":["external","mongodb-core",null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"writeOrBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":383,"columnNumber":5},{"functionName":"Writable.write","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":290,"columnNumber":11},{"functionName":"Socket.write","typeName":"Socket","fileName":"net.js","lineNumber":707,"columnNumber":40},{"functionName":"Connection.write","typeName":"Connection","fileName":"./node_modules/mongodb-core/lib/connection/connection.js","lineNumber":543,"columnNumber":23},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1298,"columnNumber":44},{"functionName":"waitForAuth","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1156,"columnNumber":39},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1164,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":1028,"columnNumber":21},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":276,"parentAsyncId":274,"triggerAsyncId":274,"executionAsyncId":274,"init":102404984.757,"before":[102404985.452],"after":[102404985.459],"destroy":102404985.744},{"asyncId":279,"parentAsyncId":274,"triggerAsyncId":274,"executionAsyncId":274,"init":102404985.139,"before":[102404985.503],"after":[102404985.514],"destroy":102404985.77},{"asyncId":538,"parentAsyncId":536,"triggerAsyncId":536,"executionAsyncId":536,"init":102405774.718,"before":[102405775.405],"after":[102405775.412],"destroy":102405775.639},{"asyncId":541,"parentAsyncId":536,"triggerAsyncId":536,"executionAsyncId":536,"init":102405775.077,"before":[102405775.449],"after":[102405775.455],"destroy":102405775.667},{"asyncId":799,"parentAsyncId":797,"triggerAsyncId":797,"executionAsyncId":797,"init":102406547.147,"before":[102406547.929],"after":[102406547.94],"destroy":102406548.207},{"asyncId":802,"parentAsyncId":797,"triggerAsyncId":797,"executionAsyncId":797,"init":102406547.515,"before":[102406547.991],"after":[102406548],"destroy":102406548.228},{"asyncId":1060,"parentAsyncId":1058,"triggerAsyncId":1058,"executionAsyncId":1058,"init":102407316.394,"before":[102407316.998],"after":[102407317.004],"destroy":102407317.211},{"asyncId":1063,"parentAsyncId":1058,"triggerAsyncId":1058,"executionAsyncId":1058,"init":102407316.696,"before":[102407317.038],"after":[102407317.045],"destroy":102407317.226},{"asyncId":1321,"parentAsyncId":1319,"triggerAsyncId":1319,"executionAsyncId":1319,"init":102408090.082,"before":[102408090.671],"after":[102408090.681],"destroy":102408090.897},{"asyncId":1324,"parentAsyncId":1319,"triggerAsyncId":1319,"executionAsyncId":1319,"init":102408090.357,"before":[102408090.728],"after":[102408090.735],"destroy":102408090.915},{"asyncId":1577,"parentAsyncId":1575,"triggerAsyncId":1575,"executionAsyncId":1575,"init":102408854.155,"before":[102408854.936],"after":[102408854.943],"destroy":102408855.151},{"asyncId":1580,"parentAsyncId":1575,"triggerAsyncId":1575,"executionAsyncId":1575,"init":102408854.594,"before":[102408854.977],"after":[102408854.986],"destroy":102408855.168},{"asyncId":223,"parentAsyncId":221,"triggerAsyncId":221,"executionAsyncId":221,"init":102404961.171,"before":[102404961.871],"after":[102404961.881],"destroy":102404962.159},{"asyncId":226,"parentAsyncId":221,"triggerAsyncId":221,"executionAsyncId":221,"init":102404961.55,"before":[102404961.936],"after":[102404961.946],"destroy":102404962.185},{"asyncId":485,"parentAsyncId":483,"triggerAsyncId":483,"executionAsyncId":483,"init":102405760.985,"before":[102405761.707],"after":[102405761.717],"destroy":102405761.989},{"asyncId":488,"parentAsyncId":483,"triggerAsyncId":483,"executionAsyncId":483,"init":102405761.298,"before":[102405761.767],"after":[102405761.777],"destroy":102405762.018},{"asyncId":746,"parentAsyncId":744,"triggerAsyncId":744,"executionAsyncId":744,"init":102406532.191,"before":[102406532.846],"after":[102406532.853],"destroy":102406533.062},{"asyncId":749,"parentAsyncId":744,"triggerAsyncId":744,"executionAsyncId":744,"init":102406532.5,"before":[102406532.89],"after":[102406532.896],"destroy":102406533.077},{"asyncId":1007,"parentAsyncId":1005,"triggerAsyncId":1005,"executionAsyncId":1005,"init":102407287.164,"before":[102407287.855],"after":[102407287.865],"destroy":102407288.121},{"asyncId":1010,"parentAsyncId":1005,"triggerAsyncId":1005,"executionAsyncId":1005,"init":102407287.504,"before":[102407287.919],"after":[102407287.928],"destroy":102407288.136},{"asyncId":1268,"parentAsyncId":1266,"triggerAsyncId":1266,"executionAsyncId":1266,"init":102408061.551,"before":[102408062.154],"after":[102408062.165],"destroy":102408062.439},{"asyncId":1271,"parentAsyncId":1266,"triggerAsyncId":1266,"executionAsyncId":1266,"init":102408061.819,"before":[102408062.215],"after":[102408062.224],"destroy":102408062.462},{"asyncId":1524,"parentAsyncId":1522,"triggerAsyncId":1522,"executionAsyncId":1522,"init":102408810.41,"before":[102408811.007],"after":[102408811.019],"destroy":102408811.282},{"asyncId":1527,"parentAsyncId":1522,"triggerAsyncId":1522,"executionAsyncId":1522,"init":102408810.727,"before":[102408811.073],"after":[102408811.083],"destroy":102408811.305}]}]},
{"clusterId":20,"parentClusterId":10,"name":"http.connection.end + timeout","children":[23,24],"nodes":[{"aggregateId":49,"parentAggregateId":38,"name":"onSendEnd@fastify","children":[60,61],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"internalNextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":305,"columnNumber":7},{"functionName":"_writeRaw","typeName":"ServerResponse","fileName":"_http_outgoing.js","lineNumber":269,"columnNumber":9},{"functionName":"_send","typeName":"ServerResponse","fileName":"_http_outgoing.js","lineNumber":237,"columnNumber":15},{"functionName":"end","typeName":"ServerResponse","fileName":"_http_outgoing.js","lineNumber":767,"columnNumber":16},{"functionName":"onSendEnd","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":212,"columnNumber":7},{"functionName":"onSendHook","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":162,"columnNumber":5},{"functionName":"Reply.send","typeName":"_Reply","fileName":"./node_modules/fastify/lib/reply.js","lineNumber":82,"columnNumber":3},{"isToplevel":true,"fileName":"./1.js","lineNumber":16,"columnNumber":13},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":73,"columnNumber":24},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"setCursorDeadAndNotified","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":505,"columnNumber":3},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":608,"columnNumber":12},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":401,"parentAsyncId":267,"triggerAsyncId":57,"executionAsyncId":267,"init":102405368.285,"before":[102405369.291],"after":[102405369.94],"destroy":102405375.448},{"asyncId":662,"parentAsyncId":529,"triggerAsyncId":57,"executionAsyncId":529,"init":102406136.546,"before":[102406137.416],"after":[102406137.775],"destroy":102406142.536},{"asyncId":923,"parentAsyncId":790,"triggerAsyncId":57,"executionAsyncId":790,"init":102406895.613,"before":[102406896.397],"after":[102406896.769],"destroy":102406900.162},{"asyncId":1183,"parentAsyncId":1051,"triggerAsyncId":57,"executionAsyncId":1051,"init":102407682.038,"before":[102407682.718],"after":[102407683.034],"destroy":102407685.784},{"asyncId":1440,"parentAsyncId":1312,"triggerAsyncId":57,"executionAsyncId":1312,"init":102408435.429,"before":[102408436.161],"after":[102408436.502],"destroy":102408439.722},{"asyncId":1701,"parentAsyncId":1568,"triggerAsyncId":57,"executionAsyncId":1568,"init":102409194.968,"before":[102409195.685],"after":[102409196.036],"destroy":102409199.461},{"asyncId":324,"parentAsyncId":214,"triggerAsyncId":71,"executionAsyncId":214,"init":102405338.551,"before":[102405339.819],"after":[102405341.05],"destroy":102405345.287},{"asyncId":586,"parentAsyncId":476,"triggerAsyncId":71,"executionAsyncId":476,"init":102406122.613,"before":[102406123.432],"after":[102406123.814],"destroy":102406127.365},{"asyncId":847,"parentAsyncId":737,"triggerAsyncId":71,"executionAsyncId":737,"init":102406874.141,"before":[102406874.879],"after":[102406875.221],"destroy":102406878.421},{"asyncId":1104,"parentAsyncId":998,"triggerAsyncId":71,"executionAsyncId":998,"init":102407648.859,"before":[102407649.563],"after":[102407649.873],"destroy":102407652.801},{"asyncId":1365,"parentAsyncId":1259,"triggerAsyncId":71,"executionAsyncId":1259,"init":102408396.558,"before":[102408397.262],"after":[102408397.607],"destroy":102408400.823},{"asyncId":1625,"parentAsyncId":1515,"triggerAsyncId":71,"executionAsyncId":1515,"init":102409141.445,"before":[102409142.235],"after":[102409142.588],"destroy":102409145.645}]},{"aggregateId":52,"parentAggregateId":38,"name":"onSendEnd@fastify","children":[],"mark":["user",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"onwrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":453,"columnNumber":15},{"functionName":"Socket._writeGeneric","typeName":"Socket","fileName":"net.js","lineNumber":773,"columnNumber":5},{"functionName":"Socket._write","typeName":"Socket","fileName":"net.js","lineNumber":783,"columnNumber":8},{"functionName":"doWrite","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":397,"columnNumber":12},{"functionName":"clearBuffer","isToplevel":true,"fileName":"_stream_writable.js","lineNumber":524,"columnNumber":7},{"functionName":"Writable.uncork","typeName":"Socket","fileName":"_stream_writable.js","lineNumber":313,"columnNumber":7},{"functionName":"end","typeName":"ServerResponse","fileName":"_http_outgoing.js","lineNumber":771,"columnNumber":21},{"functionName":"onSendEnd","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":212,"columnNumber":7},{"functionName":"onSendHook","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":162,"columnNumber":5},{"functionName":"Reply.send","typeName":"_Reply","fileName":"./node_modules/fastify/lib/reply.js","lineNumber":82,"columnNumber":3},{"isToplevel":true,"fileName":"./1.js","lineNumber":16,"columnNumber":13},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":73,"columnNumber":24},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"setCursorDeadAndNotified","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":505,"columnNumber":3},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":608,"columnNumber":12},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":403,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405368.651,"before":[102405369.978],"after":[102405369.988],"destroy":102405375.471},{"asyncId":664,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406136.964,"before":[102406137.801],"after":[102406137.808],"destroy":102406142.559},{"asyncId":925,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406895.955,"before":[102406896.797],"after":[102406896.804],"destroy":102406900.185},{"asyncId":1185,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407682.299,"before":[102407683.058],"after":[102407683.065],"destroy":102407685.808},{"asyncId":1442,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408435.739,"before":[102408436.53],"after":[102408436.537],"destroy":102408439.747},{"asyncId":1703,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409195.289,"before":[102409196.06],"after":[102409196.067],"destroy":102409199.476},{"asyncId":326,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405338.962,"before":[102405341.09],"after":[102405341.1],"destroy":102405345.314},{"asyncId":588,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406122.944,"before":[102406123.84],"after":[102406123.847],"destroy":102406127.382},{"asyncId":849,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406874.431,"before":[102406875.246],"after":[102406875.253],"destroy":102406878.445},{"asyncId":1106,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407649.142,"before":[102407649.897],"after":[102407649.904],"destroy":102407652.825},{"asyncId":1367,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408396.902,"before":[102408397.632],"after":[102408397.639],"destroy":102408400.849},{"asyncId":1627,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409141.757,"before":[102409142.613],"after":[102409142.62],"destroy":102409145.682}]},{"aggregateId":53,"parentAggregateId":38,"name":"onSendEnd@fastify","children":[],"mark":["user",null,null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"utcDate","isToplevel":true,"fileName":"internal/http.js","lineNumber":11,"columnNumber":12},{"functionName":"_storeHeader","typeName":"ServerResponse","fileName":"_http_outgoing.js","lineNumber":360,"columnNumber":32},{"functionName":"writeHead","typeName":"ServerResponse","fileName":"_http_server.js","lineNumber":257,"columnNumber":8},{"functionName":"onSendEnd","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":209,"columnNumber":7},{"functionName":"onSendHook","isToplevel":true,"fileName":"./node_modules/fastify/lib/reply.js","lineNumber":162,"columnNumber":5},{"functionName":"Reply.send","typeName":"_Reply","fileName":"./node_modules/fastify/lib/reply.js","lineNumber":82,"columnNumber":3},{"isToplevel":true,"fileName":"./1.js","lineNumber":16,"columnNumber":13},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":73,"columnNumber":24},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"setCursorDeadAndNotified","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":505,"columnNumber":3},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":608,"columnNumber":12},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":1181,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407681.798,"before":[102408678.207],"after":[102408678.221],"destroy":102408678.256},{"asyncId":322,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405337.739,"before":[102405679.741],"after":[102405679.878],"destroy":102405679.977},{"asyncId":584,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406122.276,"before":[102406676.116],"after":[102406676.136],"destroy":102406676.183},{"asyncId":845,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406873.873,"before":[102407673.547],"after":[102407673.557],"destroy":102407673.585},{"asyncId":1623,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409141.172,"before":[],"after":[],"destroy":null}]}]},
{"clusterId":21,"parentClusterId":10,"name":"mongojs > mongodb > mongodb-core","children":[],"nodes":[{"aggregateId":50,"parentAggregateId":38,"name":"runInAsyncScope@mongojs","children":[62],"mark":["external","mongodb-core",null],"type":"Immediate","frames":[{"functionName":"Immediate","isConstructor":true,"fileName":"timers.js","lineNumber":837,"columnNumber":5},{"functionName":"createImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":879,"columnNumber":19},{"functionName":"setImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":866,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":77,"columnNumber":7},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":691,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":602,"columnNumber":7},{"functionName":"queryCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":232,"columnNumber":18},{"isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/connection/pool.js","lineNumber":469,"columnNumber":18},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":371,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405362.957,"before":[102405363.3],"after":[102405363.466],"destroy":102405363.805},{"asyncId":632,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406131.619,"before":[102406132.04],"after":[102406132.237],"destroy":102406132.67},{"asyncId":893,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406889.685,"before":[102406890.097],"after":[102406890.308],"destroy":102406890.719},{"asyncId":1149,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407677.59,"before":[102407677.909],"after":[102407678.049],"destroy":102407678.37},{"asyncId":1410,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408431.328,"before":[102408431.671],"after":[102408431.825],"destroy":102408432.166},{"asyncId":1671,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409189.409,"before":[102409189.939],"after":[102409190.187],"destroy":102409190.725},{"asyncId":290,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405331.567,"before":[102405331.927],"after":[102405332.085],"destroy":102405332.438},{"asyncId":552,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406116.549,"before":[102406117.078],"after":[102406117.343],"destroy":102406117.826},{"asyncId":813,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406869.42,"before":[102406869.759],"after":[102406869.924],"destroy":102406870.272},{"asyncId":1074,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407645.144,"before":[102407645.465],"after":[102407645.607],"destroy":102407645.936},{"asyncId":1335,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408391.415,"before":[102408391.733],"after":[102408391.884],"destroy":102408392.207},{"asyncId":1591,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409136.425,"before":[102409136.809],"after":[102409136.965],"destroy":102409137.301}]},{"aggregateId":62,"parentAggregateId":50,"name":"finished@thunky","children":[],"mark":["external","mongojs",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","typeName":"Immediate","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"runCallback","isToplevel":true,"fileName":"timers.js","lineNumber":810,"columnNumber":20},{"functionName":"tryOnImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":768,"columnNumber":5},{"functionName":"processImmediate","typeName":"process","fileName":"timers.js","lineNumber":745,"columnNumber":5}],"sources":[{"asyncId":374,"parentAsyncId":371,"triggerAsyncId":371,"executionAsyncId":371,"init":102405363.312,"before":[102405363.477],"after":[102405363.707],"destroy":102405363.812},{"asyncId":635,"parentAsyncId":632,"triggerAsyncId":632,"executionAsyncId":632,"init":102406132.056,"before":[102406132.25],"after":[102406132.55],"destroy":102406132.682},{"asyncId":896,"parentAsyncId":893,"triggerAsyncId":893,"executionAsyncId":893,"init":102406890.109,"before":[102406890.323],"after":[102406890.608],"destroy":102406890.728},{"asyncId":1152,"parentAsyncId":1149,"triggerAsyncId":1149,"executionAsyncId":1149,"init":102407677.921,"before":[102407678.061],"after":[102407678.268],"destroy":102407678.38},{"asyncId":1413,"parentAsyncId":1410,"triggerAsyncId":1410,"executionAsyncId":1410,"init":102408431.683,"before":[102408431.837],"after":[102408432.069],"destroy":102408432.172},{"asyncId":1674,"parentAsyncId":1671,"triggerAsyncId":1671,"executionAsyncId":1671,"init":102409189.955,"before":[102409190.204],"after":[102409190.587],"destroy":102409190.734},{"asyncId":293,"parentAsyncId":290,"triggerAsyncId":290,"executionAsyncId":290,"init":102405331.939,"before":[102405332.098],"after":[102405332.329],"destroy":102405332.447},{"asyncId":555,"parentAsyncId":552,"triggerAsyncId":552,"executionAsyncId":552,"init":102406117.095,"before":[102406117.359],"after":[102406117.694],"destroy":102406117.835},{"asyncId":816,"parentAsyncId":813,"triggerAsyncId":813,"executionAsyncId":813,"init":102406869.771,"before":[102406869.936],"after":[102406870.171],"destroy":102406870.278},{"asyncId":1077,"parentAsyncId":1074,"triggerAsyncId":1074,"executionAsyncId":1074,"init":102407645.477,"before":[102407645.619],"after":[102407645.833],"destroy":102407645.946},{"asyncId":1338,"parentAsyncId":1335,"triggerAsyncId":1335,"executionAsyncId":1335,"init":102408391.745,"before":[102408391.895],"after":[102408392.101],"destroy":102408392.215},{"asyncId":1594,"parentAsyncId":1591,"triggerAsyncId":1591,"executionAsyncId":1591,"init":102409136.821,"before":[102409136.977],"after":[102409137.204],"destroy":102409137.307}]}]},
{"clusterId":22,"parentClusterId":10,"name":"... > mongodb > mongodb-core > thunky","children":[],"nodes":[{"aggregateId":51,"parentAggregateId":38,"name":"runInAsyncScope@mongojs","children":[63],"mark":["external","thunky",null],"type":"Immediate","frames":[{"functionName":"Immediate","isConstructor":true,"fileName":"timers.js","lineNumber":837,"columnNumber":5},{"functionName":"createImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":879,"columnNumber":19},{"functionName":"setImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":866,"columnNumber":10},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":77,"columnNumber":7},{"functionName":"runInAsyncScope","isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":198,"columnNumber":5},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":205,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb/lib/utils.js","lineNumber":120,"columnNumber":56},{"isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":683,"columnNumber":5},{"functionName":"handleCallback","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":171,"columnNumber":5},{"functionName":"nextFunction","isToplevel":true,"fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":691,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb-core/lib/cursor.js","lineNumber":701,"columnNumber":3},{"functionName":"nextObject","isToplevel":true,"fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":680,"columnNumber":8},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongodb/lib/cursor.js","lineNumber":270,"columnNumber":12},{"isToplevel":true,"fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":48,"columnNumber":14},{"functionName":"apply","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":44,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":377,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405363.503,"before":[102405363.838],"after":[102405363.993],"destroy":102405364.332},{"asyncId":383,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405364.029,"before":[102405364.369],"after":[102405364.53],"destroy":102405365.782},{"asyncId":389,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405364.566,"before":[102405365.829],"after":[102405366.091],"destroy":102405366.638},{"asyncId":395,"parentAsyncId":267,"triggerAsyncId":267,"executionAsyncId":267,"init":102405366.14,"before":[102405366.687],"after":[102405366.942],"destroy":102405375.416},{"asyncId":638,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406132.285,"before":[102406132.723],"after":[102406132.915],"destroy":102406133.4},{"asyncId":644,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406132.991,"before":[102406133.443],"after":[102406133.625],"destroy":102406133.998},{"asyncId":650,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406133.663,"before":[102406134.047],"after":[102406134.259],"destroy":102406134.617},{"asyncId":656,"parentAsyncId":529,"triggerAsyncId":529,"executionAsyncId":529,"init":102406134.296,"before":[102406134.649],"after":[102406134.815],"destroy":102406142.503},{"asyncId":899,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406890.35,"before":[102406890.763],"after":[102406890.977],"destroy":102406891.379},{"asyncId":905,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406891.018,"before":[102406891.419],"after":[102406891.611],"destroy":102406892.018},{"asyncId":911,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406891.658,"before":[102406892.059],"after":[102406892.235],"destroy":102406894.025},{"asyncId":917,"parentAsyncId":790,"triggerAsyncId":790,"executionAsyncId":790,"init":102406892.283,"before":[102406894.069],"after":[102406894.234],"destroy":102406900.128},{"asyncId":1155,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407678.087,"before":[102407678.41],"after":[102407678.55],"destroy":102407678.862},{"asyncId":1161,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407678.585,"before":[102407678.911],"after":[102407679.316],"destroy":102407679.683},{"asyncId":1167,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407679.37,"before":[102407679.732],"after":[102407679.904],"destroy":102407680.221},{"asyncId":1173,"parentAsyncId":1051,"triggerAsyncId":1051,"executionAsyncId":1051,"init":102407679.941,"before":[102407680.252],"after":[102407680.395],"destroy":102407685.733},{"asyncId":1416,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408431.863,"before":[102408432.202],"after":[102408432.357],"destroy":102408432.691},{"asyncId":1422,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408432.393,"before":[102408432.722],"after":[102408432.877],"destroy":102408433.203},{"asyncId":1428,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408432.913,"before":[102408433.235],"after":[102408433.392],"destroy":102408433.723},{"asyncId":1434,"parentAsyncId":1312,"triggerAsyncId":1312,"executionAsyncId":1312,"init":102408433.427,"before":[102408433.768],"after":[102408433.926],"destroy":102408439.689},{"asyncId":1677,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409190.24,"before":[102409190.771],"after":[102409191.023],"destroy":102409191.551},{"asyncId":1683,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409191.072,"before":[102409191.596],"after":[102409191.843],"destroy":102409192.575},{"asyncId":1689,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409192.127,"before":[102409192.631],"after":[102409192.799],"destroy":102409193.139},{"asyncId":1695,"parentAsyncId":1568,"triggerAsyncId":1568,"executionAsyncId":1568,"init":102409192.837,"before":[102409193.177],"after":[102409193.339],"destroy":102409199.438},{"asyncId":296,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405332.125,"before":[102405332.488],"after":[102405332.657],"destroy":102405333.003},{"asyncId":302,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405332.694,"before":[102405333.041],"after":[102405333.199],"destroy":102405333.54},{"asyncId":308,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405333.237,"before":[102405333.578],"after":[102405333.733],"destroy":102405334.08},{"asyncId":314,"parentAsyncId":214,"triggerAsyncId":214,"executionAsyncId":214,"init":102405333.77,"before":[102405334.118],"after":[102405334.273],"destroy":102405344.685},{"asyncId":558,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406117.396,"before":[102406117.871],"after":[102406118.135],"destroy":102406118.563},{"asyncId":564,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406118.191,"before":[102406118.607],"after":[102406118.778],"destroy":102406119.355},{"asyncId":570,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406118.816,"before":[102406119.406],"after":[102406119.623],"destroy":102406120.006},{"asyncId":576,"parentAsyncId":476,"triggerAsyncId":476,"executionAsyncId":476,"init":102406119.664,"before":[102406120.047],"after":[102406120.223],"destroy":102406127.327},{"asyncId":819,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406869.962,"before":[102406870.305],"after":[102406870.488],"destroy":102406870.828},{"asyncId":825,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406870.524,"before":[102406870.865],"after":[102406871.023],"destroy":102406871.365},{"asyncId":831,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406871.059,"before":[102406871.403],"after":[102406871.56],"destroy":102406871.891},{"asyncId":837,"parentAsyncId":737,"triggerAsyncId":737,"executionAsyncId":737,"init":102406871.596,"before":[102406871.923],"after":[102406872.076],"destroy":102406878.37},{"asyncId":1080,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407645.645,"before":[102407645.979],"after":[102407646.148],"destroy":102407646.461},{"asyncId":1086,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407646.184,"before":[102407646.502],"after":[102407646.645],"destroy":102407646.954},{"asyncId":1092,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407646.68,"before":[102407646.99],"after":[102407647.129],"destroy":102407647.446},{"asyncId":1098,"parentAsyncId":998,"triggerAsyncId":998,"executionAsyncId":998,"init":102407647.164,"before":[102407647.499],"after":[102407647.716],"destroy":102407652.769},{"asyncId":1341,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408391.922,"before":[102408392.248],"after":[102408392.389],"destroy":102408392.706},{"asyncId":1347,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408392.426,"before":[102408392.743],"after":[102408392.899],"destroy":102408393.851},{"asyncId":1353,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408393.401,"before":[102408393.9],"after":[102408394.132],"destroy":102408394.626},{"asyncId":1359,"parentAsyncId":1259,"triggerAsyncId":1259,"executionAsyncId":1259,"init":102408394.183,"before":[102408394.681],"after":[102408394.912],"destroy":102408400.79},{"asyncId":1597,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409137.003,"before":[102409137.34],"after":[102409137.499],"destroy":102409137.835},{"asyncId":1603,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409137.534,"before":[102409137.866],"after":[102409138.027],"destroy":102409138.362},{"asyncId":1609,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409138.062,"before":[102409138.393],"after":[102409138.548],"destroy":102409138.874},{"asyncId":1615,"parentAsyncId":1515,"triggerAsyncId":1515,"executionAsyncId":1515,"init":102409138.583,"before":[102409138.905],"after":[102409139.265],"destroy":102409145.597}]},{"aggregateId":63,"parentAggregateId":51,"name":"finished@thunky","children":[],"mark":["external","mongojs",null],"type":"TickObject","frames":[{"functionName":"nextTick","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"finished","isToplevel":true,"fileName":"./node_modules/thunky/index.js","lineNumber":31,"columnNumber":9},{"functionName":"thunk","typeName":"Cursor","fileName":"./node_modules/thunky/index.js","lineNumber":13,"columnNumber":5},{"functionName":"Cursor.next","typeName":"Cursor","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":41,"columnNumber":8},{"functionName":"loop","typeName":"Immediate","fileName":"./node_modules/mongojs/lib/cursor.js","lineNumber":71,"columnNumber":10},{"functionName":"runCallback","isToplevel":true,"fileName":"timers.js","lineNumber":810,"columnNumber":20},{"functionName":"tryOnImmediate","isToplevel":true,"fileName":"timers.js","lineNumber":768,"columnNumber":5},{"functionName":"processImmediate","typeName":"process","fileName":"timers.js","lineNumber":745,"columnNumber":5}],"sources":[{"asyncId":380,"parentAsyncId":377,"triggerAsyncId":377,"executionAsyncId":377,"init":102405363.849,"before":[102405364.005],"after":[102405364.231],"destroy":102405364.341},{"asyncId":386,"parentAsyncId":383,"triggerAsyncId":383,"executionAsyncId":383,"init":102405364.381,"before":[102405364.542],"after":[102405365.649],"destroy":102405365.791},{"asyncId":392,"parentAsyncId":389,"triggerAsyncId":389,"executionAsyncId":389,"init":102405365.847,"before":[102405366.108],"after":[102405366.494],"destroy":102405366.648},{"asyncId":398,"parentAsyncId":395,"triggerAsyncId":395,"executionAsyncId":395,"init":102405366.705,"before":[102405366.959],"after":[102405369.215],"destroy":102405375.425},{"asyncId":641,"parentAsyncId":638,"triggerAsyncId":638,"executionAsyncId":638,"init":102406132.736,"before":[102406132.927],"after":[102406133.292],"destroy":102406133.409},{"asyncId":647,"parentAsyncId":644,"triggerAsyncId":644,"executionAsyncId":644,"init":102406133.469,"before":[102406133.637],"after":[102406133.886],"destroy":102406134.008},{"asyncId":653,"parentAsyncId":650,"triggerAsyncId":650,"executionAsyncId":650,"init":102406134.07,"before":[102406134.271],"after":[102406134.517],"destroy":102406134.623},{"asyncId":659,"parentAsyncId":656,"triggerAsyncId":656,"executionAsyncId":656,"init":102406134.666,"before":[102406134.827],"after":[102406137.374],"destroy":102406142.512},{"asyncId":902,"parentAsyncId":899,"triggerAsyncId":899,"executionAsyncId":899,"init":102406890.775,"before":[102406890.989],"after":[102406891.262],"destroy":102406891.389},{"asyncId":908,"parentAsyncId":905,"triggerAsyncId":905,"executionAsyncId":905,"init":102406891.431,"before":[102406891.628],"after":[102406891.888],"destroy":102406892.027},{"asyncId":914,"parentAsyncId":911,"triggerAsyncId":911,"executionAsyncId":911,"init":102406892.071,"before":[102406892.251],"after":[102406893.906],"destroy":102406894.033},{"asyncId":920,"parentAsyncId":917,"triggerAsyncId":917,"executionAsyncId":917,"init":102406894.083,"before":[102406894.246],"after":[102406896.359],"destroy":102406900.138},{"asyncId":1158,"parentAsyncId":1155,"triggerAsyncId":1155,"executionAsyncId":1155,"init":102407678.422,"before":[102407678.562],"after":[102407678.763],"destroy":102407678.871},{"asyncId":1164,"parentAsyncId":1161,"triggerAsyncId":1161,"executionAsyncId":1161,"init":102407678.927,"before":[102407679.336],"after":[102407679.578],"destroy":102407679.693},{"asyncId":1170,"parentAsyncId":1167,"triggerAsyncId":1167,"executionAsyncId":1167,"init":102407679.749,"before":[102407679.916],"after":[102407680.126],"destroy":102407680.227},{"asyncId":1176,"parentAsyncId":1173,"triggerAsyncId":1173,"executionAsyncId":1173,"init":102407680.265,"before":[102407680.406],"after":[102407682.654],"destroy":102407685.742},{"asyncId":1419,"parentAsyncId":1416,"triggerAsyncId":1416,"executionAsyncId":1416,"init":102408432.213,"before":[102408432.369],"after":[102408432.597],"destroy":102408432.697},{"asyncId":1425,"parentAsyncId":1422,"triggerAsyncId":1422,"executionAsyncId":1422,"init":102408432.737,"before":[102408432.888],"after":[102408433.112],"destroy":102408433.209},{"asyncId":1431,"parentAsyncId":1428,"triggerAsyncId":1428,"executionAsyncId":1428,"init":102408433.25,"before":[102408433.404],"after":[102408433.627],"destroy":102408433.732},{"asyncId":1437,"parentAsyncId":1434,"triggerAsyncId":1434,"executionAsyncId":1434,"init":102408433.784,"before":[102408433.938],"after":[102408436.12],"destroy":102408439.699},{"asyncId":1680,"parentAsyncId":1677,"triggerAsyncId":1677,"executionAsyncId":1677,"init":102409190.788,"before":[102409191.039],"after":[102409191.41],"destroy":102409191.559},{"asyncId":1686,"parentAsyncId":1683,"triggerAsyncId":1683,"executionAsyncId":1683,"init":102409191.612,"before":[102409192.086],"after":[102409192.471],"destroy":102409192.603},{"asyncId":1692,"parentAsyncId":1689,"triggerAsyncId":1689,"executionAsyncId":1689,"init":102409192.644,"before":[102409192.811],"after":[102409193.041],"destroy":102409193.148},{"asyncId":1698,"parentAsyncId":1695,"triggerAsyncId":1695,"executionAsyncId":1695,"init":102409193.189,"before":[102409193.35],"after":[102409195.63],"destroy":102409199.445},{"asyncId":299,"parentAsyncId":296,"triggerAsyncId":296,"executionAsyncId":296,"init":102405332.5,"before":[102405332.669],"after":[102405332.899],"destroy":102405333.012},{"asyncId":305,"parentAsyncId":302,"triggerAsyncId":302,"executionAsyncId":302,"init":102405333.052,"before":[102405333.212],"after":[102405333.439],"destroy":102405333.55},{"asyncId":311,"parentAsyncId":308,"triggerAsyncId":308,"executionAsyncId":308,"init":102405333.59,"before":[102405333.745],"after":[102405333.979],"destroy":102405334.09},{"asyncId":317,"parentAsyncId":314,"triggerAsyncId":314,"executionAsyncId":314,"init":102405334.13,"before":[102405334.285],"after":[102405339.716],"destroy":102405344.695},{"asyncId":561,"parentAsyncId":558,"triggerAsyncId":558,"executionAsyncId":558,"init":102406117.888,"before":[102406118.153],"after":[102406118.456],"destroy":102406118.569},{"asyncId":567,"parentAsyncId":564,"triggerAsyncId":564,"executionAsyncId":564,"init":102406118.62,"before":[102406118.79],"after":[102406119.212],"destroy":102406119.364},{"asyncId":573,"parentAsyncId":570,"triggerAsyncId":570,"executionAsyncId":570,"init":102406119.437,"before":[102406119.636],"after":[102406119.897],"destroy":102406120.016},{"asyncId":579,"parentAsyncId":576,"triggerAsyncId":576,"executionAsyncId":576,"init":102406120.059,"before":[102406120.235],"after":[102406123.362],"destroy":102406127.334},{"asyncId":822,"parentAsyncId":819,"triggerAsyncId":819,"executionAsyncId":819,"init":102406870.316,"before":[102406870.499],"after":[102406870.726],"destroy":102406870.837},{"asyncId":828,"parentAsyncId":825,"triggerAsyncId":825,"executionAsyncId":825,"init":102406870.877,"before":[102406871.035],"after":[102406871.262],"destroy":102406871.375},{"asyncId":834,"parentAsyncId":831,"triggerAsyncId":831,"executionAsyncId":831,"init":102406871.415,"before":[102406871.572],"after":[102406871.799],"destroy":102406871.897},{"asyncId":840,"parentAsyncId":837,"triggerAsyncId":837,"executionAsyncId":837,"init":102406871.934,"before":[102406872.088],"after":[102406874.814],"destroy":102406878.38},{"asyncId":1083,"parentAsyncId":1080,"triggerAsyncId":1080,"executionAsyncId":1080,"init":102407646.019,"before":[102407646.159],"after":[102407646.362],"destroy":102407646.47},{"asyncId":1089,"parentAsyncId":1086,"triggerAsyncId":1086,"executionAsyncId":1086,"init":102407646.516,"before":[102407646.656],"after":[102407646.857],"destroy":102407646.963},{"asyncId":1095,"parentAsyncId":1092,"triggerAsyncId":1092,"executionAsyncId":1092,"init":102407647.002,"before":[102407647.14],"after":[102407647.341],"destroy":102407647.456},{"asyncId":1101,"parentAsyncId":1098,"triggerAsyncId":1098,"executionAsyncId":1098,"init":102407647.515,"before":[102407647.728],"after":[102407649.525],"destroy":102407652.778},{"asyncId":1344,"parentAsyncId":1341,"triggerAsyncId":1341,"executionAsyncId":1341,"init":102408392.259,"before":[102408392.401],"after":[102408392.605],"destroy":102408392.715},{"asyncId":1350,"parentAsyncId":1347,"triggerAsyncId":1347,"executionAsyncId":1347,"init":102408392.755,"before":[102408392.911],"after":[102408393.721],"destroy":102408393.86},{"asyncId":1356,"parentAsyncId":1353,"triggerAsyncId":1353,"executionAsyncId":1353,"init":102408393.917,"before":[102408394.148],"after":[102408394.498],"destroy":102408394.644},{"asyncId":1362,"parentAsyncId":1359,"triggerAsyncId":1359,"executionAsyncId":1359,"init":102408394.698,"before":[102408394.929],"after":[102408397.219],"destroy":102408400.796},{"asyncId":1600,"parentAsyncId":1597,"triggerAsyncId":1597,"executionAsyncId":1597,"init":102409137.351,"before":[102409137.51],"after":[102409137.736],"destroy":102409137.841},{"asyncId":1606,"parentAsyncId":1603,"triggerAsyncId":1603,"executionAsyncId":1603,"init":102409137.877,"before":[102409138.039],"after":[102409138.269],"destroy":102409138.368},{"asyncId":1612,"parentAsyncId":1609,"triggerAsyncId":1609,"executionAsyncId":1609,"init":102409138.404,"before":[102409138.56],"after":[102409138.782],"destroy":102409138.88},{"asyncId":1618,"parentAsyncId":1615,"triggerAsyncId":1615,"executionAsyncId":1615,"init":102409138.916,"before":[102409139.284],"after":[102409142.169],"destroy":102409145.606}]}]},
{"clusterId":23,"parentClusterId":20,"name":"nextTick","children":[],"nodes":[{"aggregateId":60,"parentAggregateId":49,"name":null,"children":[68,69,70],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"resume","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":815,"columnNumber":13},{"functionName":"Readable.resume","typeName":"IncomingMessage","fileName":"_stream_readable.js","lineNumber":807,"columnNumber":5},{"functionName":"_dump","typeName":"IncomingMessage","fileName":"_http_incoming.js","lineNumber":319,"columnNumber":10},{"functionName":"resOnFinish","isToplevel":true,"fileName":"_http_server.js","lineNumber":534,"columnNumber":9},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":106,"columnNumber":13},{"functionName":"emit","typeName":"ServerResponse","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"onFinish","isToplevel":true,"fileName":"_http_outgoing.js","lineNumber":720,"columnNumber":10},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":405,"parentAsyncId":401,"triggerAsyncId":401,"executionAsyncId":401,"init":102405369.366,"before":[102405370.021],"after":[102405370.701],"destroy":102405375.489},{"asyncId":666,"parentAsyncId":662,"triggerAsyncId":662,"executionAsyncId":662,"init":102406137.435,"before":[102406137.829],"after":[102406138.24],"destroy":102406142.574},{"asyncId":927,"parentAsyncId":923,"triggerAsyncId":923,"executionAsyncId":923,"init":102406896.418,"before":[102406896.825],"after":[102406897.236],"destroy":102406900.201},{"asyncId":1187,"parentAsyncId":1183,"triggerAsyncId":1183,"executionAsyncId":1183,"init":102407682.735,"before":[102407683.085],"after":[102407683.415],"destroy":102407685.825},{"asyncId":1444,"parentAsyncId":1440,"triggerAsyncId":1440,"executionAsyncId":1440,"init":102408436.179,"before":[102408436.557],"after":[102408436.928],"destroy":102408439.763},{"asyncId":1705,"parentAsyncId":1701,"triggerAsyncId":1701,"executionAsyncId":1701,"init":102409195.705,"before":[102409196.087],"after":[102409196.461],"destroy":102409199.489},{"asyncId":328,"parentAsyncId":324,"triggerAsyncId":324,"executionAsyncId":324,"init":102405340.039,"before":[102405341.133],"after":[102405341.932],"destroy":102405345.333},{"asyncId":590,"parentAsyncId":586,"triggerAsyncId":586,"executionAsyncId":586,"init":102406123.453,"before":[102406123.868],"after":[102406124.273],"destroy":102406127.395},{"asyncId":851,"parentAsyncId":847,"triggerAsyncId":847,"executionAsyncId":847,"init":102406874.896,"before":[102406875.272],"after":[102406875.673],"destroy":102406878.461},{"asyncId":1108,"parentAsyncId":1104,"triggerAsyncId":1104,"executionAsyncId":1104,"init":102407649.581,"before":[102407649.925],"after":[102407650.264],"destroy":102407652.841},{"asyncId":1369,"parentAsyncId":1365,"triggerAsyncId":1365,"executionAsyncId":1365,"init":102408397.28,"before":[102408397.663],"after":[102408398.058],"destroy":102408400.865},{"asyncId":1629,"parentAsyncId":1625,"triggerAsyncId":1625,"executionAsyncId":1625,"init":102409142.252,"before":[102409142.64],"after":[102409143.018],"destroy":102409145.699}]},{"aggregateId":68,"parentAggregateId":60,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"endReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":1055,"columnNumber":13},{"functionName":"Readable.read","typeName":"IncomingMessage","fileName":"_stream_readable.js","lineNumber":393,"columnNumber":7},{"functionName":"read","typeName":"IncomingMessage","fileName":"_http_incoming.js","lineNumber":96,"columnNumber":15},{"functionName":"resume_","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":822,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":410,"parentAsyncId":405,"triggerAsyncId":405,"executionAsyncId":405,"init":102405370.054,"before":[102405370.773],"after":[102405370.791],"destroy":102405375.52},{"asyncId":671,"parentAsyncId":666,"triggerAsyncId":666,"executionAsyncId":666,"init":102406137.842,"before":[102406138.303],"after":[102406138.31],"destroy":102406142.604},{"asyncId":932,"parentAsyncId":927,"triggerAsyncId":927,"executionAsyncId":927,"init":102406896.837,"before":[102406897.315],"after":[102406897.326],"destroy":102406900.231},{"asyncId":1192,"parentAsyncId":1187,"triggerAsyncId":1187,"executionAsyncId":1187,"init":102407683.097,"before":[102407683.465],"after":[102407683.473],"destroy":102407685.857},{"asyncId":1449,"parentAsyncId":1444,"triggerAsyncId":1444,"executionAsyncId":1444,"init":102408436.57,"before":[102408436.978],"after":[102408436.985],"destroy":102408439.795},{"asyncId":1710,"parentAsyncId":1705,"triggerAsyncId":1705,"executionAsyncId":1705,"init":102409196.099,"before":[102409196.511],"after":[102409196.518],"destroy":102409199.509},{"asyncId":335,"parentAsyncId":328,"triggerAsyncId":328,"executionAsyncId":328,"init":102405341.297,"before":[102405342.005],"after":[102405342.055],"destroy":102405345.377},{"asyncId":595,"parentAsyncId":590,"triggerAsyncId":590,"executionAsyncId":590,"init":102406123.882,"before":[102406124.327],"after":[102406124.335],"destroy":102406127.417},{"asyncId":856,"parentAsyncId":851,"triggerAsyncId":851,"executionAsyncId":851,"init":102406875.285,"before":[102406875.724],"after":[102406875.731],"destroy":102406878.493},{"asyncId":1113,"parentAsyncId":1108,"triggerAsyncId":1108,"executionAsyncId":1108,"init":102407649.937,"before":[102407650.32],"after":[102407650.328],"destroy":102407652.878},{"asyncId":1374,"parentAsyncId":1369,"triggerAsyncId":1369,"executionAsyncId":1369,"init":102408397.676,"before":[102408398.108],"after":[102408398.115],"destroy":102408400.895},{"asyncId":1634,"parentAsyncId":1629,"triggerAsyncId":1629,"executionAsyncId":1629,"init":102409142.652,"before":[102409143.072],"after":[102409143.079],"destroy":102409145.73}]},{"aggregateId":69,"parentAggregateId":60,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"endReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":1055,"columnNumber":13},{"functionName":"Readable.read","typeName":"IncomingMessage","fileName":"_stream_readable.js","lineNumber":393,"columnNumber":7},{"functionName":"flow","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":846,"columnNumber":34},{"functionName":"resume_","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":828,"columnNumber":3},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":412,"parentAsyncId":405,"triggerAsyncId":405,"executionAsyncId":405,"init":102405370.271,"before":[102405370.826],"after":[102405370.835],"destroy":102405375.536},{"asyncId":673,"parentAsyncId":666,"triggerAsyncId":666,"executionAsyncId":666,"init":102406137.977,"before":[102406138.334],"after":[102406138.341],"destroy":102406142.619},{"asyncId":934,"parentAsyncId":927,"triggerAsyncId":927,"executionAsyncId":927,"init":102406897.003,"before":[102406897.35],"after":[102406897.356],"destroy":102406900.246},{"asyncId":1194,"parentAsyncId":1187,"triggerAsyncId":1187,"executionAsyncId":1187,"init":102407683.211,"before":[102407683.493],"after":[102407683.499],"destroy":102407685.874},{"asyncId":1451,"parentAsyncId":1444,"triggerAsyncId":1444,"executionAsyncId":1444,"init":102408436.698,"before":[102408437.005],"after":[102408437.012],"destroy":102408439.81},{"asyncId":1712,"parentAsyncId":1705,"triggerAsyncId":1705,"executionAsyncId":1705,"init":102409196.232,"before":[102409196.537],"after":[102409196.543],"destroy":102409199.519},{"asyncId":337,"parentAsyncId":328,"triggerAsyncId":328,"executionAsyncId":328,"init":102405341.547,"before":[102405342.08],"after":[102405342.089],"destroy":102405345.394},{"asyncId":597,"parentAsyncId":590,"triggerAsyncId":590,"executionAsyncId":590,"init":102406124.021,"before":[102406124.357],"after":[102406124.363],"destroy":102406127.433},{"asyncId":858,"parentAsyncId":851,"triggerAsyncId":851,"executionAsyncId":851,"init":102406875.416,"before":[102406875.752],"after":[102406875.758],"destroy":102406878.508},{"asyncId":1115,"parentAsyncId":1108,"triggerAsyncId":1108,"executionAsyncId":1108,"init":102407650.052,"before":[102407650.348],"after":[102407650.354],"destroy":102407652.893},{"asyncId":1376,"parentAsyncId":1369,"triggerAsyncId":1369,"executionAsyncId":1369,"init":102408397.825,"before":[102408398.135],"after":[102408398.141],"destroy":102408400.911},{"asyncId":1636,"parentAsyncId":1629,"triggerAsyncId":1629,"executionAsyncId":1629,"init":102409142.784,"before":[102409143.099],"after":[102409143.105],"destroy":102409145.745}]},{"aggregateId":70,"parentAggregateId":60,"name":null,"children":[],"mark":["nodecore",null,null],"type":"TickObject","frames":[{"functionName":"nextTick","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":270,"columnNumber":7},{"functionName":"endReadable","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":1055,"columnNumber":13},{"functionName":"Readable.read","typeName":"IncomingMessage","fileName":"_stream_readable.js","lineNumber":393,"columnNumber":7},{"functionName":"resume_","isToplevel":true,"fileName":"_stream_readable.js","lineNumber":830,"columnNumber":12},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":138,"columnNumber":11},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":414,"parentAsyncId":405,"triggerAsyncId":405,"executionAsyncId":405,"init":102405370.497,"before":[102405370.865],"after":[102405370.874],"destroy":102405375.552},{"asyncId":675,"parentAsyncId":666,"triggerAsyncId":666,"executionAsyncId":666,"init":102406138.113,"before":[102406138.362],"after":[102406138.368],"destroy":102406142.634},{"asyncId":936,"parentAsyncId":927,"triggerAsyncId":927,"executionAsyncId":927,"init":102406897.127,"before":[102406897.377],"after":[102406897.383],"destroy":102406900.261},{"asyncId":1196,"parentAsyncId":1187,"triggerAsyncId":1187,"executionAsyncId":1187,"init":102407683.318,"before":[102407683.519],"after":[102407683.525],"destroy":102407685.889},{"asyncId":1453,"parentAsyncId":1444,"triggerAsyncId":1444,"executionAsyncId":1444,"init":102408436.819,"before":[102408437.032],"after":[102408437.038],"destroy":102408439.825},{"asyncId":1714,"parentAsyncId":1705,"triggerAsyncId":1705,"executionAsyncId":1705,"init":102409196.354,"before":[102409196.563],"after":[102409196.569],"destroy":102409199.529},{"asyncId":339,"parentAsyncId":328,"triggerAsyncId":328,"executionAsyncId":328,"init":102405341.743,"before":[102405342.11],"after":[102405342.116],"destroy":102405345.41},{"asyncId":599,"parentAsyncId":590,"triggerAsyncId":590,"executionAsyncId":590,"init":102406124.155,"before":[102406124.384],"after":[102406124.39],"destroy":102406127.457},{"asyncId":860,"parentAsyncId":851,"triggerAsyncId":851,"executionAsyncId":851,"init":102406875.535,"before":[102406875.777],"after":[102406875.783],"destroy":102406878.522},{"asyncId":1117,"parentAsyncId":1108,"triggerAsyncId":1108,"executionAsyncId":1108,"init":102407650.159,"before":[102407650.374],"after":[102407650.38],"destroy":102407652.907},{"asyncId":1378,"parentAsyncId":1369,"triggerAsyncId":1369,"executionAsyncId":1369,"init":102408397.948,"before":[102408398.161],"after":[102408398.167],"destroy":102408400.927},{"asyncId":1638,"parentAsyncId":1629,"triggerAsyncId":1629,"executionAsyncId":1629,"init":102409142.905,"before":[102409143.124],"after":[102409143.13],"destroy":102409145.76}]}]},
{"clusterId":24,"parentClusterId":20,"name":"timeout","children":[],"nodes":[{"aggregateId":61,"parentAggregateId":49,"name":null,"children":[],"mark":["nodecore",null,null],"type":"Timeout","frames":[{"functionName":"insert","isToplevel":true,"fileName":"timers.js","lineNumber":187,"columnNumber":7},{"functionName":"exports._unrefActive","typeName":"Object","fileName":"timers.js","lineNumber":158,"columnNumber":3},{"functionName":"Socket.setTimeout","typeName":"Socket","fileName":"net.js","lineNumber":389,"columnNumber":12},{"functionName":"resOnFinish","isToplevel":true,"fileName":"_http_server.js","lineNumber":547,"columnNumber":14},{"functionName":"emitNone","isToplevel":true,"fileName":"events.js","lineNumber":106,"columnNumber":13},{"functionName":"emit","typeName":"ServerResponse","fileName":"events.js","lineNumber":208,"columnNumber":7},{"functionName":"onFinish","isToplevel":true,"fileName":"_http_outgoing.js","lineNumber":720,"columnNumber":10},{"functionName":"_combinedTickCallback","isToplevel":true,"fileName":"internal/process/next_tick.js","lineNumber":131,"columnNumber":7},{"functionName":"_tickCallback","typeName":"process","fileName":"internal/process/next_tick.js","lineNumber":180,"columnNumber":9}],"sources":[{"asyncId":408,"parentAsyncId":401,"triggerAsyncId":401,"executionAsyncId":401,"init":102405369.693,"before":[],"after":[],"destroy":102405375.568},{"asyncId":669,"parentAsyncId":662,"triggerAsyncId":662,"executionAsyncId":662,"init":102406137.625,"before":[],"after":[],"destroy":102406142.65},{"asyncId":930,"parentAsyncId":923,"triggerAsyncId":923,"executionAsyncId":923,"init":102406896.621,"before":[],"after":[],"destroy":102406900.276},{"asyncId":1190,"parentAsyncId":1183,"triggerAsyncId":1183,"executionAsyncId":1183,"init":102407682.907,"before":[],"after":[],"destroy":102407685.905},{"asyncId":1447,"parentAsyncId":1440,"triggerAsyncId":1440,"executionAsyncId":1440,"init":102408436.357,"before":[],"after":[],"destroy":102408439.841},{"asyncId":1708,"parentAsyncId":1701,"triggerAsyncId":1701,"executionAsyncId":1701,"init":102409195.891,"before":[],"after":[],"destroy":102409199.54},{"asyncId":333,"parentAsyncId":324,"triggerAsyncId":324,"executionAsyncId":324,"init":102405340.819,"before":[],"after":[],"destroy":102405345.428},{"asyncId":593,"parentAsyncId":586,"triggerAsyncId":586,"executionAsyncId":586,"init":102406123.652,"before":[],"after":[],"destroy":102406127.472},{"asyncId":854,"parentAsyncId":847,"triggerAsyncId":847,"executionAsyncId":847,"init":102406875.08,"before":[],"after":[],"destroy":102406878.543},{"asyncId":1111,"parentAsyncId":1104,"triggerAsyncId":1104,"executionAsyncId":1104,"init":102407649.739,"before":[],"after":[],"destroy":102407652.923},{"asyncId":1372,"parentAsyncId":1365,"triggerAsyncId":1365,"executionAsyncId":1365,"init":102408397.464,"before":[],"after":[],"destroy":102408400.942},{"asyncId":1632,"parentAsyncId":1625,"triggerAsyncId":1625,"executionAsyncId":1625,"init":102409142.443,"before":[],"after":[],"destroy":102409145.775}]}]}
]

},{}],2:[function(require,module,exports){
'use strict'

// The callback functions represented by a sourceNode's unique async_id
// may be called any number of times. To calculate delays and busy time
// we need to look at each call to these callbacks, relative to its source
class CallbackEvent {
  constructor (callKey, source) {
    // Timestamp when this became the next call to this callback
    this.delayStart = callKey === 0 ? source.init : Math.max(source.before[callKey - 1], source.after[callKey - 1])

    // In rare cases, possibly due to a bug in streams or event tracing, .before timestamps may be greater
    // than .after timestamps. If this happens, sort them, warn the user, and provide debug data
    this.inverted = source.before[callKey] > source.after[callKey] ? { beforeAfterKey: callKey, sourceNode: source } : false

    // Timestamp when this callback call begins
    this.before = source[this.inverted ? 'after' : 'before'][callKey]

    // Timestamp when this callback call completes
    this.after = source[this.inverted ? 'before' : 'after'][callKey]

    this.aggregateNode = source.aggregateNode

    if (source.dataSet.settings.debugMode) {
      this.callKey = callKey
      this.sourceNode = source
    }
  }
}

// These temporary arrays of all CallbackEvents in a DataSet are to be used to calculate stats, then deleted / garbage collected
class AllCallbackEvents {
  constructor (wallTime) {
    this.array = []
    this.wallTime = wallTime // Reference to DataSet.wallTime object
    this.inversionCases = []
  }

  add (callbackEvent) {
    this.array.push(callbackEvent)
    if (!this.wallTime.profileStart || callbackEvent.delayStart < this.wallTime.profileStart) this.wallTime.profileStart = callbackEvent.delayStart
    if (!this.wallTime.profileEnd || callbackEvent.after > this.wallTime.profileEnd) this.wallTime.profileEnd = callbackEvent.after

    if (callbackEvent.inverted) this.inversionCases.push(callbackEvent.inverted)
  }

  applyWallTimes (callbackEvent) {
    const { delayStart, before, after } = callbackEvent

    const asyncSegments = this.wallTime.getSegments(delayStart, before)
    const syncSegments = this.wallTime.getSegments(before, after)

    // Browserified short-ish (few hundred) loops, within very long loop. Order isn't important.
    // For efficiency, use for (var), only check length once, no variables in block, send to ordinary function
    var i
    for (i = asyncSegments.length - 1; i >= 0; i--) {
      setToWallTimeSegment(callbackEvent, asyncSegments[i].asyncPending)
    }

    for (i = syncSegments.length - 1; i >= 0; i--) {
      setToWallTimeSegment(callbackEvent, syncSegments[i].syncActive)
    }
  }

  processAll () {
    if (this.inversionCases.length) console.warn('Profile contains callbackEvents with .before timestamp(s) greater than the corresponding .after timestamp:', this.inversionCases)

    this.wallTime.profileDuration = this.wallTime.profileEnd - this.wallTime.profileStart
    this.wallTime.msPerSlice = this.wallTime.profileDuration / this.wallTime.slicesCount

    const clusterStats = new Map()
    const aggregateStats = new Map()

    this.array.sort((a, b) => b.before - a.before)

    // Optimised for browsers because it runs once for every callback event in the profile
    for (var i = this.array.length - 1; i >= 0; i--) {
      this.applyWallTimes(this.array[i])
      processCallbackEvent(this.array[i], clusterStats, aggregateStats)
    }

    clusterStats.forEach(item => item.applyIntervalsTotals())
    aggregateStats.forEach(item => item.applyIntervalsTotals())
  }
}

class TemporaryStatsItem {
  constructor (node) {
    this.intervals = {
      overall: new FlattenedIntervals(),
      sync: new FlattenedIntervals(),
      async: {
        between: new FlattenedIntervals(),
        within: new FlattenedIntervals()
      }
    }
    this.rawTotals = {
      sync: 0,
      async: {
        between: 0,
        within: 0
      }
    }
    this.node = node
  }
  applyIntervalsTotals () {
    this.node.stats.rawTotals = this.rawTotals

    this.node.stats.setOverall(this.intervals.overall.getFlattenedTotal())
    this.node.stats.setSync(this.intervals.sync.getFlattenedTotal())
    this.node.stats.async.setBetween(this.intervals.async.between.getFlattenedTotal())
    this.node.stats.async.setWithin(this.intervals.async.within.getFlattenedTotal())
    this.intervals = null
  }
}

class FlattenedIntervals {
  constructor () {
    this.array = []
  }
  pushAndFlatten (interval) {
    // Clone interval data to mutate it without cross-referencing between cluster and aggregate
    const newInterval = new Interval(interval.start, interval.end, interval.isBetween)

    // If we've already found intervals for this node, walk backwards through them...
    for (var i = this.array.length - 1; i >= 0; i--) {
      // ...flattening against this new one as we go, until we hit a gap
      if (!flattenInterval(this.array, i, newInterval)) break
    }
    this.array.push(newInterval)
  }
  getFlattenedTotal () {
    let total = 0
    for (var i = this.array.length - 1; i >= 0; i--) {
      total += this.array[i].getDuration()
    }
    return total
  }
}

class Interval {
  constructor (start, end, isBetween) {
    this.start = start
    this.end = end
    this.isBetween = isBetween
  }
  getClusterDataType () {
    return this.isBetween ? 'between' : 'within'
  }
  getDuration () {
    return this.end - this.start
  }
  applyAsync (clusterStatsItem, aggregateStatsItem) {
    clusterStatsItem.rawTotals.async[this.getClusterDataType()] += this.getDuration()
    aggregateStatsItem.rawTotals.async.between += this.getDuration()

    clusterStatsItem.intervals.async[this.getClusterDataType()].pushAndFlatten(this)
    aggregateStatsItem.intervals.async.between.pushAndFlatten(this)

    clusterStatsItem.intervals.overall.pushAndFlatten(this)
    aggregateStatsItem.intervals.overall.pushAndFlatten(this)
  }
  applySync (clusterStatsItem, aggregateStatsItem) {
    clusterStatsItem.rawTotals.sync += this.getDuration()
    aggregateStatsItem.rawTotals.sync += this.getDuration()

    clusterStatsItem.intervals.sync.pushAndFlatten(this)
    aggregateStatsItem.intervals.sync.pushAndFlatten(this)

    clusterStatsItem.intervals.overall.pushAndFlatten(this)
    aggregateStatsItem.intervals.overall.pushAndFlatten(this)
  }
}

function setToWallTimeSegment (callbackEvent, segmentData) {
  // Number of callbackEvents at a point in time will be the same as the number of asyncIds
  // because by definition there can't be two callbackEvents of the same asyncId at the same time
  segmentData.callbackCount++

  const aggregateId = callbackEvent.aggregateNode.aggregateId
  if (segmentData.byAggregateId[aggregateId]) {
    segmentData.byAggregateId[aggregateId]++
  } else {
    segmentData.byAggregateId[aggregateId] = 1
  }

  const typeCategory = callbackEvent.aggregateNode.typeCategory
  if (segmentData.byTypeCategory[typeCategory]) {
    segmentData.byTypeCategory[typeCategory]++
  } else {
    segmentData.byTypeCategory[typeCategory] = 1
  }
}

function processCallbackEvent (callbackEvent, clusterStats, aggregateStats) {
  const { delayStart, before, after, aggregateNode } = callbackEvent
  const { aggregateId, isBetweenClusters, clusterNode } = aggregateNode

  if (!aggregateStats.has(aggregateId)) aggregateStats.set(aggregateId, new TemporaryStatsItem(aggregateNode))
  const aggregateStatsItem = aggregateStats.get(aggregateId)

  const clusterId = clusterNode.id
  if (!clusterStats.has(clusterId)) clusterStats.set(clusterId, new TemporaryStatsItem(clusterNode))
  const clusterStatsItem = clusterStats.get(clusterId)

  const asyncInterval = new Interval(delayStart, before, isBetweenClusters)
  asyncInterval.applyAsync(clusterStatsItem, aggregateStatsItem, isBetweenClusters)

  const syncInterval = new Interval(before, after, isBetweenClusters)
  syncInterval.applySync(clusterStatsItem, aggregateStatsItem, isBetweenClusters)
}

function flattenInterval (intervalsArray, i, newInterval) {
  const earlierInterval = intervalsArray[i]

  if (newInterval.start < earlierInterval.end) {
    intervalsArray.pop()
    newInterval.start = Math.min(earlierInterval.start, newInterval.start)
    newInterval.end = Math.max(earlierInterval.end, newInterval.end)
    return true
  }
  // Can't be any more after this point, so break the for loop
  return false
}

module.exports = {
  CallbackEvent,
  AllCallbackEvents
}

},{}],3:[function(require,module,exports){
'use strict'

const Frame = require('./frame.js')
const { CallbackEvent } = require('./callback-event.js')
const {
  validateNumber,
  isNumber
} = require('../validation.js')

class DataNode {
  constructor (dataSet) {
    // Reference to settings on data map
    this.settings = dataSet.settings
    this.dataSet = dataSet

    const node = this
    this.stats = {
      // For nodes whose sourceNodes contain no callbackEvents (.before and .after arrays are empty), these
      // stats are not set, so default 0 values are accessed. Such cases are rare but valid, e.g. root
      // TODO: give examples of some of the async_hook types that often have no callbackEvents.

      overall: 0,
      setOverall (num) { node.stats.overall = node.validateStat(num, 'stats.overall') },

      sync: 0,
      setSync (num) { node.stats.sync = node.validateStat(num, 'stats.sync') },

      async: {
        between: 0,
        setBetween (num) { node.stats.async.between = node.validateStat(num, 'stats.async.between') },

        within: 0,
        setWithin (num) { node.stats.async.within = node.validateStat(num, 'stats.async.within') }
      },

      rawTotals: {
        sync: 0,
        async: {
          between: 0,
          within: 0
        }
      }
    }
  }
  getWithinTime () { return this.stats.sync + this.stats.async.within }
  getBetweenTime () { return this.stats.async.between }
  getAsyncTime () { return this.stats.async.between + this.stats.async.within }
  getSyncTime () { return this.stats.sync }

  getParentNode () {
    return this.dataSet.getByNodeType(this.constructor.name, this.parentId)
  }

  getSameType (nodeId) {
    return this.dataSet.getByNodeType(this.constructor.name, nodeId)
  }

  validateStat (num, statType = '', conditions) {
    const targetDescription = `For ${this.constructor.name} ${this.id}${statType ? ` ${statType}` : ''}`
    return validateNumber(num, targetDescription, conditions)
  }

  static markFromArray (markArray) {
    if (markArray instanceof Map) return markArray
    // node.mark is always an array of length 3, based on this schema:
    const markKeys = ['party', 'module', 'name']
    // 'party' (as in 'third-party') will be one of 'user', 'external' or 'nodecore'.
    // 'module' and 'name' will be null unless frames met conditions in /analysis/aggregate
    const mark = new Map(markArray.map((value, i) => [markKeys[i], value]))
    // for example, 'nodecore.net.onconnection', or 'module.somemodule', or 'user'
    mark.string = markArray.reduce((string, value) => string + (value ? '.' + value : ''))
    return mark
  }
}

class ClusterNode extends DataNode {
  constructor (rawNode, dataSet) {
    super(dataSet)

    const defaultProperties = {
      clusterId: 0,
      parentClusterId: null,
      children: [],
      name: 'miscellaneous',
      mark: null,
      isRoot: false,
      nodes: []
    }
    const node = Object.assign(defaultProperties, rawNode)

    this.isRoot = (node.isRoot || node.clusterId === 1)

    this.clusterId = node.clusterId
    this.uid = 'C' + node.clusterId
    this.parentClusterId = node.parentClusterId
    this.name = node.name

    this.children = node.children

    // These contain decimals referring to the portion of a clusterNode's delay attributable to some label
    this.decimals = {
      type: {between: new Map(), within: new Map()}, // Node async_hook types: 'HTTPPARSER', 'TickObject'...
      // TODO: subTypeCategories stats
      typeCategory: {between: new Map(), within: new Map()}, // Defined in .getAsyncTypeCategories() below
      party: {between: new Map(), within: new Map()} // From .mark - 'user', 'module' or 'nodecore'
    }

    this.nodes = new Map()

    const mark = node.mark || (node.nodes.length ? node.nodes[0].mark : null)
    this.mark = mark ? DataNode.markFromArray(mark) : null
  }
  generateAggregateNodes (nodes) {
    // TODO: if this is done out of sequence, it causes a 1d segment not found error in layout/node-allocation
    // on opening some nodes (usually root node). Should ideally not rely on map order: investigate
    const nodesLength = nodes.length
    for (var i = 0; i < nodesLength; i++) {
      const aggregateNode = new AggregateNode(nodes[i], this)
      aggregateNode.generateSourceNodes(nodes[i].sources)
      this.nodes.set(aggregateNode.aggregateId, aggregateNode)
    }
    this.setDecimal(this.getBetweenTime(), 'party', 'between', this.mark.get('party'))
    this.setDecimal(this.getWithinTime(), 'party', 'within', this.mark.get('party'))
  }
  setDecimal (num, classification, position, label) {
    const decimalsMap = this.decimals[classification][position]
    const newValue = decimalsMap.has(label) ? decimalsMap.get(label) + num : num
    decimalsMap.set(label, this.validateStat(newValue))
  }
  getDecimal (classification, position, label) {
    const raw = this.stats.rawTotals
    const rawTotal = position === 'within' ? raw.async.within + raw.sync : raw.async.between

    const statType = `decimals.${classification}.${position}->${label}`
    const num = this.decimals[classification][position].get(label)

    const decimal = (num === 0 || rawTotal === 0) ? 0 : this.validateStat(num / rawTotal, statType)
    return decimal
  }
  getDecimalLabels (classification, position) {
    return this.decimals[classification][position].keys()
  }
  getDecimalsArray (classification, position) {
    const decimalsArray = []
    for (const label of this.decimals[classification][position].keys()) {
      const decimal = this.getDecimal(classification, position, label)
      decimalsArray.push([label, decimal])
    }
    return decimalsArray
  }
  get id () {
    return this.clusterId
  }
  get parentId () {
    return this.parentClusterId
  }
}

class AggregateNode extends DataNode {
  constructor (rawNode, clusterNode) {
    super(clusterNode.dataSet)

    const defaultProperties = {
      aggregateId: 0,
      parentAggregateId: null,
      children: [],
      frames: [],
      type: 'none',
      mark: ['nodecore', null, null],
      isRoot: false,
      sources: []
    }
    const node = Object.assign(defaultProperties, rawNode)

    this.isRoot = (node.isRoot || node.aggregateId === 1)

    this.aggregateId = node.aggregateId
    this.uid = 'A' + node.aggregateId
    this.parentAggregateId = node.parentAggregateId
    this.children = node.children
    this.clusterNode = clusterNode

    this.isBetweenClusters = clusterNode.parentClusterId && clusterNode.getParentNode().nodes.has(node.parentAggregateId)

    this.frames = node.frames.map((frame) => {
      const frameItem = new Frame(frame)
      const frameWrapper = { data: frameItem }
      frameWrapper.name = frameItem.getName()
      frameWrapper.formatted = frameItem.getFormatted(frameWrapper.name)
      return frameWrapper
    })
    this.name = rawNode.name || (this.frames.length ? this.frames[0].name : (this.isRoot ? 'root' : 'empty frames'))

    this.mark = DataNode.markFromArray(node.mark)
    this.party = this.mark.get('party')

    // Node's async_hook types - see https://nodejs.org/api/async_hooks.html#async_hooks_type
    // 29 possible values defined in node core, plus other user-defined values can exist
    this.type = node.type
    const [typeCategory, typeSubCategory] = AggregateNode.getAsyncTypeCategories(this.type)
    this.typeCategory = typeCategory
    this.typeSubCategory = typeSubCategory

    this.dataSet.aggregateNodes.set(this.aggregateId, this)
  }
  generateSourceNodes (sources) {
    const debugMode = this.dataSet.settings.debugMode

    // This loop runs thousands+ times, unbounded and scales with size of profile. Optimize for browsers
    const sourcesLength = sources.length
    // Only store sourceNodes in debugMode, otherwise extract their callbackEvents and discard
    if (debugMode) this.sources = new Array(sourcesLength)

    for (var i = 0; i < sourcesLength; i++) {
      const sourceNode = new SourceNode(sources[i], this)
      sourceNode.generateCallbackEvents()
      if (debugMode) this.sources[i] = sourceNode
    }
    if (debugMode) this.dataSet.sourceNodes = this.dataSet.sourceNodes.concat(this.sources)
  }
  applyDecimalsToCluster () {
    const apply = (time, betweenOrWithin) => {
      this.clusterNode.setDecimal(time, 'type', betweenOrWithin, this.type)
      this.clusterNode.setDecimal(time, 'typeCategory', betweenOrWithin, this.typeCategory)
      this.clusterNode.setDecimal(time, 'party', betweenOrWithin, this.mark.get('party'))
    }

    if (this.isBetweenClusters) {
      apply(this.stats.rawTotals.async.between, 'between')
      apply(this.stats.rawTotals.sync, 'within')
    } else {
      apply(this.stats.rawTotals.async.between + this.stats.rawTotals.sync, 'within')
    }
  }
  getDecimalsArray (classification, position) {
    return [[this[classification], 1]]
  }
  get id () {
    return this.aggregateId
  }
  get parentId () {
    return this.parentAggregateId
  }
  static getAsyncTypeCategories (typeName) {
  // Combines node's async_hook types into sets of more user-friendly thematic categories
  // Based on https://gist.github.com/mafintosh/e31eb1d61f126de019cc10344bdbb62b
    switch (typeName) {
      case 'FSEVENTWRAP':
      case 'FSREQWRAP':
      case 'STATWATCHER':
        return ['files-streams', 'fs']
      case 'JSSTREAM':
      case 'WRITEWRAP':
      case 'SHUTDOWNWRAP':
        return ['files-streams', 'streams']
      case 'ZLIB':
        return ['files-streams', 'zlib']

      case 'HTTPPARSER':
      case 'PIPECONNECTWRAP':
      case 'PIPEWRAP':
      case 'TCPCONNECTWRAP':
      case 'TCPSERVER':
      case 'TCPWRAP':
      case 'TCPSERVERWRAP':
        return ['networks', 'networking']
      case 'UDPSENDWRAP':
      case 'UDPWRAP':
        return ['networks', 'network']
      case 'GETADDRINFOREQWRAP':
      case 'GETNAMEINFOREQWRAP':
      case 'QUERYWRAP':
        return ['networks', 'dns']

      case 'PBKDF2REQUEST':
      case 'RANDOMBYTESREQUEST':
      case 'TLSWRAP':
      case 'SSLCONNECTION':
        return ['crypto', 'crypto']

      case 'TIMERWRAP':
      case 'Timeout':
      case 'Immediate':
      case 'TickObject':
        return ['timing-promises', 'timers-and-ticks']
      case 'PROMISE':
        return ['timing-promises', 'promises']

      case 'PROCESSWRAP':
      case 'TTYWRAP':
      case 'SIGNALWRAP':
        return ['other', 'process']
      case 'none':
        return ['other', 'root']
      default:
        return ['other', 'user-defined']
    }
  }
}

class SourceNode {
  constructor (rawSource, aggregateNode) {
    this.dataSet = aggregateNode.dataSet
    this.dataSet.sourceNodesCount++

    const defaultProperties = {
      asyncId: 0,
      parentAsyncId: null,
      children: [],
      init: null,
      before: [],
      after: [],
      destroy: null
    }
    const source = Object.assign(defaultProperties, rawSource)

    this.asyncId = source.asyncId
    this.parentAsyncId = source.parentAsyncId
    this.triggerAsyncId = source.parentAsyncId
    this.executionAsyncId = source.parentAsyncId

    this.init = source.init // numeric timestamp

    // In rare cases, possibly due to a bug in streams or event tracing, arrays of .before and .after
    // times are out of sequence. If this happens, sort them, warn the user, and provide debug data
    const scrambledOrder = source.before.some((value, index) => index && value < source.before[index - 1])

    this.before = scrambledOrder ? source.before.sort() : source.before // array of numeric timestamps
    this.after = scrambledOrder ? source.after.sort() : source.after // array of numeric timestamps
    this.destroy = source.destroy // numeric timestamp

    if (scrambledOrder) console.warn('The following async ID source data contained out-of-sequence .before and .after timestamps:', source)

    this.aggregateNode = aggregateNode
  }
  generateCallbackEvents () {
    // Skip unusual cases of a broken asyncId with no init time (e.g. some root nodes)
    if (!isNumber(this.init)) return this

    // This loop runs thousands+++ of times, unbounded and scales with size of profile. Optimize for browsers
    const callbackEventCount = this.before.length
    for (var i = 0; i < callbackEventCount; i++) {
      // Skip incomplete items, e.g. bad application exits leaving a .before with no corresponding .after
      if (isNumber(this.after[i])) this.dataSet.callbackEvents.add(new CallbackEvent(i, this))
    }
    return this
  }
  get id () {
    return this.asyncId
  }
}

// ArticificalNodes are created in /layout/ for layout-specific combinations or modified versions of nodes
class ArtificialNode extends ClusterNode {
  constructor (rawNode, nodeToCopy, contents) {
    const nodeProperties = Object.assign({}, nodeToCopy, rawNode, {
      clusterId: rawNode.id || nodeToCopy.id,
      parentClusterId: rawNode.parentId || nodeToCopy.parentId,
      nodes: []
    })
    super(nodeProperties, nodeToCopy.dataSet)

    const defaultProperties = {
      nodeType: 'AggregateNode'
    }
    const node = Object.assign(defaultProperties, rawNode)
    if (nodeToCopy.clusterNode) {
      this.clusterNode = nodeToCopy.clusterNode
    }

    this.nodeType = node.nodeType
    this.uid = rawNode.id
    this.contents = contents
  }
  applyAggregateNodes (nodes) {
    if (!nodes.size) return

    for (const [aggregateId, aggregateNode] of nodes) {
      this.nodes.set(aggregateId, aggregateNode)
      if (!this.mark) this.mark = aggregateNode.mark
    }
  }
  applyMark (mark) {
    if (!this.mark) this.mark = mark
  }
  getSameType (nodeId) {
    return this.dataSet.getByNodeType(this.nodeType, nodeId)
  }
  aggregateStats (dataNode) {
    this.stats.setOverall(this.stats.overall + dataNode.stats.overall)
    this.stats.setSync(this.stats.sync + dataNode.stats.sync)
    this.stats.async.setWithin(this.stats.async.within + dataNode.stats.async.within)
    this.stats.async.setBetween(this.stats.async.between + dataNode.stats.async.between)

    this.stats.rawTotals.sync += dataNode.stats.rawTotals.sync
    this.stats.rawTotals.async.between += dataNode.stats.rawTotals.async.between
    this.stats.rawTotals.async.within += dataNode.stats.rawTotals.async.within
  }
  aggregateDecimals (dataNode, classification, position) {
    if (dataNode.decimals) {
      // e.g. combining clusterNodes
      const byLabel = dataNode.decimals[classification][position]
      for (const [label, value] of byLabel) {
        this.setDecimal(value, classification, position, label)
      }
    } else {
      // e.g. combining aggregateNodes
      const label = dataNode[classification]
      const rawTotals = dataNode.stats.rawTotals
      const value = rawTotals.async[position] + (position === 'within' ? rawTotals.sync : 0)
      this.setDecimal(value, classification, position, label)
    }
  }
}

class ShortcutNode extends ArtificialNode {
  constructor (rawNode, nodeToCopy) {
    super(rawNode, nodeToCopy)
    this.shortcutTo = nodeToCopy
  }
}

module.exports = {
  ShortcutNode,
  ArtificialNode,
  ClusterNode,
  AggregateNode,
  SourceNode,
  DataNode
}

},{"../validation.js":34,"./callback-event.js":2,"./frame.js":5}],4:[function(require,module,exports){
'use strict'

const { AllCallbackEvents } = require('./callback-event.js')
const { validateKey } = require('../validation.js')
const { ClusterNode } = require('./data-node.js')

class DataSet {
  constructor (data, settings = {}) {
    if (!data.map) {
      throw new Error(`No valid data found, data.json is typeof ${typeof data}`)
    }

    const defaultSettings = {
      debugMode: false, // if true, keeps sourceNodes in memory and exposes dataSet and Layout to window
      wallTimeSlices: 400
    }

    settings = Object.assign(defaultSettings, settings)
    this.settings = settings

    this.wallTime = new WallTime(this.settings.wallTimeSlices)

    // Array of CallbackEvents is temporary for calculating stats on other nodes
    this.callbackEvents = new AllCallbackEvents(this.wallTime) // CallbackEvents are created and pushed within SourceNode constructor
    this.callbackEventsCount = 0

    // Source, Aggregate and Cluster Node maps persist in memory throughout
    this.sourceNodesCount = 0
    if (this.settings.debugMode) this.sourceNodes = [] // SourceNodes are created from and pushed to this array in AggregateNode constructor
    this.aggregateNodes = new Map() // AggregateNodes are created from ClusterNode constructor and set in their own constructor
    this.clusterNodes = new Map()

    for (const node of data) {
      const clusterNode = new ClusterNode(node, this)
      this.clusterNodes.set(node.clusterId, clusterNode)
      clusterNode.generateAggregateNodes(node.nodes)
    }
  }
  processData () {
    this.calculateFlattenedStats()
    this.calculateDecimals()
    this.wallTime.processSlices()
  }
  getByNodeType (nodeType, nodeId) {
    const typeKeyMapping = {
      AggregateNode: 'aggregateNodes',
      ClusterNode: 'clusterNodes'
    }
    validateKey(nodeType, Object.keys(typeKeyMapping))
    return this[typeKeyMapping[nodeType]].get(nodeId)
  }
  calculateFlattenedStats () {
    this.callbackEvents.processAll()
    this.callbackEventsCount = this.callbackEvents.array.length
    this.callbackEvents = null
  }
  calculateDecimals () {
    this.aggregateNodes.forEach(aggregateNode => aggregateNode.applyDecimalsToCluster())
  }
}

class WallTime {
  constructor (slicesCount) {
    // Creates array of wall time slices, based on typical width of the chart they're to be drawn in, to be scalable
    this.slicesCount = slicesCount
    this.slices = Array.from({length: this.slicesCount}, () => createWallTimeSlice())

    // Set in callback-event.js AllCallbackEvents.add()
    this.profileStart = 0 // Timestamp of first .init
    this.profileEnd = 0 // Timestamp of last .after

    // Set in callback-event.js AllCallbackEvents.processAll()
    this.profileDuration = null // Number of miliseconds from profileStart to profileEnd
    this.msPerSlice = null // profileDuration / slicesCount, number of miliseconds spanned by each item in slices array

    this.maxAsyncPending = 0
    this.maxSyncActive = 0
    this.categoriesOrdered = []
  }

  getSegments (startTime, endTime, discardFirst = false) {
    const {
      profileStart,
      profileEnd,
      msPerSlice,
      slices
    } = this

    // Don't allow seemingly valid non-failing output from logically invalid input
    if (startTime < profileStart) throw new Error(`Wall time segment start time (${startTime}) precedes profile start time (${profileStart})`)
    if (endTime > profileEnd) throw new Error(`Wall time segment end time (${endTime}) exceeds profile end time (${profileEnd})`)
    if (startTime > endTime) {
      throw new Error(`Wall time segment start time (${startTime}) doesn’t precede segment end time (${endTime})`)
    }

    const startIndex = Math.floor((startTime - profileStart) / msPerSlice)
    const endIndex = Math.ceil((endTime - profileStart) / msPerSlice)
    const segments = slices.slice(startIndex, endIndex)

    // The last item in getSegments(x, y) is always the same as the first in getSegments(y, z)
    // so use discardFirst when needed to avoid duplication in adjacent segments
    return discardFirst ? segments.slice(1) : segments
  }

  processSlices () {
    const maxAsyncByCategory = {}

    for (var i = 0; i < this.slicesCount; i++) {
      const slice = this.slices[i]
      if (slice.syncActive.callbackCount > this.maxSyncActive) this.maxSyncActive = slice.syncActive.callbackCount
      if (slice.asyncPending.callbackCount > this.maxAsyncPending) this.maxAsyncPending = slice.asyncPending.callbackCount

      // Define maxAsyncByCategory[typeCategory] for each type category present and set it to the highest value
      for (const [typeCategory, value] of Object.entries(slice.asyncPending.byTypeCategory)) {
        if (!maxAsyncByCategory[typeCategory] || value > maxAsyncByCategory[typeCategory]) maxAsyncByCategory[typeCategory] = value
      }
    }

    // Sort so the category with the tallest spike of pending events is first
    this.categoriesOrdered = Object.keys(maxAsyncByCategory).sort((a, b) => {
      return maxAsyncByCategory[b] - maxAsyncByCategory[a]
    })
  }
}

function createWallTimeSlice () {
  // Refers to 1% of the time the profile was running for
  return {
    syncActive: createSubSlice(),
    asyncPending: createSubSlice()
  }
}

function createSubSlice () {
  return {
    byAggregateId: {},
    callbackCount: 0,
    byTypeCategory: {}
  }
}

module.exports = DataSet

},{"../validation.js":34,"./callback-event.js":2,"./data-node.js":3}],5:[function(require,module,exports){
'use strict'

class Frame {
  constructor (frame) {
    this.functionName = frame.functionName
    this.typeName = frame.typeName
    this.evalOrigin = frame.evalOrigin
    this.fileName = frame.fileName
    this.lineNumber = frame.lineNumber
    this.columnNumber = frame.columnNumber
    this.isEval = frame.isEval
    this.isConstructor = frame.isConstructor
    this.isNative = frame.isNative
    this.isToplevel = frame.isToplevel
    this.party = this.getFrameParty(this.fileName)
  }

  getName () {
    let name = this.functionName ? this.functionName : '<anonymous>'
    if (this.isEval) {
      // no change
    } else if (this.isToplevel) {
      // no change
    } else if (this.isConstructor) {
      name = 'new ' + name
    } else if (this.isNative) {
      name = 'native ' + name
    } else {
      name = this.typeName + '.' + name
    }
    return name
  }

  getFormatted (name) {
    let formatted = '    at ' + name
    if (this.isEval) {
      formatted += ' ' + this.evalOrigin
    } else {
      formatted += ' ' + this.fileName
      formatted += ':' + (this.lineNumber > 0 ? this.lineNumber : '')
      formatted += (this.columnNumber > 0 ? ':' + this.columnNumber : '')
    }
    return formatted
  }

  // TODO: move this logic to analysis, add property there, then trim file paths
  getFrameParty (fileName) {
    if (!fileName) return ['empty', 'no file']

    // If first character is / or it's a letter followed by :\
    if (fileName.charAt(0) === '.' || fileName.charAt(0) === '/' || fileName.match(/^[a-zA-Z]:\\/)) {
      // ...then this is a Unix or Windows style local file path

      if (fileName.match(/(?:\\|\/)node_modules(?:\\|\/)/)) {
        const directories = fileName.split(/\\|\//)
        const moduleName = directories[directories.lastIndexOf('node_modules') + 1]
        return ['external', `module ${moduleName}`]
      }
      return ['user', 'your application']
    }
    return ['nodecore', 'node core']
  }
}

module.exports = Frame

},{}],6:[function(require,module,exports){
'use strict'

const data = require('../data.json') // base64 encoded source file

const DataSet = require('./dataset.js')

// 'json = data' optional arg allows json to be passed in for browserless tests
function loadData (settings = {}, json = data) {
  const dataSet = new DataSet(json, settings)
  dataSet.processData()
  return dataSet
}

module.exports = loadData

},{"../data.json":1,"./dataset.js":4}],7:[function(require,module,exports){
'use strict'

const HtmlContent = require('./html-content.js')

class BreadcrumbPanel extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, contentProperties)

    this.originalUI = contentProperties.originalUI
    this.topmostUI = contentProperties.originalUI
    contentProperties.originalUI.on('setTopmostUI', (newTopmostUI) => {
      this.topmostUI = newTopmostUI
      this.draw()
    })

    document.addEventListener('keydown', (e) => {
      if (e.keyCode === 27 && this.topmostUI !== this.originalUI) {
        // ESC button
        if (this.topmostUI.selectedDataNode) {
          return this.topmostUI.clearFrames()
        }
        const lastUI = this.topmostUI
        const targetUI = this.topmostUI.clearSublayout()
        this.originalUI.emit('navigation', { from: lastUI, to: targetUI })
      }
    })
  }

  initializeElements () {
    super.initializeElements()
    this.d3Element.classed('panel', true)
    this.d3Element.classed('breadcrumbs-panel', true)
  }

  draw () {
    super.draw()

    this.d3Element.selectAll('label').remove()

    let ui = this.topmostUI
    while (ui) {
      this.addLabel(ui)
      ui = ui.parentUI
    }
  }

  addLabel (ui) {
    const fullLabelText = ui.name || 'Main View'
    const labelText = trimToNearestSpace(fullLabelText)
    this.d3Element
      .insert('label', ':first-child') // i.e. prepend instead of append
      .classed('breadcrumb', true)
      .property('textContent', labelText)
      .property('title', fullLabelText)
      .on('click', () => {
        this.traverseUp(ui)
      })

    if (ui !== this.originalUI) {
      this.d3Element
        .insert('label', ':first-child') // i.e. prepend instead of append
        .classed('breadcrumb-separator', true)
        .property('textContent', '➥')
    }
  }
  traverseUp (targetUI) {
    if (this.topmostUI !== targetUI) {
      const lastUI = this.topmostUI
      let currentUI = this.topmostUI
      while (currentUI && currentUI !== targetUI) {
        currentUI = currentUI.clearSublayout()
      }
      this.originalUI.emit('navigation', { from: lastUI, to: targetUI })
    }
  }
}

// Attempts to aesthetically limit string length
// Initially it breaks string into words (space split)
// Then it tries to detect a natural break that's not far from the max (15 +/- 3)
// And prioritize such break over a hard cut, if available
function trimToNearestSpace (str) {
  const trimThreshold = 15
  if (str.length < trimThreshold) return str
  const acceptableStretch = 3
  let trimmed = ''
  for (const word of str.split(' ')) {
    const combined = trimmed + ' ' + word
    if (combined.length > trimThreshold + acceptableStretch) {
      const previousSpaceAvailable = trimmed.length > trimThreshold - acceptableStretch && trimmed.length <= trimThreshold
      const resolved = previousSpaceAvailable ? trimmed : combined.slice(0, trimThreshold + 1)
      trimmed = resolved
      break
    }
    trimmed = combined
  }
  trimmed = trimmed.trim() // drop excess spaces
  return trimmed + '…'
}

module.exports = BreadcrumbPanel

},{"./html-content.js":13}],8:[function(require,module,exports){
'use strict'

const d3 = require('./d3-subset.js')
const debounce = require('lodash/debounce')
const EventEmitter = require('events')
const htmlContentTypes = require('./html-content-types.js')
const Layout = require('../layout/layout.js')
const { validateKey } = require('../validation.js')

const history = []

class BubbleprofUI extends EventEmitter {
  constructor (sections = [], settings = {}, appendTo, parentUI = null) {
    super()

    const defaultSettings = {
      numberFormatter: d3.format(',.0f'),
      strokePadding: 10,
      nodeLinkId: 'node-link',
      classNames: '',
      viewMode: 'fit'
    }

    this.settings = Object.assign({}, defaultSettings, settings)
    this.mainContainer = {}
    this.layoutNode = null // Is assigned if this is a sublayout with .layoutNode

    function getOriginalUI (parentUI) {
      return parentUI.parentUI ? getOriginalUI(parentUI.parentUI) : parentUI
    }
    this.parentUI = parentUI
    this.originalUI = parentUI ? getOriginalUI(parentUI) : this

    this.highlightedNode = null
    this.selectedDataNode = null
    this.name = this.parentUI && this.parentUI.selectedDataNode.name
    this.name = this.name || 'Main view'
    this.name = this.name.split(' ').filter(str => !str.includes('/') && !str.includes(':')).join(' ')

    // Main divisions of the page
    this.sections = new Map()

    for (const sectionName of sections) {
      this.sections.set(sectionName, new htmlContentTypes.HtmlContent(appendTo, {
        htmlElementType: 'section',
        id: sectionName,
        classNames: this.settings.classNames
      }, this))
    }

    if (this.originalUI === this) {
      const nodeLinkSection = this.getNodeLinkSection()
      this.backBtn = nodeLinkSection.addContent(undefined, { classNames: 'back-btn' })
      history.push(this)
      this.on('navigation', ({ to }) => {
        history.push(to)
        this.backBtn.d3Element.classed('hidden', history.length < 2)
      })
    }
  }

  getContentClass (className) {
    validateKey(className, Object.keys(htmlContentTypes))
    return htmlContentTypes[className]
  }

  getNodeLinkSection () {
    return this.sections.get(this.settings.nodeLinkId)
  }

  getSettingsForLayout () {
    const settings = {}
    switch (this.settings.viewMode) {
      case 'fit':
      case 'maximised':
        const boundingBox = this.originalUI.getNodeLinkSection().d3Element.node().getBoundingClientRect()
        settings.svgHeight = boundingBox.height
        settings.svgWidth = boundingBox.width
        settings.allowStretch = false
        break
      case 'scroll':
      default:
        settings.allowStretch = true
        break
    }

    if (this.layout) {
      settings.collapseNodes = this.layout.settings.collapseNodes
    }
    return settings
  }

  createSubLayout (layoutNode) {
    const sublayout = this.layout.createSubLayout(layoutNode, this.getSettingsForLayout())
    if (sublayout) {
      sublayout.generate()
      const nodeLinkSection = this.originalUI.getNodeLinkSection()

      const nodeLinkId = 'node-link-' + layoutNode.id
      const uiWithinSublayout = new BubbleprofUI([nodeLinkId], {
        nodeLinkId,
        classNames: 'sublayout'
      }, nodeLinkSection, this)
      uiWithinSublayout.layoutNode = layoutNode

      const sublayoutHtml = uiWithinSublayout.sections.get(nodeLinkId)
      sublayoutHtml.addCollapseControl()
      const closeBtn = sublayoutHtml.addContent(undefined, { classNames: 'close-btn' })

      const sublayoutSvg = sublayoutHtml.addContent('SvgContainer', {id: 'sublayout-svg', svgBounds: {}})
      sublayoutHtml.addContent('HoverBox', {svg: sublayoutSvg})

      uiWithinSublayout.initializeElements()

      uiWithinSublayout.initializeCloseButton(closeBtn)

      uiWithinSublayout.setData(sublayout)
      uiWithinSublayout.setAsTopmostUI()
      return uiWithinSublayout
    }
    return this
  }

  // Close button returns to the originalUI
  initializeCloseButton (closeBtn) {
    closeBtn.d3Element
      .property('textContent', '×')
      .on('click', () => {
        let targetUI = this
        while (targetUI.layoutNode) {
          targetUI = targetUI.clearSublayout()
        }
        if (targetUI !== this.ui) {
          this.originalUI.emit('navigation', { from: this, to: targetUI })
        }
      })
  }

  // Back button goes back in user navigation one step at a time
  // This does not record opening frames
  // This does record pressing ESC and close button
  initializeBackButton () {
    const { backBtn, originalUI } = this
    backBtn.d3Element
      .classed('hidden', true)
      .on('click', stepBack)

    document.addEventListener('keydown', (e) => {
      if (e.keyCode === 8 && e.target.nodeName.toLowerCase() !== 'input') {
        // Backspace button
        stepBack()
      }
    })

    let topMostUI = this
    this.on('setTopmostUI', (newTopmostUI) => {
      topMostUI = newTopmostUI
    })

    function stepBack () {
      if (history.length < 2) {
        return
      }
      if (topMostUI.selectedDataNode) {
        return topMostUI.clearFrames()
      }
      history.pop()
      const lastUI = history[history.length - 1]
      const lastLayoutNode = lastUI.layoutNode
      backBtn.d3Element.classed('hidden', history.length < 2)

      if (lastUI === originalUI) {
        while (topMostUI.layoutNode) {
          topMostUI = topMostUI.clearSublayout()
        }
        return
      }

      return topMostUI.jumpToNode(lastLayoutNode.node)
    }
  }

  formatNumber (num) {
    return num < 1 ? '<1' : this.settings.numberFormatter(num)
  }

  // Selects a node visible within current layout
  selectNode (layoutNode) {
    const dataNode = layoutNode.node
    const sameNode = this.selectedDataNode && this.selectedDataNode.uid === dataNode.uid

    switch (dataNode.constructor.name) {
      case 'ShortcutNode':
        const uiParent = this.clearSublayout() // Go up a level as shortcuts always point outside the node
        const targetDataNode = dataNode.targetLayoutNode ? dataNode.targetLayoutNode.node : dataNode.shortcutTo
        return uiParent.jumpToNode(targetDataNode)

      case 'AggregateNode':
        this.selectedDataNode = dataNode
        this.outputFrames(dataNode, layoutNode)
        window.location.hash = 'a' + dataNode.aggregateId
        return this

      case 'ClusterNode':
        window.location.hash = 'c' + dataNode.clusterId
        if (dataNode.nodes.size === 1) {
          // If there's only one aggregateNode, just select it
          this.selectedDataNode = dataNode.nodes.values().next().value
          this.outputFrames(this.selectedDataNode, layoutNode)
          return this
        } else {
          this.selectedDataNode = dataNode
          return sameNode ? this : this.createSubLayout(layoutNode)
        }

      case 'ArtificialNode':
        this.selectedDataNode = dataNode
        const uiWithinCollapsedNode = sameNode ? this : this.createSubLayout(layoutNode)
        window.location.hash = this.generateCollapsedNodeHash(uiWithinCollapsedNode)
        return uiWithinCollapsedNode
    }
  }

  generateCollapsedNodeHash (uiWithinCollapsedNode) {
    let hash = `l${uiWithinCollapsedNode.layoutNode.id}|`
    const appendParentNode = (parentUI) => {
      if (!parentUI.layoutNode) {
        hash += 'm'
      } else {
        const dataNode = parentUI.layoutNode.node
        switch (dataNode.constructor.name) {
          case 'ClusterNode':
            hash += 'c' + dataNode.clusterId
            break
          case 'ArtificialNode':
            hash += `l${parentUI.layoutNode.id}|`
            appendParentNode(parentUI.parentUI)
            break
        }
      }
    }
    appendParentNode(uiWithinCollapsedNode.parentUI)
    return hash
  }

  parseCollapsedNodeHash () {
    const nodeIds = window.location.hash.slice(1).split('|')
    const lastNodeId = nodeIds.pop()
    let targetUI
    if (lastNodeId === 'm') {
      targetUI = this
    } else {
      const clusterId = parseInt(lastNodeId.slice(1))
      const clusterNode = this.dataSet.clusterNodes.get(clusterId)
      targetUI = this.jumpToNode(clusterNode)
    }

    for (var i = nodeIds.length - 1; i >= 0; i--) {
      const layoutNodeId = nodeIds[i].slice(1)
      const layoutNode = targetUI.layout.layoutNodes.get(layoutNodeId)
      targetUI = targetUI.selectNode(layoutNode)
    }
    this.emit('navigation', { from: this, to: targetUI })
  }

  clearSublayout () {
    this.selectedDataNode = null

    // TODO: check that this frees up this and its layout for GC
    if (this.parentUI) {
      this.getNodeLinkSection().d3Element.remove()
      this.parentUI.selectedDataNode = null
      this.parentUI.setAsTopmostUI()
      if (this.parentUI.layoutNode) {
        const dataNode = this.parentUI.layoutNode.node
        switch (dataNode.constructor.name) {
          case 'ClusterNode':
            window.location.hash = 'c' + dataNode.clusterId
            break
          case 'AggregateNode':
            window.location.hash = 'a' + dataNode.aggregateId
            break
          case 'ArtificialNode':
            window.location.hash = this.generateCollapsedNodeHash(this.parentUI)
            break
        }
      } else {
        window.location.hash = ''
      }
    }

    // Close the frames panel if it's open
    this.clearFrames()

    return this.parentUI
  }

  highlightNode (layoutNode = null, dataNode = null) {
    this.highlightedNode = layoutNode
    this.highlightedDataNode = dataNode
    this.emit('hover', layoutNode)
  }

  // Selects a node that may or may not be collapsed
  jumpToNode (dataNode) {
    if (this.layoutNode && this.layoutNode.node.uid === dataNode.uid) {
      return this
    }
    if (dataNode.clusterNode) {
      return this.jumpToAggregateNode(dataNode)
    }
    this.highlightNode(null)
    const layoutNode = this.layout.findDataNode(dataNode)
    // If we can't find the node in this sublayout, step up one level and try again
    if (!layoutNode) {
      this.clearSublayout()
      return this.parentUI.jumpToNode(dataNode)
    }

    if (layoutNode.node.uid === dataNode.uid) {
      return this.selectNode(layoutNode)
    } else {
      // dataNode is inside one or more levels of collapsedNode - recurse
      const uiWithinCollapsedNode = this.selectNode(layoutNode)
      return uiWithinCollapsedNode.jumpToNode(dataNode)
    }
  }

  // Should not be called directly, only via jumpToNode
  jumpToAggregateNode (aggregateNode) {
    this.highlightNode(null)
    const nodeId = aggregateNode.id
    const layoutNodes = this.layout.layoutNodes
    const layoutNodeInView = layoutNodes.get(nodeId)
    if (layoutNodeInView && layoutNodeInView.node.uid === aggregateNode.uid) {
      return this.selectNode(layoutNodeInView)
    }

    const uiWithinClusterNode = this.jumpToNode(aggregateNode.clusterNode)
    if (aggregateNode.clusterNode.nodes.size === 1) {
      return uiWithinClusterNode
    }
    let currentUI = uiWithinClusterNode
    while (currentUI) {
      const layoutNode = currentUI.layout.findDataNode(aggregateNode)
      if (!layoutNode) {
        const context = [...currentUI.layout.layoutNodes.values()].map(layoutNode => layoutNode.id).join(';')
        const viewUID = `${currentUI.layoutNode && currentUI.layoutNode.node.uid} "${currentUI.name}"`
        const clusterUID = aggregateNode.clusterNode && aggregateNode.clusterNode.uid
        throw new Error(`Could not find aggregate ${aggregateNode.uid} from cluster ${clusterUID} in view ${viewUID} with nodes ${context}`)
      }
      currentUI = currentUI.selectNode(layoutNode)
      if (layoutNode.node.uid === aggregateNode.uid) {
        return currentUI
      }
    }
  }

  outputFrames (aggregateNode, layoutNode = null) {
    if (layoutNode) {
      this.highlightNode(layoutNode)
    }
    this.originalUI.emit('outputFrames', aggregateNode)
  }

  clearFrames () {
    this.selectedDataNode = null
    this.originalUI.emit('outputFrames', null)
  }

  collapseEvent (eventName) {
    // Called when a collapsable with a given collapseEvent name opens, to close all others
    this.emit(`collapse-${eventName}`)
  }

  redrawLayout () {
    const newLayout = new Layout(this.layout.initialInput, this.getSettingsForLayout())
    newLayout.generate()
    this.setData(newLayout)
  }

  truncateLabel (labelString, maxWords, maxChars) {
    const labelWords = labelString.split(' ')
    let truncatedLabel = labelString
    let addEllipsis = false

    if (labelWords.length > maxWords) {
      truncatedLabel = labelWords.slice(0, maxWords).join(' ')
      addEllipsis = true
    }

    if (truncatedLabel.length > maxChars) {
      truncatedLabel = truncatedLabel.slice(0, maxChars - 2)
      addEllipsis = true
    }

    if (addEllipsis) truncatedLabel += '…'

    return truncatedLabel
  }

  // For all UI item instances, keep initial DOM element creation in initializeElements() method
  // so that browser paint etc can happen around the same time, minimising reflows
  initializeElements () {
    const d3Body = d3.select('body')
    const d3Main = d3.select('main')
    d3Body.classed('initialized', true)
    d3Body.attr('data-view-mode', this.settings.viewMode)

    this.mainContainer.d3Element = d3Main.size() ? d3Main : d3Body.append('main')
    this.mainContainer.d3ContentWrapper = this.mainContainer.d3Element

    // TODO: try replacing with .emit('initializeElements')
    for (const section of this.sections.values()) {
      section.initializeElements()
    }

    this.on('highlightType', (className) => {
      d3Body.attr('data-highlight-type', className || null)
    })

    this.on('highlightParty', (className) => {
      d3Body.attr('data-highlight-party', className || null)
    })

    const debounceTime = 300
    const nodeLinkSection = this.getNodeLinkSection()

    const onWindowResizeBegin = debounce(() => {
      nodeLinkSection.d3Element.classed('redraw', true)

      // Use a shorter time period than the trailing debounce to prevent getting stuck
    }, debounceTime * 0.9, { leading: true })

    const onWindowResizeEnd = debounce(() => {
      this.redrawLayout()
      nodeLinkSection.d3Element.classed('redraw', false)
    }, debounceTime)

    window.addEventListener('resize', () => {
      onWindowResizeBegin()
      onWindowResizeEnd()
    })

    if (this.originalUI === this) {
      this.initializeBackButton()
    }
  }

  setData (layout, dataSet) {
    if (layout === this.layout) return
    const initialize = !this.layout

    this.dataSet = dataSet || this.dataSet || this.parentUI.dataSet
    this.layout = layout
    this.emit('setData')

    if (initialize) {
      // Copy layout settings like lineWidth
      Object.assign(this.settings, layout.settings)
      this.emit('initializeFromData')
    }
    this.emit('svgDraw')
  }

  setAsTopmostUI () {
    // Allow user to inspect layout object
    window.layout = this.layout

    // Allow UI components to interact with whichever ui and layout is in focus
    this.originalUI.emit('setTopmostUI', this)
  }

  complete () {
    this.setAsTopmostUI()
    this.emit('complete')

    if (window.location.hash) {
      setTimeout(() => {
        const id = parseInt(window.location.hash.slice(2))
        switch (window.location.hash.charAt(1)) {
          case 'a':
            const aggregateNode = this.dataSet.aggregateNodes.get(id)
            const uiWithinAggregate = this.jumpToNode(aggregateNode)
            this.emit('navigation', { from: this, to: uiWithinAggregate })
            break
          case 'c':
            const clusterNode = this.dataSet.clusterNodes.get(id)
            const uiWithinCluster = this.jumpToNode(clusterNode)
            this.emit('navigation', { from: this, to: uiWithinCluster })
            break
          case 'l':
            this.parseCollapsedNodeHash(window.location.hash)
            break
        }
      })
    }
  }

  // For all UI item instances, keep updates and changes to DOM elements in draw() method
  // so that browser paint etc can happen around the same time, minimising reflows
  draw () {
    // TODO: try replacing with .emit('draw')
    for (const section of this.sections.values()) {
      section.draw()
    }
  }
}
module.exports = BubbleprofUI

},{"../layout/layout.js":27,"../validation.js":34,"./d3-subset.js":9,"./html-content-types.js":12,"events":73,"lodash/debounce":139}],9:[function(require,module,exports){
'use strict'

// During development, use entire D3 library for ease of use
const d3 = require('d3')

/* TODO: on launch, refine down to a subset of d3's microlibraries

// Reduce file size by only including the d3 modules that are used
const d3 = Object.assign(
  require('d3-selection'),
  // Assign all chosen microlibraries to d3-selection to preserve d3.event's live binding
  // see https://github.com/d3/d3/issues/3102
  require('d3-array'),
  require('d3-force'),
  require('d3-hierarchy'),
  require('d3-scale'),
  require('d3-shape'),
  require('d3-time-format')
)

*/

module.exports = d3

},{"d3":72}],10:[function(require,module,exports){
'use strict'

// const d3 = require('./d3-subset.js') // Currently unused but will be used
const HtmlContent = require('./html-content.js')
const arrayFlatten = require('array-flatten')

class Frames extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, contentProperties)
    this.framesByNode = []
    this.topmostUI = null

    this.firstDraw = true

    this.ui.on('setTopmostUI', (topmostUI) => {
      this.topmostUI = topmostUI
    })
  }

  initializeElements () {
    super.initializeElements()

    this.d3Element.classed('frames-container', true)

    this.d3Heading = this.d3ContentWrapper.append('div')
      .classed('heading', true)

    this.ui.on('outputFrames', (aggregateNode) => {
      if (aggregateNode) {
        this.setData(aggregateNode)
      } else {
        this.reset()
      }
    })
  }

  reset () {
    this.node = null
    this.framesByNode = []
    this.parentContent.collapseClose()
  }

  setData (aggregateNode) {
    this.node = aggregateNode
    this.isRoot = aggregateNode.isRoot

    this.framesByNode = []
    groupFrames(this.node, this.framesByNode)
    this.parentContent.collapseOpen()
  }

  draw () {
    super.draw()

    if (this.firstDraw) {
      this.firstDraw = false
      this.parentContent.d3ContentWrapper.insert('span', ':first-child')
        .classed('close', true)
        .on('click', () => {
          this.topmostUI.clearFrames()
          this.parentContent.collapseClose()
        })
    }

    this.d3ContentWrapper.selectAll('.frame-item').remove()
    this.d3ContentWrapper.selectAll('.frame-group').remove()

    if (this.node) {
      this.drawFrames(this.framesByNode, this.d3ContentWrapper)
      this.d3Heading.html(`Showing async stack trace from async operation "<strong>${this.node.name}</strong>"`)
        .on('mouseover', () => {
          const layoutNode = this.topmostUI.layout.findDataNode(this.node)
          this.topmostUI.highlightNode(layoutNode, this.node)
        })
        .on('mouseout', () => {
          this.topmostUI.highlightNode(null)
        })
    } else {
      this.d3Heading.html(`
        Click on a grouping in the diagram above to drill down, and find the call stacks showing the exact lines of code these async operations originated from.
      `)
      this.d3Heading.on('mouseover', null)
      this.d3Heading.on('mouseout', null)
    }
  }

  getDelaysText (aggregateNode) {
    const betweenFigure = this.ui.formatNumber(aggregateNode.getBetweenTime())
    const withinFigure = this.ui.formatNumber(aggregateNode.getWithinTime())
    return `<span class="figure">${betweenFigure} ms</span> in asynchronous delays, <span class="figure">${withinFigure} ms</span> in synchronous delays.`
  }

  drawFrames (frames, d3AppendTo) {
    if (!frames.length) {
      const d3Group = d3AppendTo.append('div')
        .classed('frame-group', true)
        .on('click', () => {
          d3Group.classed('collapsed', !d3Group.classed('collapsed'))
        })

      d3Group.append('div')
        .classed('sub-collapse-control', true)
        .html('<span class="arrow"></span> Empty frames')

      const d3EmptyFrameItem = d3Group.append('div')
        .classed('frame-item', true)

      if (frames.dataNode && frames.dataNode.isRoot) {
        d3EmptyFrameItem.text('This is the root node, representing the starting point of your application. No stack frames are available.')
      } else {
        d3EmptyFrameItem.text('No frames are available for this async operation. It could be from a native module, or something not integrated with the Async Hooks API.')
      }
    }
    for (const frame of frames) {
      if (frame.isGroup) {
        const d3Group = d3AppendTo.append('div')
          .classed('frame-group', true)

        const d3SubCollapseControl = d3Group.append('div')
          .classed('sub-collapse-control', true)

        let header = '<span class="arrow"></span>'
        if (frame.dataNode) {
          const isThisNode = frame.dataNode === this.node

          d3Group
            .classed('node-frame-group', true)
            .classed('collapsed', !isThisNode)
            .classed('this-node', isThisNode)

          if (!isThisNode) {
            d3Group.insert('a', ':first-child')
              .classed('jump-to-node', true)
              .text('Select on diagram')
              .on('mouseover', () => {
                const layoutNode = this.topmostUI.layout.findDataNode(frame.dataNode) || this.topmostUI.layout.rootLayoutNode
                this.topmostUI.highlightNode(layoutNode, frame.dataNode)
              })
              .on('mouseout', () => {
                this.topmostUI.highlightNode(null)
              })
              .on('click', () => {
                const targetUI = this.topmostUI.jumpToNode(frame.dataNode)
                this.topmostUI.originalUI.emit('navigation', { from: this.ui, to: targetUI })
              })
          }

          header += `${arrayFlatten(frame).length} frames from `
          header += `${isThisNode ? 'this async operation' : `previous async operation "${frame.dataNode.name}"`}`
          header += `<div class="delays">${this.getDelaysText(frame.dataNode)}</span>`
        } else if (frame.party) {
          d3Group.classed(frame.party[0], true)
            .classed('collapsed', frame.party[0] !== 'user')
          header += `${frame.length} frame${frame.length === 1 ? '' : 's'} from ${frame.party[1]}`
        }

        d3SubCollapseControl.html(header)
          .on('click', () => {
            d3Group.classed('collapsed', !d3Group.classed('collapsed'))
          })

        this.drawFrames(frame, d3Group)
      } else {
        d3AppendTo.append('pre')
          .html(frame.formatted)
          .classed('frame-item', true)
      }
    }
  }
}

function groupFrames (aggregateNode, framesByNode) {
  let previousFrame
  let previousGroup
  const groupedFrames = []
  groupedFrames.dataNode = aggregateNode
  groupedFrames.isGroup = true

  for (const frame of aggregateNode.frames) {
    const party = frame.data.party
    if (!previousFrame || previousFrame.data.party[1] !== party[1]) {
      const group = [frame]
      group.isGroup = true
      group.party = party
      groupedFrames.push(group)
      previousGroup = group
    } else {
      previousGroup.push(frame)
    }
    previousFrame = frame
  }

  framesByNode.push(groupedFrames)

  // Full async stack trace - recurse through aggregate ancestry to the root aggregate node
  if (aggregateNode.parentId) groupFrames(aggregateNode.getParentNode(), framesByNode)
}

module.exports = Frames

},{"./html-content.js":13,"array-flatten":35}],11:[function(require,module,exports){
'use strict'

const d3 = require('./d3-subset.js')
const HtmlContent = require('./html-content.js')
const { validateKey } = require('../validation.js')

class HoverBox extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, Object.assign({
      type: 'node-link',
      position: { x: 0, y: 0 },
      allowableOverflow: 0,
      fixedOrientation: null
    }, contentProperties))
    validateKey(this.contentProperties.type, ['node-link', 'tool-tip', 'static'])
    if (this.contentProperties.type === 'node-link' && !this.contentProperties.svg) {
      throw new Error('Node-link HoverBox requires contentProperties.svg to be defined')
    }

    this.isHidden = true
  }

  initializeElements () {
    super.initializeElements(true) // Tells super not to add .htmlContent to default position

    this.d3Element.classed('hover-box', true)
    this.d3Element.classed('hidden', true)

    this.d3VerticalArrow = this.d3ContentWrapper.append('div')
      .classed('vertical-arrow', true)

    this.d3TitleBlock = this.d3ContentWrapper.append('div')
      .classed('block', true)
      .classed('title-block', true)
      .html(this.contentProperties.htmlContent || '')

    if (this.contentProperties.type === 'node-link') {
      this.nodeLinkElements()
    }
  }

  nodeLinkElements () {
    this.d3Title = this.d3TitleBlock.append('h2')
    this.d3ClickMessage = this.d3TitleBlock.append('a')
      .classed('click-message', true)

    this.asyncOperationsChart = this.addContent('LineChart', {
      classNames: 'block time-block',
      static: false
    })
    this.asyncOperationsChart.initializeElements()

    this.d3TimeBlock = this.asyncOperationsChart.d3ContentWrapper
    this.d3TimeStatement = this.d3TimeBlock.append('p')

    this.ui.on('hover', layoutNode => {
      if (layoutNode) this.layoutNode = layoutNode
      this.changeVisibility(!!layoutNode)
    })
  }

  nodeLinkPosition (nodePosition) {
    // The SVG element can scale like a responsive image. The HTML hover box doesn't.
    // So, the exact pixel position of the hover box depends on the SVG's current width.
    const svg = this.contentProperties.svg
    const svgContainerBounds = svg.d3Element.node().getBoundingClientRect()
    const responsiveScaleFactor = svgContainerBounds.width / svg.svgBounds.width

    const x = nodePosition.x * responsiveScaleFactor
    const y = nodePosition.y * responsiveScaleFactor
    this.contentProperties.position = { x, y }
    this.position(x, y, svgContainerBounds)
  }

  positionSidewards (x, y, containerBounds, hoverBounds) {
    const horizontalFlip = x + hoverBounds.width > window.innerWidth

    this.d3Element.style('top', y + 'px')
    this.d3Element.style('left', (horizontalFlip ? x - hoverBounds.width : x) + 'px')

    this.d3Element.classed('off-bottom', y + hoverBounds.height > containerBounds.height)
    this.d3Element.classed('horizontal-flip', horizontalFlip)
    this.d3Element.classed('use-vertical-arrow', false)
  }

  position (x, y, containerBounds) {
    const {
      allowableOverflow,
      fixedOrientation
    } = this.contentProperties

    const hoverBounds = this.d3Element.node().getBoundingClientRect()

    const verticalArrowPadding = 12
    const initialTop = y + verticalArrowPadding
    const initialLeft = x - verticalArrowPadding
    const allowableWidth = containerBounds.width + allowableOverflow

    let arrowOffset = verticalArrowPadding
    let adjustedLeft = initialLeft - verticalArrowPadding
    const overflowX = initialLeft + hoverBounds.width - allowableWidth
    if (overflowX > 0) {
      adjustedLeft -= overflowX
      arrowOffset = overflowX + verticalArrowPadding
    }

    let adjustedTop = initialTop
    let verticalFlip = (fixedOrientation === 'up')

    if (!fixedOrientation) {
      const overflowY = initialTop + hoverBounds.height - containerBounds.height
      if (overflowY > 0) {
        const titleBlockHeight = this.d3TitleBlock.node().getBoundingClientRect().height
        adjustedTop -= titleBlockHeight + verticalArrowPadding * 2
        verticalFlip = true
      }
    }

    // On short windows with no space above or below
    if (adjustedTop < 0 && !fixedOrientation) {
      this.positionSidewards(x, y, containerBounds, hoverBounds)
      return
    }

    this.d3Element.style('top', adjustedTop + 'px')
    this.d3Element.style('left', adjustedLeft + 'px')
    this.d3VerticalArrow.style('left', arrowOffset + 'px')

    this.d3Element.classed('off-bottom', verticalFlip)
    this.d3Element.classed('use-vertical-arrow', true)
    this.d3Element.classed('horizontal-flip', false)
  }

  changeVisibility (show) {
    this.isHidden = !show
    if (!show) {
      this.content.forEach(contentItem => {
        if (contentItem.collapseControl && contentItem.collapseControl.collapsedByDefault) {
          contentItem.collapseClose()
        }
      })
    }
    this.draw()
  }

  showContentAt (htmlContent, position) {
    this.contentProperties.htmlContent = htmlContent
    this.showAt(position)
  }

  showAt (position) {
    this.contentProperties.position = position
    this.changeVisibility(true)
  }

  hide () {
    this.changeVisibility(false)
  }

  draw () {
    super.draw()

    if (this.contentProperties.type === 'node-link') {
      if (this.layoutNode) this.nodeLinkDraw(this.layoutNode)
      return
    }

    const { x, y } = this.contentProperties.position
    this.position(x, y, this.parentContent.d3ContentWrapper.node().getBoundingClientRect())

    if (this.contentProperties.type === 'tool-tip') {
      this.d3TitleBlock.html(this.contentProperties.htmlContent || '')
    }

    // Mouseover on the hover box itself causes mouseout of the element that showed the hover box
    // Re-show hover box so mouse/trackpad users can interact with hover content e.g. select text
    // Use mouseenter / mouseleave as mouseover / mouseout re-trigger on mouseover child elements
    this.d3Element.on('mouseenter', () => {
      if (this.isHidden) this.changeVisibility(true)
    })
    this.d3Element.on('mouseleave', () => {
      this.changeVisibility(false)
    })
  }

  nodeLinkDraw (layoutNode) {
    // See comment on equivalent logic in draw ()
    this.d3Element.on('mouseenter', () => {
      if (this.isHidden) this.ui.highlightNode(this.layoutNode)
    })
    this.d3Element.on('mouseleave', () => {
      this.ui.highlightNode(null)
    })

    this.asyncOperationsChart.applyLayoutNode(layoutNode)

    // Ensure off-bottom class is not applied before calculating if it's needed
    this.d3Element.classed('off-bottom', false)

    this.nodeLinkPosition(layoutNode.position)

    const nodeType = layoutNode.node.constructor.name
    const dataNode = nodeType === 'ShortcutNode' ? layoutNode.node.shortcutTo : layoutNode.node

    this.d3Title.text(dataNode.name)

    const percentage = dataNode.stats.overall / this.ui.dataSet.wallTime.profileDuration * 100
    const percentageFormatted = (percentage >= 100 ? '>99' : this.ui.formatNumber(percentage)) + '%'

    this.d3TimeStatement.html(`
      For
      <strong>${this.ui.formatNumber(dataNode.stats.overall)}\u2009ms</strong> (${percentageFormatted} of the profile runtime), async operations were pending from this group.
    `)

    // If a clusterNode only contains one aggregate, no point clicking down into it, just give us the frames
    const isIgnorableCluster = nodeType === 'ClusterNode' && layoutNode.node.nodes.size === 1
    const clickableDataNode = isIgnorableCluster ? layoutNode.node.nodes.values().next().value : layoutNode.node
    const clickableNodeType = clickableDataNode.constructor.name

    switch (clickableNodeType) {
      case 'AggregateNode':
        this.d3ClickMessage.text('Click to display stack trace')
        this.d3Element.attr('name', 'aggregate-node')
        break
      case 'ShortcutNode':
        this.d3ClickMessage.text(`Click to navigate to "${dataNode.name}"`)
        this.d3Element.attr('name', 'shortcut-node')
        break
      case 'ArtificialNode':
      case 'ClusterNode':
        const nodesCount = nodeType === 'ClusterNode' ? dataNode.nodes.size : layoutNode.collapsedNodes.length
        this.d3ClickMessage.text(`Click to expand ${nodesCount} grouped items`)
        this.d3Element.attr('name', 'cluster-node')
        break
    }
    const clickHandler = () => {
      d3.event.stopPropagation()
      this.ui.highlightNode(null)
      const targetUI = this.ui.selectNode(layoutNode)
      if (targetUI !== this.ui) {
        this.ui.originalUI.emit('navigation', { from: this.ui, to: targetUI })
      }
    }
    this.d3TitleBlock.on('click', clickHandler)
    this.d3VerticalArrow.on('click', clickHandler)
  }
}

module.exports = HoverBox

},{"../validation.js":34,"./d3-subset.js":9,"./html-content.js":13}],12:[function(require,module,exports){
'use strict'

// This lookup object of HTML content types is necessary to prevent circular dependencies
// e.g. if an A contains a B which contains an A
module.exports = {
  // Parent class, for generic HTML content with optional collapse, load indicator, etc
  HtmlContent: require('./html-content.js'),

  // Sub classes which extend HtmlContent
  BreadcrumbPanel: require('./breadcrumb-panel.js'),
  Frames: require('./frames.js'),
  HoverBox: require('./hover-box.js'),
  InteractiveKey: require('./interactive-key.js'),
  LineChart: require('./line-chart.js'),
  Lookup: require('./lookup.js'),
  SvgContainer: require('./svg-container.js')
}

},{"./breadcrumb-panel.js":7,"./frames.js":10,"./hover-box.js":11,"./html-content.js":13,"./interactive-key.js":15,"./line-chart.js":16,"./lookup.js":17,"./svg-container.js":19}],13:[function(require,module,exports){
'use strict'

const { uniqueMapKey } = require('../validation.js')

// Base class for HTML content, extended by specific types of UI item
// Only initializeElement() and draw() modify the DOM
class HtmlContent {
  constructor (parentContent, contentProperties = {}, ui = parentContent.ui) {
    this.ui = ui
    this.parentContent = parentContent || this.ui.mainContainer

    const defaultProperties = {
      id: null,
      name: null,
      hidden: false,
      htmlElementType: 'div',
      htmlContent: '',
      classNames: ''
    }
    this.contentProperties = Object.assign(defaultProperties, contentProperties)
    this.isHidden = this.contentProperties.hidden

    this.collapseControl = null
    this.loadingAnimation = null

    this.content = new Map()
    this.contentIds = []
  }

  addContent (className = 'HtmlContent', contentProperties = {}, prepend = false) {
    const ContentClass = this.ui.getContentClass(className)
    const item = new ContentClass(this, contentProperties)

    const identifier = uniqueMapKey(contentProperties.id || ContentClass.name, this.content)

    this.content.set(identifier, item)
    this.contentIds[prepend ? 'unshift' : 'push'](identifier)
    return item
  }

  addCollapseControl (collapsedByDefault = false, contentProperties = {}) {
    this.collapseControl = new CollapseControl(this, contentProperties, collapsedByDefault)
    return this.collapseControl
  }

  collapseOpen () {
    this.collapseChange(false)
  }

  collapseClose () {
    this.collapseChange(true)
  }

  collapseToggle () {
    this.collapseChange()
  }

  collapseChange (closeBool) {
    if (!this.collapseControl) return
    if (typeof closeBool === 'undefined') closeBool = !this.collapseControl.isCollapsed

    // If this is opening and has a collapseEvent, close everything else with same event
    const collapseEvent = this.collapseControl.collapseEvent
    if (!closeBool && collapseEvent) this.ui.collapseEvent(collapseEvent)

    this.collapseControl.isCollapsed = closeBool
    this.draw()
  }

  addLoadingAnimation (contentProperties = {}) {
    this.loadingAnimation = new LoadingAnimation(this, contentProperties)
    return this.loadingAnimation
  }

  // Initial creation of elements independent of data and layout, before .setData() is called
  initializeElements (skipContent = false) {
    const {
      htmlContent,
      htmlElementType,
      id,
      classNames
    } = this.contentProperties

    const d3ParentElement = this.parentContent.d3ContentWrapper

    this.d3Element = d3ParentElement.append(htmlElementType)
    this.d3ContentWrapper = this.d3Element

    if (this.collapseControl) {
      this.collapseControl.initializeElements()
      this.d3ContentWrapper = this.d3Element.append('div')
        .classed('collapsible-content-wrapper', true)

      if (id) this.d3ContentWrapper.attr('id', `${id}-inner`)

      if (this.collapseControl.closeIcon) {
        this.d3ContentWrapper.insert('span', ':first-child')
          .html(this.collapseControl.closeIcon)
          .classed('close', true)
          .classed('portrait-only', this.collapseControl.portraitOnly)
          .on('click', () => this.collapseClose())
      }
    }

    if (this.loadingAnimation) this.loadingAnimation.initializeElements()

    if (id) this.d3Element.attr('id', id)
    if (classNames) this.d3Element.classed(classNames, true)
    if (htmlContent && !skipContent) this.d3ContentWrapper.html(htmlContent)

    for (const id of this.contentIds) {
      this.content.get(id).initializeElements()
    }
  }

  draw () {
    this.d3Element.classed('hidden', this.isHidden)

    if (this.collapseControl) this.collapseControl.draw()
    if (this.loadingAnimation) this.loadingAnimation.draw()

    if (!this.isHidden) {
      for (const item of this.content.values()) {
        item.draw()
      }
    }
  }
}

class CollapseControl extends HtmlContent {
  constructor (parentContent, contentProperties, collapsedByDefault) {
    super(parentContent, contentProperties)

    this.collapsedByDefault = collapsedByDefault
    this.isCollapsed = collapsedByDefault

    this.closeIcon = contentProperties.closeIcon || null
    this.collapseEvent = contentProperties.collapseEvent || null

    this.portraitOnly = contentProperties.portraitOnly || false
    this.collapseClassName = this.portraitOnly ? 'portrait-collapsed' : 'collapsed'
  }
  initializeElements () {
    super.initializeElements()

    this.d3Element.classed('collapse-control', true)
    this.parentContent.d3Element.classed(this.collapseClassName, this.isCollapsed)

    if (this.portraitOnly) this.d3Element.classed('portrait-only', true)

    if (this.collapseEvent) {
      this.ui.on(`collapse-${this.collapseEvent}`, (closeBool) => {
        this.parentContent.collapseClose()
      })
    }

    this.d3Element.on('click', () => {
      this.parentContent.collapseToggle()
    })
  }
  draw () {
    super.draw()
    this.parentContent.d3Element.classed(this.collapseClassName, this.isCollapsed)
  }
}

class LoadingAnimation extends HtmlContent {
  initializeElements () {
    super.initializeElements()
    this.d3Element.classed('loading-indicator', true)

    this.ui.on('complete', () => {
      this.isHidden = true
      this.draw()
    })
  }
}

module.exports = HtmlContent

},{"../validation.js":34}],14:[function(require,module,exports){
'use strict'

const BubbleprofUI = require('./bubbleprof-ui.js')
const staticKeyHtml = require('./static-key.js')

function drawOuterUI () {
  // Initial DOM drawing that is independent of data

  const sections = ['header', 'node-link', 'side-bar', 'footer']
  const ui = new BubbleprofUI(sections)

  // Header
  const header = ui.sections.get('header')
  const highlightBar = header.addContent(undefined, { classNames: 'header-bar highlight-bar' })

  // Analysis code uses term "party" as in "3rd-party", but it may be confusing to users. "Area" is clearer.
  // TODO: repace 'party' with 'area' everywhere in code, including in analysis
  const partyKeyPanel = highlightBar.addContent(undefined, { classNames: 'panel', htmlContent: '<label>Area:</label>' })
  const typeKeyPanel = highlightBar.addContent(undefined, { classNames: 'panel', htmlContent: '<label>Type:</label>' })

  header.addContent(undefined, {
    classNames: 'help-link-block panel',
    // Uncomment this and comment out the other line to test that the animation doesn't play when the page is visited
    // TODO: remove this when https://clinicjs.org is live
    // htmlContent: '<a class="help-link external-link" href="https://www.bbc.com/news" title="Test link to a visitable page"></a>'
    htmlContent: '<a class="help-link external-link" href="https://clinicjs.org/bubbleprof/walkthrough" title="External link to NearForm’s BubbleProf walkthrough"></a>'
  })

  const breadcrumbBar = header.addContent(undefined, { classNames: 'header-bar breadcrumb-bar' })
  breadcrumbBar.addContent('BreadcrumbPanel', { classNames: 'panel', originalUI: ui })
  // TODO: when adding full-screen and light theme
  // const uiButtonsPanel = header.addContent(undefined, { classNames: 'panel' })

  partyKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'user',
    targetType: 'party',
    label: 'Userland',
    hoverText: 'Operations initiated from inside the application being profiled'
  })
  partyKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'external',
    targetType: 'party',
    label: 'Dependencies',
    hoverText: 'Operations initiated from an external module in node_modules'
  })
  partyKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'nodecore',
    targetType: 'party',
    label: 'Node core',
    hoverText: 'Operations initiated from within node.js core only'
  })

  const asyncHooksDocsLink = 'Async Hook types (<a class="external-link" target="_blank" href="https://nodejs.org/api/async_hooks.html#async_hooks_type" title="External link to official Node.js Async Hooks documentation">see docs</a>):'

  typeKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'networks',
    targetType: 'type',
    label: 'Networks',
    hoverText: 'Async operations related to networks, including TCP, UDP and DNS',
    collapsedText: `${asyncHooksDocsLink}
    <ul>
      <li>HTTPPARSER
      <li>PIPECONNECTWRAP
      <li>PIPEWRAP
      <li>TCPCONNECTWRAP
      <li>TCPSERVER
      <li>TCPWRAP
      <li>TCPSERVERWRAP

      <li>UDPSENDWRAP
      <li>UDPWRAP

      <li>GETADDRINFOREQWRAP
      <li>GETNAMEINFOREQWRAP
      <li>QUERYWRAP
    </ul>
    `
  })
  typeKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'files-streams',
    targetType: 'type',
    label: 'Data',
    hoverText: 'Async operations related to the file system (fs) or data streams',
    collapsedText: `${asyncHooksDocsLink}
    <ul>
      <li>FSEVENTWRAP
      <li>FSREQWRAP
      <li>STATWATCHER

      <li>JSSTREAM
      <li>WRITEWRAP
      <li>SHUTDOWNWRAP

      <li>ZLIB
    </ul>
    `
  })
  typeKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'crypto',
    targetType: 'type',
    label: 'Crypto',
    hoverText: 'Async operations related to cryptography and encryption',
    collapsedText: `${asyncHooksDocsLink}
    <ul>
      <li>PBKDF2REQUEST
      <li>RANDOMBYTESREQUEST
      <li>TLSWRAP
      <li>SSLCONNECTION
    </ul>
    `
  })
  typeKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'timing-promises',
    targetType: 'type',
    label: 'Scheduling',
    hoverText: 'Async wrappers, such as timers, ticks and promises, used to schedule arbitrary code',
    collapsedText: `${asyncHooksDocsLink}
    <ul>
      <li>TIMERWRAP
      <li>Timeout
      <li>Immediate
      <li>TickObject
      <li>PROMISE
    </ul>
    `
  })
  typeKeyPanel.addContent('InteractiveKey', {
    relativeContainer: header,
    name: 'other',
    targetType: 'type',
    label: 'Other',
    hoverText: 'Other async operations, including process wrappers and user-defined Async Hooks',
    collapsedText: `${asyncHooksDocsLink}
    <ul>
      <li>PROCESSWRAP
      <li>TTYWRAP
      <li>SIGNALWRAP
      <li>User-defined async hooks
    </ul>
    `
  })

  // Main panel - nodelink diagram
  const nodeLink = ui.sections.get('node-link')
  nodeLink.addLoadingAnimation()

  const nodeLinkSVG = nodeLink.addContent('SvgContainer', {id: 'node-link-svg', svgBounds: {}})

  nodeLink.addContent('HoverBox', {svg: nodeLinkSVG})

  // Sidebar
  const sideBar = ui.sections.get('side-bar')
  sideBar.addCollapseControl(true, {
    htmlContent: '<div class="text">Details</div><div class="arrow"></div>',
    classNames: 'bar',
    closeIcon: '×',
    collapseEvent: 'main-overlay',
    portraitOnly: true
  })

  const lookup = sideBar.addContent('Lookup', {
    classNames: 'side-bar-item',
    defaultText: 'Enter a file or function name'
  })
  lookup.addCollapseControl(true, { htmlContent: 'Search <span class="arrow"></span>' })
  lookup.addLoadingAnimation({ hidden: true })

  const callbacksOverTime = sideBar.addContent('LineChart', {
    classNames: 'side-bar-item'
  })
  callbacksOverTime.addCollapseControl(false, { htmlContent: 'Async operations <span class="arrow"></span>' })

  const key = sideBar.addContent(undefined, {
    classNames: 'main-key side-bar-item',
    htmlContent: staticKeyHtml
  })
  key.addCollapseControl(false, { htmlContent: 'Key <span class="arrow"></span>' })

  /* TODO: Add this when feature is implemented
  sideBar.addContent(undefined, { classNames: 'side-bar-item' })
    .addCollapseControl(true, { htmlContent: 'Stack frames with longest delays <span class="arrow"></span>' })
  */

  // Footer
  const footerCollapseHTML = '<div class="text">Call stacks</div><div class="arrow"></div>'
  const footer = ui.sections.get('footer')
  footer.addCollapseControl(true, {
    htmlContent: footerCollapseHTML,
    classNames: 'bar',
    collapseEvent: 'main-overlay'
  })
  footer.addContent('Frames', { id: 'frames-panel', classNames: 'side-bar-item' })

  // Complete
  ui.initializeElements()

  return ui
}

module.exports = drawOuterUI

},{"./bubbleprof-ui.js":8,"./static-key.js":18}],15:[function(require,module,exports){
'use strict'

// const d3 = require('./d3-subset.js') // Currently unused but will be used
const HtmlContent = require('./html-content.js')

class InteractiveKey extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, contentProperties)

    const {
      hoverText,
      collapsedText,
      relativeContainer
    } = contentProperties

    this.relativeContainer = relativeContainer || this.parentContent

    this.hoverText = hoverText || null
    if (hoverText) this.hoverBox = this.addHoverBox()

    this.collapsedText = collapsedText || null
    if (collapsedText) this.collapsedContent = this.addCollapsedContent(this.hoverBox || this)
  }

  addHoverBox () {
    return this.relativeContainer.addContent('HoverBox', {
      type: 'static',
      htmlContent: this.hoverText,
      allowableOverflow: 24,
      fixedOrientation: 'down'
    })
  }

  addCollapsedContent (infoParent) {
    const collapsedContent = infoParent.addContent(undefined, {
      htmlContent: this.collapsedText,
      classNames: 'details-block block'
    })
    collapsedContent.addCollapseControl(true, {
      htmlContent: this.contentProperties.collapseLabel || 'Details <span class="arrow"></span>'
    })
    return collapsedContent
  }

  initializeElements () {
    if (!this.contentProperties.name) throw new Error('InteractiveKey requires contentProperties.name to be defined')
    if (!this.contentProperties.targetType) throw new Error('InteractiveKey requires contentProperties.targetType to be defined')

    const {
      name,
      targetType,
      label,
      htmlContent
    } = this.contentProperties

    const eventName = `highlight${targetType.charAt(0).toUpperCase()}${targetType.slice(1)}`
    const targetClass = `${targetType}-${name}`

    if (!htmlContent) {
      this.contentProperties.htmlContent = `
        <span style="border-width: ${this.ui.settings.lineWidth}px;" class="${targetType}-icon"></span><label>${label}</label>
      `
    }
    super.initializeElements()

    this.d3Element.classed(targetClass, true)
    this.d3Element.classed('interactive-key', true)

    this.d3Element.on('mouseover', () => {
      this.ui.emit(eventName, this.contentProperties.name)

      if (this.hoverBox) {
        this.hoverBox.d3TitleBlock.classed(targetClass, true)
        this.hoverBox.d3TitleBlock.classed('by-variable', true)
      }

      const bbox = this.d3Element.node().getBoundingClientRect()
      const hoverBbox = this.hoverBox.d3Element.node().getBoundingClientRect()
      const containerBbox = this.relativeContainer.d3Element.node().getBoundingClientRect()

      if (this.hoverBox) {
        this.hoverBox.showAt({
          x: bbox.left + bbox.width / 2 + hoverBbox.width / 2,
          y: bbox.height + bbox.top - containerBbox.top
        })
      }
    })
    this.d3Element.on('mouseout', () => {
      this.ui.emit(eventName, null)
      if (this.collapsedContent) this.collapsedContent.collapseClose()
      if (this.hoverBox) this.hoverBox.hide()
    })
  }
}

module.exports = InteractiveKey

},{"./html-content.js":13}],16:[function(require,module,exports){
'use strict'

const d3 = require('./d3-subset.js')
const HtmlContent = require('./html-content.js')

class LineChart extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, Object.assign({
      static: true,
      margins: {
        top: 0,
        left: 6,
        right: 6,
        bottom: 12
      }
    }, contentProperties))

    this.topmostUI = this.ui
    this.xScale = d3.scaleTime()
    this.yScale = d3.scaleLinear()

    this.pixelsPerSlice = 0

    this.areaMaker = d3.area()
      .x(d => this.xScale(d.data.time))
      .y0(d => this.yScale(d[0]))
      .y1(d => this.yScale(d[1]))

    this.ui.on('setData', () => {
      this.setData()
    })
    this.ui.on('initializeFromData', () => {
      this.initializeFromData()
    })
    this.ui.on('setTopmostUI', topmostUI => {
      this.topmostUI = topmostUI
      this.layoutNode = topmostUI.layoutNode
      this.draw()
    })
  }
  getAggregateNode (id) {
    return this.ui.dataSet.aggregateNodes.get(id)
  }
  initializeElements () {
    super.initializeElements()
    const margins = this.contentProperties.margins

    this.d3Element.classed('line-chart', true)

    this.d3ChartWrapper = this.d3ContentWrapper.append('div')
      .classed('line-chart', true)

    this.d3LineChartSVG = this.d3ChartWrapper.append('svg')
      .classed('line-chart-svg', true)

    this.d3LineChartGroup = this.d3LineChartSVG.append('g')
      .attr('transform', `translate(${margins.left}, ${margins.top})`)

    this.d3LinesGroup = this.d3LineChartGroup.append('g')
      .classed('lines-group', true)

    this.d3XAxisGroup = this.d3LineChartGroup.append('g')
      .classed('axis-group', true)
      .classed('x-axis', true)

    this.hoverBox = this.addContent('HoverBox', {
      type: 'tool-tip',
      allowableOverflow: 24,
      fixedOrientation: 'up'
    })
    this.hoverBox.initializeElements()

    this.d3SliceHighlight = this.d3ChartWrapper.append('div')
      .classed('slice-highlight', true)
      .classed('hidden', true)

    this.d3LeadInText = this.d3ChartWrapper.append('p')
      .classed('lead-in-text', true)
  }
  setData () {
    const {
      wallTime,
      aggregateNodes
    } = this.ui.dataSet

    this.slicesCount = wallTime.slicesCount

    this.xScale.domain([0, wallTime.profileEnd - wallTime.profileStart])
    this.yScale.domain([0, wallTime.maxAsyncPending])

    // Sort by category (same colours together), and where same category, by id (how early defined)
    this.aggregateIds = [...aggregateNodes.keys()].sort((a, b) => {
      const aNode = aggregateNodes.get(a)
      const bNode = aggregateNodes.get(b)
      if (aNode.typeCategory !== bNode.typeCategory) {
        const aIndex = wallTime.categoriesOrdered.indexOf(aNode.typeCategory)
        const bIndex = wallTime.categoriesOrdered.indexOf(bNode.typeCategory)
        return aIndex - bIndex
      }
      return a - b
    })

    const aggregateIdsCount = this.aggregateIds.length
    this.dataArray = wallTime.slices.map((timeSlice, index) => {
      // Creates an object for each time slice containing the start time and a key for each aggregateId
      const asyncInSliceByAgId = {
        time: index * wallTime.msPerSlice
      }
      for (var i = 0; i < aggregateIdsCount; i++) {
        // Each aggregateId key is the number of async ops from that aggregate node active in this time slice
        asyncInSliceByAgId[this.aggregateIds[i]] = timeSlice.asyncPending.byAggregateId[this.aggregateIds[i]] || 0
      }
      return asyncInSliceByAgId
    })

    // d3's stacker inverts the data array, so it is by aggregateId in sort order first, each containing array
    // of timeslices, then stacks it such that [0] is the total of lower stacks and [1] is [0] + this datapoint
    const dataStacker = d3.stack()
      .keys(this.aggregateIds)

    this.stackedData = dataStacker(this.dataArray)

    // Refresh on data / layout update. This includes screen resize
    if (!this.hidden) {
      this.initializeFromData()
      this.draw()
    }
  }
  initializeFromData () {
    if (this.d3Lines) {
      this.d3Lines.data(this.stackedData)
      return
    }
    this.d3Lines = this.d3LinesGroup.selectAll('.area-line')
      .data(this.stackedData)
      .enter()
      .append('path')
      .attr('class', d => `type-${this.getAggregateNode(d.key).typeCategory}`)
      .classed('area-line-even', d => !(d.index % 2))
      .classed('area-line', true)
      .on('mouseover', (d) => {
        if (this.parentContent.constructor.name === 'HoverBox') return
        const aggregateNode = this.getAggregateNode(d.key)
        const layoutNode = this.topmostUI.layout.findAggregateNode(aggregateNode)
        if (layoutNode) {
          this.topmostUI.highlightNode(layoutNode, aggregateNode)
        }
      })
      .on('mouseout', () => {
        if (this.parentContent.constructor.name === 'HoverBox') return
        this.topmostUI.highlightNode(null)
      })
      .on('click', (d) => {
        const aggregateNode = this.getAggregateNode(d.key)
        const targetUI = this.topmostUI.jumpToNode(aggregateNode)
        if (targetUI !== this.ui) {
          this.ui.originalUI.emit('navigation', { from: this.ui, to: targetUI })
        }
      })
      .on('mousemove', () => {
        this.showSlice(d3.event)
      })

    // Same behaviour on mouse movements off coloured area as on
    this.d3LineChartSVG.on('mousemove', () => {
      this.showSlice(d3.event)
    })

    this.d3ContentWrapper.on('mouseleave', () => {
      this.hoverBox.hide()
      this.d3SliceHighlight.classed('hidden', true)
    })

    if (this.contentProperties.static) this.d3LeadInText.html(this.getLeadInText())
  }
  applyLayoutNode (layoutNode = null) {
    this.layoutNode = layoutNode
  }
  layoutNodeHasAggregateId (aggregateId) {
    const aggregateNode = this.getAggregateNode(aggregateId)
    const targetUI = this.parentContent.constructor.name === 'HoverBox' ? this.topmostUI : this.topmostUI.parentUI
    const layoutNode = targetUI.layout.findAggregateNode(aggregateNode)
    return (layoutNode === this.layoutNode)
  }
  getLeadInText () {
    const pluralCalls = this.ui.dataSet.callbackEventsCount !== 1
    const pluralResources = this.ui.dataSet.sourceNodesCount !== 1

    return `
      <strong>${this.ui.formatNumber(this.ui.dataSet.callbackEventsCount)} call${pluralCalls ? 's' : ''}</strong>
      to ${this.ui.formatNumber(this.ui.dataSet.sourceNodesCount)} async resource${pluralResources ? 's' : ''}, over
      ${(this.ui.formatNumber(this.ui.dataSet.wallTime.profileDuration))} milliseconds.
    `
  }
  showSlice (event) {
    const { offsetX } = event
    // Note: d3.event is a live binding which fails if d3 is not bundled in a recommended way.
    // See, for example, https://github.com/d3/d3-sankey/issues/30#issuecomment-307869620

    const width = this.d3LineChartSVG.node().getBoundingClientRect().width
    const margins = this.contentProperties.margins

    // Show nothing if mouse movement is within chart margins
    if (offsetX <= margins.left || offsetX + margins.left >= width) {
      this.d3SliceHighlight.classed('hidden', true)
      return
    }

    const leftPosition = offsetX - margins.left

    const index = Math.floor(leftPosition / this.pixelsPerSlice)
    const timeSliceData = this.dataArray[index]

    const totalOperationsInSlice = this.aggregateIds.reduce((accum, aggregateId) => {
      if (this.layoutNode && !this.layoutNodeHasAggregateId(aggregateId)) return accum
      return accum + timeSliceData[aggregateId]
    }, 0)

    const topOffset = margins.top
    const leftOffset = this.pixelsPerSlice * index + margins.left

    this.d3SliceHighlight
      .classed('hidden', false)
      .style('left', leftOffset + 'px')

    const pluralize = totalOperationsInSlice === 1 ? '' : 's'
    this.hoverBox.showContentAt(`<strong>${totalOperationsInSlice}</strong> pending async operation${pluralize}`, {
      x: leftOffset + this.pixelsPerSlice / 2,
      y: topOffset
    })
    this.hoverBox.d3Element.classed('off-bottom', true)
  }
  draw () {
    // Can be slow on extremely large profiles, do asynchronously
    setTimeout(() => {
      super.draw()
      const {
        width,
        height
      } = this.d3LineChartSVG.node().getBoundingClientRect()
      const margins = this.contentProperties.margins

      const usableHeight = height - margins.bottom - margins.top
      const usableWidth = width - margins.left - margins.right

      // If a layoutNode has been assigned, de-emphasise everything that's not in it
      if (this.layoutNode) {
        /* TODO: Enable this when nodes on diagram are drawn based on async / sync not within / between
        this.d3LeadInText.html(this.getLeadInText())
        */

        this.d3LineChartSVG.classed('filter-applied', true)
        this.d3Lines.classed('filtered', d => {
          if (!this.layoutNode) return false
          return !this.layoutNodeHasAggregateId(d.key)
        })
        if (this.ui.highlightedDataNode) {
          this.d3Lines.classed('not-emphasised', d => {
            const aggregateNode = this.getAggregateNode(d.key)
            return (aggregateNode !== this.ui.highlightedDataNode)
          })
        }
      } else {
        this.d3LineChartSVG.classed('filter-applied', false)
        this.d3Lines.classed('filtered', false)
      }

      this.xScale.range([0, usableWidth])
      this.yScale.range([usableHeight, 0])

      this.d3Lines.attr('d', this.areaMaker)

      const xAxis = d3.axisBottom()
        .ticks(width < 160 ? 5 : 9) // Show fewer ticks if less space is available
        .tickSize(2)
        .tickPadding(3)
        .scale(this.xScale)
        .tickFormat((dateStamp) => {
          const hairSpace = ' ' // &hairsp; unicode char, SVG doesn't like it as a HTML entity

          // Start with 0 s
          if (d3.timeFormat('%Q')(dateStamp) === '0') return `0${hairSpace}s`

          // Show millisecond increments like '500 ms'
          if (d3.timeSecond(dateStamp) < dateStamp) {
            // When space is moderately limited, show unlabelled mid point markers between seconds
            if (width < 220) return ''
            return d3.timeFormat('%L')(dateStamp) + `${hairSpace}ms`
          }
          // Show second increments like '5 s'
          if (d3.timeMinute(dateStamp) < dateStamp) return parseInt(d3.timeFormat('%S')(dateStamp)) + `${hairSpace}s`

          // Show minute increments like '5 min'
          if (d3.timeHour(dateStamp) < dateStamp) return d3.timeFormat('%M')(dateStamp) + `${hairSpace}min`

          // Show hour increments like '5 hr', with no units longer than hours
          return d3.timeFormat('%H')(dateStamp) + `${hairSpace}hr`
        })

      this.d3XAxisGroup
        .attr('transform', `translate(0, ${usableHeight})`)
        .call(xAxis)

      this.pixelsPerSlice = usableWidth / this.slicesCount

      this.d3SliceHighlight.style('width', Math.max(this.pixelsPerSlice, 1) + 'px')
      this.d3SliceHighlight.style('height', usableHeight + 'px')
      this.d3SliceHighlight.style('top', margins.top + 'px')
    })
  }
}

module.exports = LineChart

},{"./d3-subset.js":9,"./html-content.js":13}],17:[function(require,module,exports){
'use strict'

const HtmlContent = require('./html-content.js')
const debounce = require('lodash/debounce')

class Lookup extends HtmlContent {
  constructor (d3Container, contentProperties = {}) {
    super(d3Container, contentProperties)
    this.defaultText = contentProperties.defaultText
    this.lastInput = ''
    this.topmostUI = null

    this.ui.on('setTopmostUI', (topmostUI) => {
      const stringifiedKeys = () => [...this.topmostUI.layout.layoutNodes.keys()].join()

      const previousNodeIds = this.topmostUI ? stringifiedKeys() : null
      this.topmostUI = topmostUI

      if (previousNodeIds && previousNodeIds !== stringifiedKeys()) {
        // Re-do any current search against new layout
        this.lastInput = ''
        this.onInput()
      }
    })
  }

  initializeElements () {
    super.initializeElements()
    this.d3Element.classed('lookup', true)

    this.d3LookupInput = this.d3ContentWrapper.append('input')
      .classed('lookup-input', true)
      .classed('default-text', true)
      .property('value', this.defaultText)

    this.d3Suggestions = this.d3ContentWrapper.append('ul')
      .classed('lookup-suggestions', true)
      .classed('hidden', true)

    // Look up autocomplete suggestions when user has stopped typing
    const debouncedChange = debounce(() => {
      // Arrow functions around methods required to preserve `this` context
      this.onInput()
    }, 200)

    // Use keyup so isn't fired while, for example, user holds down delete
    this.d3LookupInput.on('keyup', debouncedChange)

    this.d3LookupInput.on('focus', () => {
      this.onFocus()
    })

    this.d3LookupInput.on('blur', () => {
      this.onBlur()
    })

    this.d3Element.on('mouseout', () => {
      this.clearLookup()
    })
  }

  onFocus () {
    if (this.d3LookupInput.property('value') === this.defaultText) {
      this.d3LookupInput.property('value', '')
      this.d3LookupInput.classed('default-text', false)
    }
    this.d3Suggestions.classed('hidden', false)
  }

  onBlur () {
    if (this.d3LookupInput.property('value') === '') {
      this.d3LookupInput.property('value', this.defaultText)
      this.d3LookupInput.classed('default-text', true)
      this.lastInput = ''
    }
    // Try to clear after current event stack resolves (e.g. click on a suggestion)
    setTimeout(() => {
      // Arrow function to preserve `this` context
      this.clearLookup()
    })
  }

  clearLookup () {
    // Only clear if the input doesn't have focus and the cursor isn't over any child of this element
    const hasHover = this.d3Element.selectAll(':hover').size()
    const hasFocus = this.d3LookupInput.node() === document.activeElement
    if (hasHover || hasFocus) return

    this.d3Suggestions
      .classed('hidden', true)
      .selectAll('li').remove()
  }

  onInput () {
    this.d3LookupInput.classed('default-text', false)
    const inputText = this.d3LookupInput.property('value').trim()
    if (inputText !== this.lastInput) {
      this.lookupFrames(inputText)
      this.lastInput = inputText
    }
  }

  lookupFrames (inputText) {
    this.d3Suggestions.selectAll('li').remove()

    if (inputText === this.defaultText || inputText.length < 3) return

    this.d3Element.classed('loading', true)

    // Let the .loading message show then do the lookup in another tick
    setTimeout(() => {
      // Clear again in case an earlier lookup resolved while this one was still processing
      this.d3Suggestions.selectAll('li').remove()

      const searchResults = this.deepFramesSearch(inputText)
      const matches = searchResults.length
      const pluralizer = matches === 1 ? '' : 'es'
      const resultsMessage = `Found ${matches || 'no'} match${pluralizer}${matches ? ':' : '.'}`

      this.d3Suggestions.append('li')
        .classed('results-count', true)
        .text(resultsMessage)

      for (const { frame, dataNode, layoutNode } of searchResults) {
        this.addSuggestion(frame, dataNode, layoutNode)
      }

      this.d3Element.classed('loading', false)
    })
  }

  addSuggestion (frame, dataNode, layoutNode) {
    const textString = frame.formatted
      // Add zero-width spaces after slashes to allow long paths to break across lines
      .replace(/\//g, '/&#8203;')
      .replace(/\\/g, '\\&#8203;')
      // Use non-breaking hyphens so file or folder names don't break across lines
      .replace(/-/g, '&#8209;')

    this.d3Suggestions.append('li')
      .classed('suggestion', true)
      .html(textString)
      .on('mouseover', () => {
        this.topmostUI.highlightNode(layoutNode, dataNode)
      })
      .on('mouseout', () => {
        this.topmostUI.highlightNode(null)
      })
      .on('click', () => {
        const targetUI = this.topmostUI.jumpToNode(dataNode)
        if (targetUI !== this.ui) {
          this.ui.originalUI.emit('navigation', { from: this.ui, to: targetUI })
        }
      })
  }

  deepFramesSearch (inputText) {
    // Do nothing if user manages to enter input before layout has loaded
    if (!this.topmostUI || !this.topmostUI.layout) return

    const inputStr = inputText.toLowerCase()

    // Enables results to be sorted by quality of match and interestingness of target
    const resultTypesByPriority = [
      [['functionName', 'exact'], []],
      [['fileName', 'exact', 'file'], []],
      [['typeName', 'exact'], []],
      [['functionName', 'start'], []],
      [['fileName', 'start', 'file'], []],
      [['fileName', 'exact', 'folder'], []],
      [['functionName', 'exact', null, 'split'], []],
      [['fileName', 'exact', 'file', 'split'], []],
      [['functionName', 'start', null, 'split'], []],
      [['fileName', 'start', 'file', 'split'], []],
      [['typeName', 'start'], []],
      [['fileName', 'exact', 'folder', 'split'], []],
      [['functionName', 'anywhere'], []],
      [['fileName', 'anywhere', 'file'], []],
      [['fileName', 'start', 'folder', 'split'], []],
      [['typeName', 'anywhere'], []],
      [['fileName', 'anywhere', 'folder'], []]
    ]

    const compare = (testStr, test, uriItem = null, split = null) => {
      if (uriItem) {
        const splitUri = testStr.replace(/\\/g, '/').split('/')
        const fileName = splitUri.pop()

        if (uriItem === 'file') {
          return compare(fileName, test, null, split)
        } else {
          return splitUri.some((folderName) => compare(folderName, test, null, split))
        }
      }

      if (split) {
        const camelFreeStr = testStr.replace(/([a-z])([A-Z])/g, '$1-$2')
        const split = camelFreeStr.replace(/_/g, '-').split('-')
        return split.some((subString) => compare(subString, test, uriItem, null))
      }

      testStr = testStr.toLowerCase()
      switch (test) {
        case 'exact':
          return testStr === inputStr
        case 'start':
          return testStr.match(new RegExp(`^${inputStr}.*`, 'i'))
        case 'anywhere':
          return testStr.match(new RegExp(`.*${inputStr}.*`, 'i'))
      }
    }

    const searchInFrame = (frame, dataNode, layoutNode) => {
      for (const [testConditions, resultsArray] of resultTypesByPriority) {
        const [
          dataType,
          test,
          uriItem,
          split
        ] = testConditions
        const testStr = frame.data[dataType]

        if (testStr && compare(testStr, test, uriItem, split)) {
          resultsArray.push({
            frame,
            dataNode,
            layoutNode
          })
          return
        }
      }
    }

    const searchInNode = (dataNode, layoutNode) => {
      switch (dataNode.constructor.name) {
        case 'AggregateNode':
          for (const frame of dataNode.frames) {
            searchInFrame(frame, dataNode, layoutNode)
          }
          break
        case 'ShortcutNode':
          break
        case 'ArtificialNode':
          for (const collapsedLayoutNode of layoutNode.collapsedNodes) {
            // Don't pass the collapsedLayoutNode down because it's not visible at this level
            searchInNode(collapsedLayoutNode.node, layoutNode)
          }
          break
        case 'ClusterNode':
          for (const aggregateNode of dataNode.nodes.values()) {
            searchInNode(aggregateNode, layoutNode)
          }
          break
      }
    }

    for (const layoutNode of this.topmostUI.layout.layoutNodes.values()) {
      searchInNode(layoutNode.node, layoutNode)
    }
    return resultTypesByPriority.reduce((acc, item) => acc.concat(item[1]), [])
  }
}

module.exports = Lookup

},{"./html-content.js":13,"lodash/debounce":139}],18:[function(require,module,exports){
'use strict'

const svgSample = `
  <svg class="key-item-image bubbleprof" style="width: 70px; height: 180px; display: block;">
    <g class="node-group" name="11" transform="rotate(-16) translate(-254,-285)">
      <path class="outer-path" d="M 294.6726593852533 304.365025784205 Q 287.82548583124384 291.99101211066295 275.4514721661044 298.838185648429L 245.9456762943194 401.45313620513423 A 34.49862255765599 34.49862255765599 0 1 0 265.1668635174329 406.97997632712253 Z"></path>
      <line class="line-segment party-nodecore" x1="288.9063032183193" x2="259.4005073465343" y1="302.70697374760846" y2="405.3219243043137" style="stroke-width: 2;"></line>
      <line class="line-segment type-networks" x1="292.75054066294194" x2="263.24474479115696" y1="303.81234177200616" y2="406.4272923287114" style="stroke-width: 2;"></line>
      <circle class="inner-circle" cx="246.29919333121512" cy="436.4107210714518" r="22.49862255765599"></circle>
      <path class="line-segment party-nodecore" d="M1.8675020246818336e-15,-30.49862255765599A30.49862255765599,30.49862255765599,0,1,1,-18.040781191743168,-24.590571199262715A30.49862255765599,30.49862255765599,0,1,0,1.8675020246818336e-15,-30.49862255765599Z" transform="translate(246.29919333121512, 436.4107210714518)" style="stroke-width: 2;"></path>
      <path class="line-segment party-external" d="M-18.040781191743168,-24.590571199262715A30.49862255765599,30.49862255765599,0,0,1,-5.602506074045501e-15,-30.49862255765599A30.49862255765599,30.49862255765599,0,0,0,-18.040781191743168,-24.590571199262715Z" transform="translate(246.29919333121512, 436.4107210714518)" style="stroke-width: 2;"></path>
      <path class="line-segment type-networks" d="M1.622572664852363e-15,-26.49862255765599A26.49862255765599,26.49862255765599,0,1,1,-22.827271325232676,-13.457068079538168A26.49862255765599,26.49862255765599,0,1,0,1.622572664852363e-15,-26.49862255765599Z" transform="translate(246.29919333121512, 436.4107210714518)" style="stroke-width: 2;"></path>
      <path class="line-segment type-timing-promises" d="M-22.827271325232676,-13.457068079538168A26.49862255765599,26.49862255765599,0,0,1,-4.867717994557089e-15,-26.49862255765599A26.49862255765599,26.49862255765599,0,0,0,-22.827271325232676,-13.457068079538168Z" transform="translate(246.29919333121512, 436.4107210714518)" style="stroke-width: 2;"></path>
      <text class="party-nodecore text-label name-label upper-label on-line-label" transform="translate(270.3091678378041, 352.90908100156344) rotate(-73.95799506878697)">example–1.2&#8202;s</text>
    </g>
  </svg>
`

const keyHtml = `
  <div class="key-bubble-sample">${svgSample}</div>
  <p>
    <strong>⬋ Grouped async operations.</strong> Size represents time spent executing code and waiting for responses.
  </p>
  <p>
    The straight line segment represents async operations in this group initiated in the previous group.
  </p>
  <p>
    Colors indicate type and area of the grouped operations (labels above expand to give more details).
  </p>
  <h4>How to start exploring this</h4>
  <p>
    The diagram shows how groups of async operations branch out from the start point of this application, which is at the top centre.
  </p>
  <p>
    <strong>Click on bubbles to explore deeper.</strong> When you reach groupings of only one async operation, call stacks are shown, allowing you to find the code behind the biggest delays.
  </p>
  <p>
    See also the <a href="https://clinicjs.org/bubbleprof/walkthrough" class="external-link">walkthrough and guides on the ClinicJs website</a>.
  </p>
`

module.exports = keyHtml

},{}],19:[function(require,module,exports){
'use strict'

const HtmlContent = require('./html-content.js')
const SvgNodeDiagram = require('./svg-node-diagram.js')

class SvgContainer extends HtmlContent {
  constructor (parentContent, contentProperties = {}) {
    const defaultProperties = {
      htmlElementType: 'svg'
    }
    super(parentContent, Object.assign(defaultProperties, contentProperties))

    if (contentProperties.svgBounds) {
      const defaultBounds = {
        minX: 0,
        minY: 0,
        width: null, // Set from layout.settings
        height: null, // Set in layout.scale
        preserveAspectRatio: 'xMidYMid meet',
        minimumDistanceFromEdge: 20
      }
      this.svgBounds = Object.assign(defaultBounds, contentProperties.svgBounds)
    }

    this.svgNodeDiagram = new SvgNodeDiagram(this)

    this.ui.on('setData', () => {
      this.setData()
    })
  }

  setData () {
    const {
      minX,
      minY,
      preserveAspectRatio
    } = this.svgBounds
    this.svgBounds.height = this.ui.layout.scale.finalSvgHeight || this.ui.layout.settings.svgHeight
    this.svgBounds.width = this.ui.layout.settings.svgWidth

    this.d3Element
      .attr('viewBox', `${minX} ${minY} ${this.svgBounds.width} ${this.svgBounds.height}`)
      .attr('preserveAspectRatio', preserveAspectRatio)
  }

  initializeElements () {
    super.initializeElements()

    this.d3Element
      .attr('id', this.contentProperties.id)
      .classed('bubbleprof', true)

    this.svgNodeDiagram.initializeElements()
  }

  draw () {
    this.svgNodeDiagram.draw()
  }
}

module.exports = SvgContainer

},{"./html-content.js":13,"./svg-node-diagram.js":20}],20:[function(require,module,exports){
'use strict'

const d3 = require('./d3-subset.js')
const LineCoordinates = require('../layout/line-coordinates.js')
const SvgNode = require('./svg-node.js')

class SvgNodeDiagram {
  constructor (svgContainer) {
    this.svgContainer = svgContainer
    this.ui = svgContainer.ui

    this.svgNodes = new Map()

    this.ui.on('initializeFromData', () => {
      // Called once, creates group contents using d3's .append()
      this.initializeFromData()
    })

    this.ui.on('setData', () => {
      // Called any time the layout or ui object are changed
      this.setData()
    })

    this.ui.on('svgDraw', () => {
      // Called any time the SVG DOM elements need to be modified or redrawn
      this.draw()
    })
  }

  initializeElements () {
    this.d3Container = this.svgContainer.d3Element

    // Group to which one group for each node is appended
    this.d3Element = this.d3Container.append('g')
      .classed('node-links-wrapper', true)
  }

  setData () {
    this.dataArray = [...this.ui.layout.layoutNodes.values()]
    this.d3Enter = this.d3Element.selectAll('g.node-group')
      .data(this.dataArray)
      .enter()

    this.dataArray.forEach(layoutNode => {
      if (!this.svgNodes.has(layoutNode.id)) this.svgNodes.set(layoutNode.id, new SvgNode(this))
      this.svgNodes.get(layoutNode.id).setData(layoutNode)
    })
  }

  initializeFromData () {
    this.d3NodeGroups = this.d3Enter.append('g')
      .classed('node-group', true)
      .attr('name', layoutNode => layoutNode.id)
      .each((layoutNode, i, nodes) => {
        const d3NodeGroup = d3.select(nodes[i])
        this.svgNodes.get(layoutNode.id).initializeFromData(d3NodeGroup)
      })
      .on('mouseenter', layoutNode => this.ui.highlightNode(layoutNode))
      .on('mouseleave', () => this.ui.highlightNode(null))
      .on('click', (layoutNode) => {
        d3.event.stopPropagation()
        const targetUI = this.ui.selectNode(layoutNode)
        if (targetUI !== this.ui) {
          this.ui.originalUI.emit('navigation', { from: this.ui, to: targetUI })
        }
      })
  }
  draw () {
    this.bbox = this.d3Container.node().getBoundingClientRect()
    this.svgNodes.forEach(svgNode => svgNode.draw())
  }

  getLengthToBottom (x1, y1, degrees) {
    // Outer padding is partly for labels to use, allow encrouchment most of the way
    const distanceFromEdge = this.ui.settings.svgDistanceFromEdge / 4

    const radians = LineCoordinates.degreesToRadians(90 - degrees)
    const adjacentLength = this.bbox.height - distanceFromEdge - y1
    const hypotenuseLength = adjacentLength / Math.cos(radians)
    return hypotenuseLength
  }

  getLengthToSide (x1, y1, degrees) {
    // Outer padding is partly for labels to use, allow a little encrouchment
    const distanceFromEdge = this.ui.settings.svgDistanceFromEdge

    // Ensure degrees range is between -180 and 180
    degrees = LineCoordinates.enforceDegreesRange(degrees)
    let radians
    let adjacentLength

    if (degrees > 90 || degrees < -90) {
      // Test against left side edge
      radians = LineCoordinates.degreesToRadians(180 - degrees)
      adjacentLength = x1 - distanceFromEdge
    } else {
      // Test against right side edge
      radians = LineCoordinates.degreesToRadians(degrees)
      adjacentLength = this.bbox.width - distanceFromEdge - x1
    }
    const hypotenuseLength = adjacentLength / Math.cos(radians)
    return hypotenuseLength
  }
}

module.exports = SvgNodeDiagram

},{"../layout/line-coordinates.js":28,"./d3-subset.js":9,"./svg-node.js":22}],21:[function(require,module,exports){
'use strict'

const d3 = require('./d3-subset.js')
const LineCoordinates = require('../layout/line-coordinates.js')

class SvgNodeSection {
  constructor (parentContent, settings) {
    this.parentContent = parentContent
    this.ui = parentContent.ui

    const {
      dataPosition,
      shapeClass
    } = settings
    this.dataPosition = dataPosition
    this.shapeClass = shapeClass
  }
  setData (layoutNode) {
    this.layoutNode = layoutNode
  }
  initializeFromData () {
    this.d3NodeGroup = this.parentContent.d3NodeGroup

    if (this.shapeClass === 'SvgBubble') {
      this.d3InnerCircle = this.d3NodeGroup.append('circle')
        .classed('inner-circle', true)
    }

    const svgNodeElementClasses = {
      SvgLine,
      SvgBubble
    }

    const SvgNodeElementClass = svgNodeElementClasses[this.shapeClass]

    this.byParty = new SvgNodeElementClass(this, this.d3NodeGroup, 'party')
      .setData(this.layoutNode)
      .initializeFromData()

    this.byType = new SvgNodeElementClass(this, this.d3NodeGroup, 'typeCategory')
      .setData(this.layoutNode)
      .initializeFromData()
  }
  draw () {
    // In case this was too small to show on page load, but screen has been resized up, and now it's big enough
    if (!this.byParty) this.initializeFromData()

    this.byParty.draw()
    this.byType.draw()

    if (this.d3InnerCircle) {
      this.d3InnerCircle
        .attr('cx', this.parentContent.circleCentre.x)
        .attr('cy', this.parentContent.circleCentre.y)
        .attr('r', Math.max(this.parentContent.getRadius() - this.ui.settings.lineWidth * 4, 0))
    }
  }
}

class SvgNodeElement {
  constructor (parentContent, d3Group, dataType) {
    this.svgNode = parentContent.parentContent
    this.d3Group = d3Group
    this.ui = parentContent.ui

    this.dataPosition = parentContent.dataPosition
    this.dataType = dataType
  }
  setData (layoutNode) {
    this.decimalsArray = layoutNode.node.getDecimalsArray(this.dataType, this.dataPosition)

    return this
  }

  getRadius (layoutNode) {
    return this.ui.layout.scale.getCircleRadius(layoutNode.getWithinTime())
  }

  getLength (layoutNode) {
    return this.ui.layout.scale.getLineLength(layoutNode.getBetweenTime())
  }
}

class SvgLine extends SvgNodeElement {
  initializeFromData () {
    const d3Enter = this.d3Group.selectAll('line.segmented-line')
      .data(this.decimalsArray)
      .enter()

    const classPrepend = this.dataType === 'typeCategory' ? 'type' : 'party'
    const highlightEvent = this.dataType === 'typeCategory' ? 'highlightType' : 'highlightParty'

    this.d3Shapes = d3Enter.append('line')
      .attr('class', decimal => `line-segment ${classPrepend}-${decimal[0]}`)
      .style('stroke-width', this.ui.settings.lineWidth)
      .on('mouseover', decimal => this.ui.emit(highlightEvent, decimal[0]))
      .on('mouseout', () => this.ui.emit(highlightEvent, null))

    return this
  }
  setCoordinates () {
    this.degrees = this.svgNode.degrees
    this.length = this.svgNode.drawType === 'squash' ? Math.max(this.svgNode.getLength(), 1) : this.svgNode.getLength()

    let degrees
    let length
    if (this.svgNode.drawType === 'labelOnLine') {
      degrees = this.degrees + 90 * (this.svgNode.flipLabel ? -1 : 1)
      length = this.ui.settings.lineWidth * (this.dataType === 'typeCategory' ? 4 : 2)
    } else {
      const onLeftSide = (this.svgNode.flipLabel && this.dataType === 'typeCategory') || (!this.svgNode.flipLabel && this.dataType !== 'typeCategory')
      degrees = this.degrees + 90 * (onLeftSide ? -1 : 1)
      length = this.ui.settings.lineWidth
    }

    const toOrigin = new LineCoordinates({
      x1: this.svgNode.originPoint.x,
      y1: this.svgNode.originPoint.y,
      degrees,
      length
    })

    this.originPoint = {
      x: toOrigin.x2,
      y: toOrigin.y2
    }
    return this
  }
  draw () {
    this.setCoordinates()

    let previousX = this.originPoint.x
    let previousY = this.originPoint.y

    this.d3Shapes.each((segmentDatum, index, nodes) => {
      const d3LineSegment = d3.select(nodes[index])

      const segmentLine = new LineCoordinates({
        x1: previousX,
        y1: previousY,
        degrees: this.degrees,
        length: this.length * segmentDatum[1]
      })

      previousX = segmentLine.x2
      previousY = segmentLine.y2

      d3LineSegment.attr('x1', segmentLine.x1)
      d3LineSegment.attr('x2', segmentLine.x2)
      d3LineSegment.attr('y1', segmentLine.y1)
      d3LineSegment.attr('y2', segmentLine.y2)
    })
  }
}

class SvgBubble extends SvgNodeElement {
  setData (layoutNode) {
    super.setData(layoutNode)
    this.arcData = d3.pie().value((arcDatum) => arcDatum[1])(this.decimalsArray)
    return this
  }
  initializeFromData () {
    const d3Enter = this.d3Group.selectAll('path.segmented-bubble')
      .data(this.arcData)
      .enter()

    const classPrepend = this.dataType === 'typeCategory' ? 'type' : 'party'
    const highlightEvent = this.dataType === 'typeCategory' ? 'highlightType' : 'highlightParty'

    this.d3Shapes = d3Enter.append('path')
      .attr('class', arcDatum => `line-segment ${classPrepend}-${arcDatum.data[0]}`)
      .style('stroke-width', this.ui.settings.lineWidth)
      .on('mouseover', arcDatum => this.ui.emit(highlightEvent, arcDatum.data[0]))
      .on('mouseout', () => this.ui.emit(highlightEvent, null))

    return this
  }
  setCoordinates () {
    this.circleCentre = this.svgNode.circleCentre
    this.radius = this.svgNode.getRadius() - (this.dataType === 'typeCategory' ? this.ui.settings.lineWidth * 2 : 0)
  }
  draw () {
    this.setCoordinates()

    const arcMaker = d3.arc()
      .innerRadius(this.radius)
      .outerRadius(this.radius)

    this.d3Shapes
      .attr('d', arcDatum => arcMaker(arcDatum))
      .attr('transform', `translate(${this.circleCentre.x}, ${this.circleCentre.y})`)
  }
}

module.exports = SvgNodeSection

},{"../layout/line-coordinates.js":28,"./d3-subset.js":9}],22:[function(require,module,exports){
'use strict'

const LineCoordinates = require('../layout/line-coordinates.js')
const SvgNodeSection = require('./svg-node-section.js')

class SvgNode {
  constructor (parentContent) {
    this.parentContent = parentContent
    this.ui = parentContent.ui

    // Set and updated in .setCoordinates():
    this.strokePadding = null
    this.degrees = null
    this.originPoint = null

    this.asyncBetweenLines = new SvgNodeSection(this, {
      dataPosition: 'between',
      shapeClass: 'SvgLine'
    })
    this.syncBubbles = new SvgNodeSection(this, {
      dataPosition: 'within',
      shapeClass: 'SvgBubble'
    })
  }

  setData (layoutNode) {
    this.layoutNode = layoutNode
    this.drawType = this.getDrawType(layoutNode)

    this.asyncBetweenLines.setData(layoutNode)
    if (this.drawType !== 'squash') {
      this.syncBubbles.setData(layoutNode)
    }

    if (this.d3NodeGroup) this.setCoordinates()
    return this
  }

  setCoordinates () {
    this.strokePadding = this.ui.settings.labelMinimumSpace // this.ui.settings.strokePadding
    this.labelMinimumSpace = this.ui.settings.labelMinimumSpace
    this.lineWidth = this.ui.settings.lineWidth

    this.circleCentre = {
      x: this.layoutNode.position.x,
      y: this.layoutNode.position.y
    }

    const inboundConnection = this.layoutNode.inboundConnection
    const previousPosition = inboundConnection ? inboundConnection.sourceLayoutNode.position : {
      // Root node position
      x: this.layoutNode.position.x,
      y: this.ui.settings.svgDistanceFromEdge - this.strokePadding - this.lineWidth
    }
    const connectCentresCoords = new LineCoordinates({
      x1: previousPosition.x,
      y1: previousPosition.y,
      x2: this.layoutNode.position.x,
      y2: this.layoutNode.position.y
    })

    this.degrees = connectCentresCoords.degrees

    // Prevent on-line or following-line label text being upside-down
    this.labelDegrees = labelRotation(this.degrees)
    this.flipLabel = !(this.degrees === this.labelDegrees)

    // TODO: check that this doesn't look wrong in cases of drawType = squash but has withinTime
    const sourceRadius = inboundConnection ? this.getRadius(inboundConnection.sourceLayoutNode) + this.strokePadding : 0

    const offsetLength = sourceRadius - this.lineWidth / 2 + this.strokePadding
    const offsetBeforeLine = new LineCoordinates({
      radians: connectCentresCoords.radians,
      length: offsetLength,
      x1: previousPosition.x,
      y1: previousPosition.y
    })

    this.originPoint = {
      x: offsetBeforeLine.x2,
      y: offsetBeforeLine.y2
    }
  }

  initializeFromData (d3NodeGroup) {
    this.d3NodeGroup = d3NodeGroup
    const partyClass = `party-${this.layoutNode.node.mark.get('party')}`

    this.d3OuterPath = this.d3NodeGroup.append('path')
      .classed('outer-path', true)

    this.asyncBetweenLines.initializeFromData()
    if (this.drawType !== 'squash') {
      this.syncBubbles.initializeFromData()
    }

    this.d3NameLabel = this.d3NodeGroup.append('text')
      .classed(partyClass, true)
      .classed('text-label', true)
      .classed('name-label', true)

    this.d3TimeLabel = this.d3NodeGroup.append('text')
      .classed(partyClass, true)
      .classed('text-label', true)
      .classed('time-label', true)

    this.setCoordinates()
    return this
  }

  draw () {
    if (this.layoutNode.node.constructor.name === 'ShortcutNode') {
      this.drawShortcut()
    } else {
      this.drawOuterPath()
      this.drawNameLabel()

      if (this.drawType === 'labelInCircle') this.drawTimeLabel()

      this.asyncBetweenLines.draw()
      if (this.drawType !== 'squash') {
        this.syncBubbles.draw()
      }
    }
  }

  drawShortcut () {
    this.d3NodeGroup.classed('shortcut', true)

    const backwards = !this.layoutNode.parent
    const degrees = backwards ? LineCoordinates.enforceDegreesRange(this.degrees - 180) : this.degrees
    const length = this.ui.settings.shortcutLength

    let outerPath = ''

    const arrowLine = new LineCoordinates({
      x1: this.originPoint.x,
      y1: this.originPoint.y,
      degrees: this.degrees,
      length
    })

    const start = {
      x: backwards ? arrowLine.x2 : arrowLine.x1,
      y: backwards ? arrowLine.y2 : arrowLine.y1
    }

    const end = {
      x: backwards ? arrowLine.x1 : arrowLine.x2,
      y: backwards ? arrowLine.y1 : arrowLine.y2
    }

    const toArrowLeftBase = new LineCoordinates({
      x1: start.x,
      y1: start.y,
      length: this.strokePadding,
      degrees: degrees - 90
    })
    outerPath += `M ${toArrowLeftBase.x2} ${toArrowLeftBase.y2} `

    const toArrowRightBase = new LineCoordinates({
      x1: toArrowLeftBase.x2,
      y1: toArrowLeftBase.y2,
      length: this.strokePadding * 2,
      degrees: degrees + 90
    })
    outerPath += `L ${toArrowRightBase.x2} ${toArrowRightBase.y2} `

    const toArrowheadRightBase = new LineCoordinates({
      x1: toArrowRightBase.x2,
      y1: toArrowRightBase.y2,
      length: length - this.strokePadding * 2,
      degrees
    })
    outerPath += `L ${toArrowheadRightBase.x2} ${toArrowheadRightBase.y2} `

    const toArrowheadRightCorner = new LineCoordinates({
      x1: toArrowheadRightBase.x2,
      y1: toArrowheadRightBase.y2,
      length: this.strokePadding,
      degrees: degrees + 90
    })
    outerPath += `L ${toArrowheadRightCorner.x2} ${toArrowheadRightCorner.y2} `

    const toArrowheadTip = new LineCoordinates({
      x1: toArrowheadRightBase.x2,
      y1: toArrowheadRightBase.y2,
      x2: end.x,
      y2: end.y
    })
    outerPath += `L ${toArrowheadTip.x2} ${toArrowheadTip.y2} `

    const toArrowheadLeftCorner = new LineCoordinates({
      x1: toArrowheadRightCorner.x2,
      y1: toArrowheadRightCorner.y2,
      length: this.strokePadding * 4,
      degrees: degrees - 90
    })
    outerPath += `L ${toArrowheadLeftCorner.x2} ${toArrowheadLeftCorner.y2} `

    const toArrowheadLeftBase = new LineCoordinates({
      x1: toArrowheadLeftCorner.x2,
      y1: toArrowheadLeftCorner.y2,
      length: this.strokePadding,
      degrees: degrees + 90
    })
    outerPath += `L ${toArrowheadLeftBase.x2} ${toArrowheadLeftBase.y2} Z`

    this.d3OuterPath.attr('d', outerPath)

    const toArrowMidpoint = new LineCoordinates({
      x1: start.x,
      y1: start.y,
      degrees,
      length: length / 2
    })

    this.d3TimeLabel.classed('hidden', true)
    this.d3NameLabel.text(formatNameLabel(this.layoutNode.node.name))
      .classed(`party-${this.layoutNode.node.mark.get('party')}`, true)
      .classed('on-line-label', true)
    trimText(this.d3NameLabel, length - this.strokePadding)

    const transformString = `translate(${toArrowMidpoint.x2}, ${toArrowMidpoint.y2}) rotate(${this.labelDegrees})`
    this.d3NameLabel.attr('transform', transformString)
  }

  drawNameLabel () {
    this.d3TimeLabel.classed('hidden', true)
    this.d3NameLabel.classed('hidden', false)

    const nameLabel = formatNameLabel(this.layoutNode.node.name)
    const labelPlusTime = `${nameLabel}–${formatTimeLabel(this.layoutNode.node.stats.overall)}`
    this.d3NameLabel.text(labelPlusTime)

    let textAfterTrim = ''
    const spaceInCircle = Math.max(this.getRadius() * 2 - this.strokePadding - this.lineWidth, 0)
    const spaceOnLine = Math.max(this.getLength() - this.strokePadding, 0)

    if (!this.layoutNode.children.length) {
      // Is a leaf / endpoint - can position at end of line, continuing line

      // First see if the label fits fine on the line or in the circle
      if (this.drawType === 'labelOnLine') textAfterTrim = trimText(this.d3NameLabel, spaceOnLine)
      if (this.drawType === 'labelInCircle') textAfterTrim = trimText(this.d3NameLabel, spaceInCircle)

      if (textAfterTrim !== labelPlusTime) {
        // See if putting the label after the line truncates it less
        this.d3NameLabel.text(labelPlusTime)

        const toEndpoint = new LineCoordinates({
          x1: this.circleCentre.x,
          y1: this.circleCentre.y,
          length: this.getRadius() + this.lineWidth + this.strokePadding,
          degrees: this.degrees
        })

        const {
          x2,
          y2
        } = toEndpoint

        const lengthToSide = this.parentContent.getLengthToSide(x2, y2, this.degrees, this.ui.settings)
        const lengthToBottom = this.parentContent.getLengthToBottom(x2, y2, this.degrees, this.ui.settings)
        const lengthToEdge = Math.min(lengthToSide, lengthToBottom)

        const textAfterTrimToEdge = trimText(this.d3NameLabel, lengthToEdge)

        if (textAfterTrimToEdge.length > textAfterTrim.length) {
          this.d3NameLabel.classed('flipped-label', this.flipLabel)
          this.d3NameLabel.classed('endpoint-label', true)
          this.d3NameLabel.classed('upper-label', false)
          this.d3NameLabel.classed('smaller-label', this.drawType === 'squash')

          const transformString = `translate(${x2}, ${y2}) rotate(${this.labelDegrees})`
          this.d3NameLabel.attr('transform', transformString)

          this.d3TimeLabel.classed('hidden', true)

          // Tell the rest of the drawing logic that the expected on-line/in-cirlce label has been moved
          if (this.drawType === 'labelOnLine' || this.drawType === 'labelInCircle') this.drawType = 'labelAfterLine'
          return
        } else {
          this.d3NameLabel.text(textAfterTrim)
        }

        this.d3NameLabel.classed('hidden', !textAfterTrim)
      }
    }

    if (this.drawType === 'noNameLabel') {
      this.d3NameLabel.classed('hidden', true)
      return
    }

    // Is not a leaf / endpoint - position on line or circle
    this.d3NameLabel.classed('upper-label', true)
    this.d3NameLabel.classed('endpoint-label', false)
    this.d3NameLabel.classed('smaller-label', false)
    this.d3NameLabel.classed('flipped-label', false)

    if (this.drawType === 'labelOnLine') {
      if (!textAfterTrim) textAfterTrim = trimText(this.d3NameLabel, spaceOnLine)

      if (!textAfterTrim) {
        this.drawType = 'noNameLabel'
        this.d3NameLabel.classed('hidden', true)
        return
      }
      this.d3NameLabel.classed('hidden', false)

      const toMidwayPoint = new LineCoordinates({
        x1: this.originPoint.x,
        y1: this.originPoint.y,
        length: this.getLength() / 2,
        degrees: this.degrees
      })
      const transformString = `translate(${toMidwayPoint.x2}, ${toMidwayPoint.y2}) rotate(${this.labelDegrees})`
      this.d3NameLabel.attr('transform', transformString)

      this.d3NameLabel.classed('on-line-label', true)
    } else {
      this.d3NameLabel.classed('on-line-label', false)
    }

    if (this.drawType === 'labelInCircle') {
      // Don't include time label in text label, drop it below
      this.d3TimeLabel.classed('hidden', false)
      this.d3NameLabel.text(nameLabel)

      textAfterTrim = trimText(this.d3NameLabel, spaceInCircle)

      if (!textAfterTrim) {
        this.drawType = 'noNameLabel'
        this.d3NameLabel.classed('hidden', true)
        return
      }
      this.d3NameLabel.classed('hidden', false)

      this.d3NameLabel.attr('transform', `translate(${this.circleCentre.x}, ${this.circleCentre.y}) rotate(${labelRotation(this.degrees - 90)})`)

      this.d3NameLabel.classed('in-circle-label', true)
    } else {
      this.d3NameLabel.classed('in-circle-label', false)
    }
  }

  drawTimeLabel () {
    this.d3TimeLabel.classed('hidden', false)
    this.d3TimeLabel.text(formatTimeLabel(this.layoutNode.node.stats.overall))

    // Position in circle
    const textAfterTrim = trimText(this.d3TimeLabel, this.getRadius() * 1.5 - this.strokePadding)
    this.d3TimeLabel.classed('hidden', !textAfterTrim)
    this.d3TimeLabel.attr('transform', `translate(${this.circleCentre.x}, ${this.circleCentre.y}) rotate(${labelRotation(this.degrees - 90)})`)

    this.d3TimeLabel.classed('in-circle-label', true)
    this.d3TimeLabel.classed('on-line-label', false)
    this.d3TimeLabel.classed('lower-label', true)
  }

  drawOuterPath () {
    let outerPath = ''
    const lineLength = this.getLength()

    const toLineTopLeft = new LineCoordinates({
      x1: this.originPoint.x,
      y1: this.originPoint.y,
      length: this.strokePadding,
      degrees: this.degrees - 90
    })
    outerPath += `M ${toLineTopLeft.x2} ${toLineTopLeft.y2} `

    const toLineTopRight = new LineCoordinates({
      x1: toLineTopLeft.x2,
      y1: toLineTopLeft.y2,
      length: this.strokePadding * 2,
      degrees: this.degrees + 90
    })
    const toQCurveControlPoint = new LineCoordinates({
      x1: this.originPoint.x,
      y1: this.originPoint.y,
      length: this.strokePadding,
      degrees: this.degrees - 180
    })
    outerPath += `Q ${toQCurveControlPoint.x2} ${toQCurveControlPoint.y2} ${toLineTopRight.x2} ${toLineTopRight.y2}`

    const toLineBottomRight = new LineCoordinates({
      x1: toLineTopRight.x2,
      y1: toLineTopRight.y2,
      length: lineLength,
      degrees: this.degrees
    })

    outerPath += `L ${toLineBottomRight.x2} ${toLineBottomRight.y2} `

    if (this.drawType === 'squash') {
      // End with pointed arrow tip

      const toPointedTip = new LineCoordinates({
        x1: this.originPoint.x,
        y1: this.originPoint.y,
        length: lineLength + this.strokePadding,
        degrees: this.degrees
      })

      outerPath += `L ${toPointedTip.x2} ${toPointedTip.y2} `

      outerPath += 'L' // Ready for simple line to bottom left x y
    } else {
      // End with long-route circular arc around bubble, to bottom left x y

      const arcRadius = this.getRadius() + this.lineWidth * 2
      // Arc definition: A radiusX radiusY x-axis-rotation large-arc-flag sweep-flag x y
      outerPath += `A ${arcRadius} ${arcRadius} 0 1 0`
    }

    const toLineBottomLeft = new LineCoordinates({
      x1: toLineBottomRight.x2,
      y1: toLineBottomRight.y2,
      length: this.strokePadding * 2,
      degrees: this.degrees - 90
    })

    outerPath += ` ${toLineBottomLeft.x2} ${toLineBottomLeft.y2} Z`

    this.d3OuterPath.attr('d', outerPath)
  }

  getRadius (layoutNode = this.layoutNode) {
    if (layoutNode === this.layoutNode && this.drawType === 'squash') {
      return 0
    } else {
      return this.ui.layout.scale.getCircleRadius(layoutNode.getWithinTime())
    }
  }

  getLength (layoutNode = this.layoutNode) {
    if (this.drawType === 'squash') {
      return this.ui.layout.scale.getLineLength(layoutNode.getBetweenTime() + layoutNode.getWithinTime())
    } else {
      return this.ui.layout.scale.getLineLength(layoutNode.getBetweenTime())
    }
  }

  getDrawType (layoutNode) {
    const circleRadius = this.getRadius()
    const lineLength = this.getLength()

    // Too small to discriminate node elements; show a very short line
    if (circleRadius + lineLength < 2) return 'squash'

    // Prefer putting labels on lines over in circles if both are viable and similar
    if (lineLength > 30 && lineLength > circleRadius) return 'labelOnLine'

    if (circleRadius > 30) return 'labelInCircle'

    return 'noNameLabel'
  }
}

function labelRotation (degrees) {
  // Prevent text from being displayed upside down
  if (degrees > 90) return (degrees -= 180)
  if (degrees < -90) return (degrees += 180)
  return degrees
}

function trimText (d3Text, maxLength, reps = 0) {
  d3Text.classed('hidden', false)

  const width = d3Text.node().getBBox().width
  const textString = d3Text.text()

  if (width > maxLength) {
    const decimal = maxLength / width
    const trimToLength = Math.floor(textString.length * decimal) - 2

    if (trimToLength > 1 && reps < 5) {
      reps++ // Limit recursion in case unusual characters e.g. diacritics cause infinite loop
      const ellipsisChar = '…'
      const newText = textString.slice(0, trimToLength) + ellipsisChar
      d3Text.text(newText)
      // Check new text fits - won't if early chars are wider than later chars, e.g. 'Mmmmmm!!!!!!'
      return (trimText(d3Text, maxLength, reps))
    }
    d3Text.text('')
    return ''
  }
  return textString
}

function formatTimeLabel (num) {
  // format as 2 significant figures, with ms or s units
  const hairSpace = ' ' // &hairsp; unicode char, SVG doesn't like it as a HTML entity
  if (num < 1) return `<1${hairSpace}ms`

  if (num > 1000) {
    return `${parseFloat((num / 1000).toPrecision(2))}${hairSpace}s`
  } else {
    return `${parseFloat(num.toPrecision(2))}${hairSpace}ms`
  }
}

function formatNameLabel (string) {
  // Remove line numbers from aggregateNode names
  string = string.replace(/:\d+:\d+/g, '')

  // Remove indicators of truncated module lists
  string = string.replace(/\.\.\. > /g, '')
  return string
}

module.exports = SvgNode

},{"../layout/line-coordinates.js":28,"./svg-node-section.js":21}],23:[function(require,module,exports){
'use strict'

const _ = {
  difference: require('lodash/difference')
}

const { ShortcutNode } = require('../data/data-node.js')
const { LayoutNode, CollapsedLayoutNode } = require('./layout-node.js')

class CollapsedLayout {
  constructor (layout) {
    this.uncollapsedLayout = layout
    // Shallow clone before modifying
    // TODO: revisit idempotency of this class - mutates each LayoutNode internally
    this.layoutNodes = new Map([...layout.layoutNodes])
    this.scale = layout.scale
    this.minimumNodes = 3

    // TODO: stop relying on coincidental Map.keys() order (i.e. stuff would break when child occurs before parent)
    // e.g. we could attach .topNodes or some iterator to Layout instances
    this.topLayoutNodes = new Set([...this.layoutNodes.values()].filter(layoutNode => !layoutNode.parent))

    let topNodesIterator = this.topLayoutNodes.values()
    for (let i = 0; i < this.topLayoutNodes.size; ++i) {
      const topNode = topNodesIterator.next().value
      this.collapseHorizontally(topNode)
    }
    const newLayoutNodes = new Map()
    // Isolating vertical collapsing from horizontal collapsing
    // Mainly for aesthetic reasons, but also reduces complexity (easier to debug)
    topNodesIterator = this.topLayoutNodes.values()
    for (let i = 0; i < this.topLayoutNodes.size; ++i) {
      const topNode = topNodesIterator.next().value
      this.collapseVertically(topNode)
      this.mergeShortcutNodes(topNode)
      this.indexLayoutNode(newLayoutNodes, topNode)
    }
    this.layoutNodes = newLayoutNodes
  }
  indexLayoutNode (nodesMap, layoutNode) {
    nodesMap.set(layoutNode.id, layoutNode)
    for (let i = 0; i < layoutNode.children.length; ++i) {
      const childId = layoutNode.children[i]
      this.indexLayoutNode(nodesMap, this.layoutNodes.get(childId))
    }
  }
  mergeShortcutNodes (layoutNode) {
    // Reduce shortcuts
    const { dataNodes, shortcutsByTarget } = this.groupNodesByTarget(layoutNode)
    const shortcutNodes = this.formShortcutBijection(shortcutsByTarget, layoutNode)
    // Update refs
    layoutNode.children = dataNodes.concat(shortcutNodes)
    // Traverse down
    for (let i = 0; i < layoutNode.children.length; ++i) {
      const childId = layoutNode.children[i]
      const childLayoutNode = this.layoutNodes.get(childId)
      this.mergeShortcutNodes(childLayoutNode)
    }
  }
  groupNodesByTarget (layoutNode) {
    // Used to group alike ShortcutNodes together
    // Maps { LayoutNode => [...ShortcutNode] }
    // e.g. { LayoutNode-2 => [ShortcutNode-2], CollapsedLayoutNode-clump:3,4,5 => [ShortcutNode-3, ShortcutNode-4, ShortcutNode-5] }
    const shortcutsByTarget = new Map()

    const dataNodes = []
    for (let i = 0; i < layoutNode.children.length; ++i) {
      const childId = layoutNode.children[i]
      const childLayoutNode = this.layoutNodes.get(childId)
      if (childLayoutNode.node.constructor.name === 'ShortcutNode') {
        const shortcutNode = childLayoutNode.node
        const targetLayoutNode = this.uncollapsedLayout.findDataNode(shortcutNode.shortcutTo, true)
        let targetShortcuts = shortcutsByTarget.get(targetLayoutNode)
        if (!targetShortcuts) {
          targetShortcuts = []
          shortcutsByTarget.set(targetLayoutNode, targetShortcuts)
        }
        targetShortcuts.push(childLayoutNode)
      } else {
        dataNodes.push(childId)
      }
    }
    return { dataNodes, shortcutsByTarget }
  }
  formShortcutBijection (shortcutsByTarget, parentLayoutNode) {
    const bijectiveShortcuts = []
    const shortcutsIterator = shortcutsByTarget.entries()
    for (let i = 0; i < shortcutsByTarget.size; ++i) {
      const [targetLayoutNode, shortcutNodes] = shortcutsIterator.next().value
      if (shortcutNodes.length === 1) {
        bijectiveShortcuts.push(shortcutNodes[0].id)
        continue
      }

      const mergedShortcut = new ShortcutNode({
        id: `shortcut:${targetLayoutNode.id}`,
        children: [],
        parentId: parentLayoutNode.id
      }, targetLayoutNode.node)
      mergedShortcut.targetLayoutNode = targetLayoutNode
      const mergedLayoutNode = new LayoutNode(mergedShortcut, parentLayoutNode)
      for (let i = 0; i < shortcutNodes.length; ++i) {
        const shortcutLayoutNode = shortcutNodes[i]
        this.layoutNodes.delete(shortcutLayoutNode.id)
      }
      this.layoutNodes.set(mergedLayoutNode.id, mergedLayoutNode)
      bijectiveShortcuts.push(mergedLayoutNode.id)
    }
    return bijectiveShortcuts
  }
  collapseHorizontally (layoutNode) {
    let combined
    let prevTiny
    const children = layoutNode.children.map(childId => this.layoutNodes.get(childId))
    for (let i = 0; i < children.length; ++i) {
      const child = children[i]
      const belowThreshold = this.isBelowThreshold(child)
      this.collapseHorizontally(child)
      if (this.layoutNodes.size === this.minimumNodes) {
        break
      }
      if (belowThreshold) {
        if (combined || prevTiny) {
          combined = this.combinelayoutNodes(combined || prevTiny, child)
        }
        prevTiny = child
      }
    }
  }
  collapseVertically (layoutNode) {
    const children = layoutNode.children.map(childId => this.layoutNodes.get(childId))
    let combined
    for (let i = 0; i < children.length; ++i) {
      const child = children[i]
      const belowThreshold = child.collapsedNodes || this.isBelowThreshold(child)
      const collapsedChild = this.collapseVertically(child)
      if (this.layoutNodes.size === this.minimumNodes) {
        break
      }
      if (belowThreshold && !this.topLayoutNodes.has(layoutNode)) {
        const hostNode = combined || layoutNode
        const squashNode = collapsedChild || child
        // Do not vertically-collapse children which have at least one long grandchild
        const longGrandChild = squashNode.children.map(childId => this.layoutNodes.get(childId)).find(child => !this.isCollapsible(child))
        if (longGrandChild) {
          continue
        }
        combined = this.combinelayoutNodes(hostNode, squashNode)
      }
    }
    return combined
  }
  combinelayoutNodes (hostNode, squashNode) {
    if ([hostNode.node.constructor.name, squashNode.node.constructor.name].includes('ShortcutNode')) {
      return
    }
    if (!this.isCollapsible(hostNode) || !this.isCollapsible(squashNode)) {
      return
    }

    // hostNode is expected to be either direct parent or direct sibling of squashNode
    const parent = hostNode.parent
    if (hostNode.parent !== squashNode.parent && squashNode.parent !== hostNode) {
      const toContext = layoutNode => ((layoutNode.parent && toContext(layoutNode.parent) + '=>') || '') + layoutNode.id
      const context = toContext(hostNode) + ' + ' + toContext(squashNode)
      throw new Error('Cannot combine nodes - clump/stem mismatch: ' + context)
    }
    const children = _.difference(hostNode.children.concat(squashNode.children), [squashNode.id])

    const hostNodes = hostNode.collapsedNodes ? [...hostNode.collapsedNodes] : [hostNode]
    const squashNodes = squashNode.collapsedNodes ? [...squashNode.collapsedNodes] : [squashNode]
    const collapsed = new CollapsedLayoutNode(hostNodes.concat(squashNodes), parent, children)

    // Update refs
    ejectLayoutNode(parent, hostNode)
    ejectLayoutNode(parent, squashNode)
    insertLayoutNode(this.layoutNodes, parent, collapsed)
    // Update indices
    this.layoutNodes.set(collapsed.id, collapsed)
    this.layoutNodes.delete(hostNode.id)
    this.layoutNodes.delete(squashNode.id)

    return collapsed
  }
  isBelowThreshold (layoutNode) {
    return layoutNode.getTotalTime() * this.scale.sizeIndependentScale < 10
  }
  isCollapsible (layoutNode) {
    return layoutNode.collapsedNodes || this.isBelowThreshold(layoutNode)
  }
}

function ejectLayoutNode (parent, layoutNode) {
  layoutNode.parent = null
  layoutNode.children = []
  // TODO: optimize .children and .collapsedNodes using Set?
  // (faster at lookup and removal, but slower at addition and iteration - https://stackoverflow.com/a/39010462)
  const index = parent.children.indexOf(layoutNode.id)
  if (index !== -1) parent.children.splice(index, 1)
}

function insertLayoutNode (layoutNodes, parent, layoutNode) {
  parent.children.unshift(layoutNode.id)
  for (let i = 0; i < layoutNode.children.length; ++i) {
    const child = layoutNodes.get(layoutNode.children[i])
    child.parent = layoutNode
  }
}

module.exports = CollapsedLayout

},{"../data/data-node.js":3,"./layout-node.js":26,"lodash/difference":140}],24:[function(require,module,exports){
'use strict'

class Connection {
  constructor (sourceLayoutNode, targetLayoutNode, scale) {
    // TODO: rename sourceNode everywhere to avoid confusion with DataNode->SourceNode class
    this.sourceId = sourceLayoutNode.id
    this.sourceLayoutNode = sourceLayoutNode
    this.sourceNode = sourceLayoutNode.node.shortcutTo || sourceLayoutNode.node

    this.targetId = targetLayoutNode.id
    this.targetLayoutNode = targetLayoutNode
    this.targetNode = targetLayoutNode.node.shortcutTo || targetLayoutNode.node

    this.scale = scale

    // TODO: remove this completely once all branches are merged and released
    // this.targetNode.connectionFromParent = this
  }

  // Avoid duplication of values so stats can be swtiched/recalculated with settings
  // If recalculating these proves to be a performance problem, consider caching values
  getSourceRadius () { return this.scale.getCircleRadius(this.sourceLayoutNode.getWithinTime()) }
  getTargetRadius () { return this.scale.getCircleRadius(this.targetLayoutNode.getWithinTime()) }
  getVisibleLineLength () { return this.scale.getLineLength(this.targetLayoutNode.getBetweenTime()) }
  getDistanceBetweenCenters () {
    return this.getSourceRadius() +
      this.getVisibleLineLength() +
      this.getTargetRadius() +
      // Leave a gap at both ends so any text labels are readable
      // Only one lineWidth because it increases distance by half a line width at each end
      this.scale.settings.labelMinimumSpace * 2 + this.scale.settings.lineWidth
  }
}

module.exports = Connection

},{}],25:[function(require,module,exports){
'use strict'

const Layout = require('./layout.js')

function generateLayout (dataSet, settings) {
  const layout = new Layout({ dataNodes: [...dataSet.clusterNodes.values()] }, settings)

  // This can be interrupted in tests etc
  layout.generate(settings)
  return layout
}

module.exports = generateLayout

},{"./layout.js":27}],26:[function(require,module,exports){
'use strict'

const { validateNumber } = require('../validation.js')
const { ArtificialNode } = require('../data/data-node.js')

class LayoutNode {
  constructor (node, parent) {
    this.id = node.id
    this.node = node
    this.stem = null
    this.position = null
    this.inboundConnection = null
    this.parent = parent
    this.children = []
  }
  getBetweenTime () {
    return this.node.getBetweenTime()
  }
  getWithinTime () {
    return this.node.getWithinTime()
  }
  getTotalTime () {
    return this.getBetweenTime() + this.getWithinTime()
  }
  validateStat (...args) {
    return this.node.validateStat(...args)
  }
}

class CollapsedLayoutNode {
  constructor (layoutNodes, parent, children) {
    const dataNodes = layoutNodes.sort((a, b) => a.id - b.id).map(layoutNode => layoutNode.node)
    this.id = 'clump:' + dataNodes.map(dataNode => dataNode.uid).join(',')
    this.collapsedNodes = layoutNodes
    this.parent = parent
    this.children = children || []

    for (let i = 0; i < layoutNodes.length; ++i) {
      const layoutNode = layoutNodes[i]
      const node = layoutNode.node
      if (!this.node) {
        this.node = new ArtificialNode({
          id: this.id,
          nodeType: node.constructor.name
        }, node, dataNodes)
      }
      if (node.nodes) this.node.applyAggregateNodes(node.nodes)
      this.node.applyMark(node.mark)
      this.node.aggregateStats(node)
      this.applyDecimals(node)
    }
  }
  getBetweenTime () {
    return this.collapsedNodes.reduce((total, layoutNode) => total + layoutNode.node.getBetweenTime(), 0)
  }
  getWithinTime () {
    return this.collapsedNodes.reduce((total, layoutNode) => total + layoutNode.node.getWithinTime(), 0)
  }
  getSyncTime () {
    return this.collapsedNodes.reduce((total, layoutNode) => total + layoutNode.node.getSyncTime(), 0)
  }
  getAsyncTime () {
    return this.collapsedNodes.reduce((total, layoutNode) => total + layoutNode.node.getAsyncTime(), 0)
  }
  getTotalTime () {
    return this.getBetweenTime() + this.getWithinTime()
  }
  validateStat (num, statType = '', aboveZero = false) {
    const targetDescription = `For ${this.constructor.name} ${this.id}${statType ? ` ${statType}` : ''}`
    return validateNumber(num, targetDescription, aboveZero)
  }
  applyDecimals (otherNode) {
    this.node.aggregateDecimals(otherNode, 'type', 'between')
    this.node.aggregateDecimals(otherNode, 'type', 'within')
    this.node.aggregateDecimals(otherNode, 'typeCategory', 'between')
    this.node.aggregateDecimals(otherNode, 'typeCategory', 'within')
    this.node.aggregateDecimals(otherNode, 'party', 'between')
    this.node.aggregateDecimals(otherNode, 'party', 'within')
  }
}

module.exports = {
  LayoutNode,
  CollapsedLayoutNode
}

},{"../data/data-node.js":3,"../validation.js":34}],27:[function(require,module,exports){
'use strict'

const Stem = require('./stems.js')
const Connection = require('./connections.js')
const Scale = require('./scale.js')
const Positioning = require('./positioning.js')
const { ShortcutNode } = require('../data/data-node.js')
const { LayoutNode } = require('./layout-node.js')
const CollapsedLayout = require('./collapsed-layout.js')

class Layout {
  constructor ({ dataNodes, connection, parentLayout }, settings) {
    const defaultSettings = {
      collapseNodes: false,
      svgDistanceFromEdge: 40,
      lineWidth: 2,
      labelMinimumSpace: 10,
      svgWidth: 750,
      svgHeight: 750,
      shortcutLength: 60,
      allowStretch: true
    }
    this.settings = Object.assign(defaultSettings, settings)
    this.initialInput = {
      dataNodes,
      connection,
      parentLayout
    }

    this.parentLayout = parentLayout || null

    this.scale = new Scale(this)
    this.positioning = new Positioning(this)

    this.connections = []
    this.connectionsByTargetId = new Map()

    this.rootLayoutNode = null

    if (connection) {
      this.prepareSublayoutNodes(dataNodes, connection)
    } else {
      this.prepareLayoutNodes(dataNodes)
    }
  }

  // Note: This currently does not support missing midpoints (implicit children)
  prepareLayoutNodes (dataNodes) {
    this.layoutNodes = new Map()

    const dataNodeById = new Map(dataNodes.map(node => [node.id, node]))
    const createLayoutNode = (nodeId, parentLayoutNode) => {
      const dataNode = dataNodeById.get(nodeId)
      if (!dataNode || this.layoutNodes.has(dataNode.id)) return

      const layoutNode = new LayoutNode(dataNode, parentLayoutNode)
      this.layoutNodes.set(dataNode.id, layoutNode)

      if (dataNode.isRoot) this.rootLayoutNode = this.layoutNodes.get(dataNode.id)

      if (parentLayoutNode) parentLayoutNode.children.push(dataNode.id)
      for (let i = 0; i < dataNode.children.length; ++i) {
        const childNodeId = dataNode.children[i]
        createLayoutNode(childNodeId, layoutNode)
      }
    }
    const topDataNodes = dataNodes.filter(dataNode => !dataNode.parent)
    for (let i = 0; i < topDataNodes.length; ++i) {
      const topDataNode = topDataNodes[i]
      createLayoutNode(topDataNode.id)
    }
  }

  // For layouts inside a clusterNode, rather than layouts of all cluterNodes
  prepareSublayoutNodes (dataNodes, connection) {
    // This sublayout is of nodes within targetNode. Some have parents within sourceNode

    const includedIds = new Set(dataNodes.map(dataNode => dataNode.id))

    const shortcutToSource = !connection.sourceNode ? null : new ShortcutNode({
      id: `shortcut:${connection.sourceNode.id}`,
      isRoot: true,
      children: []
    }, connection.sourceNode)

    if (shortcutToSource) {
      dataNodes.unshift(shortcutToSource)
    }

    for (let i = 0; i < dataNodes.length; ++i) {
      const dataNode = dataNodes[i]

      if (shortcutToSource && !includedIds.has(dataNode.parentId)) {
        shortcutToSource.children.push(dataNode.id)
      }
      for (let i = 0; i < dataNode.children.length; ++i) {
        const childId = dataNode.children[i]
        // If this child is in another cluster, add a dummy leaf node -> clickable link/shortcut to that cluster
        if (!dataNodes.some(dataNode => dataNode.id === childId)) {
          const childNode = dataNode.getSameType(childId)

          // If we're inside a cluster of clusters, childNode might be on the top level of clusters
          const shortcutNode = new ShortcutNode({
            id: childId, // id in another cluster - can't be duplicated in this layout, is in parent's children array
            children: [],
            parentId: dataNode.id
          // Use the name, mark etc of the clusterNode the target node is inside
          }, childNode.clusterId ? childNode : childNode.clusterNode)

          dataNodes.push(shortcutNode)
        }
      }
    }
    this.prepareLayoutNodes(dataNodes)
  }

  // Returns a containing layoutNode. If dataNode can't be found at this level and
  // `recursive` is true, it walks up parent layouts and re-tries; else it returns false
  findDataNode (dataNode, recursive = false) {
    const nodeId = dataNode.id
    const layoutNodes = this.layoutNodes
    if (layoutNodes.has(nodeId) && layoutNodes.get(nodeId).node.uid === dataNode.uid) {
      return this.layoutNodes.get(nodeId)
    }
    if (dataNode.contents) {
      return this.findDataNode(dataNode.contents[0])
    }
    return this.findCollapsedNode(dataNode, recursive)
  }

  findCollapsedNode (dataNode, recursive = false) {
    for (const layoutNode of this.layoutNodes.values()) {
      if (layoutNode.collapsedNodes && layoutNode.collapsedNodes.some((subLayoutNode) => subLayoutNode.node.uid === dataNode.uid)) {
        return layoutNode
      }
    }
    return recursive && this.parentLayout ? this.parentLayout.findDataNode(dataNode, recursive) : false
  }

  findAggregateNode (aggregateNode, recursive = false) {
    return this.findDataNode(aggregateNode, recursive) || this.findDataNode(aggregateNode.clusterNode, recursive)
  }

  processBetweenData (generateConnections = true) {
    // If re-doing after scale, remove old pre-scale pre-collapse stems
    if (generateConnections) this.layoutNodes.forEach(layoutNode => { layoutNode.stem = null })

    const layoutNodesIterator = this.layoutNodes.values()
    for (let i = 0; i < this.layoutNodes.size; ++i) {
      const layoutNode = layoutNodesIterator.next().value

      // Missing ancestor stems are created within descendents' new Stem, so stem might already exist
      if (!layoutNode.stem) layoutNode.stem = new Stem(this, layoutNode)

      if (generateConnections && layoutNode.parent) {
        const connection = new Connection(layoutNode.parent, layoutNode, this.scale)
        this.connectionsByTargetId.set(layoutNode.id, connection)
        this.connections.push(connection)
        layoutNode.inboundConnection = connection
      }
    }
  }

  processHierarchy (settingsOverride) {
    const settings = settingsOverride || this.settings

    this.processBetweenData(!settings.collapseNodes)
    this.updateScale()
    if (settings.collapseNodes) {
      this.collapseNodes()
      this.processBetweenData(true)
      this.updateScale()
    }
  }

  updateScale () {
    this.scale.calculatePreScaleFactor()
    this.updateStems()
    this.scale.calculateScaleFactor()
    this.updateStems()
  }

  updateStems () {
    const layoutNodesIterator = this.layoutNodes.values()
    for (let i = 0; i < this.layoutNodes.size; ++i) {
      const layoutNode = layoutNodesIterator.next().value
      layoutNode.stem.update()
    }
  }

  createSubLayout (layoutNode, settings) {
    const subsetInView = pickDataSubset(layoutNode)

    if (subsetInView.length) {
      const connection = layoutNode.inboundConnection

      const sublayout = new Layout({
        parentLayout: this,
        dataNodes: subsetInView,
        connection: connection || { targetNode: layoutNode.node }
      }, settings)
      return sublayout
    }
  }

  // Like DataSet.processData(), call it seperately in main flow so that can be interupted in tests etc
  generate (settingsOverride) {
    this.processHierarchy(settingsOverride)
    this.positioning.formClumpPyramid()
    this.positioning.placeNodes()
  }

  collapseNodes () {
    const collapsedLayout = new CollapsedLayout(this)
    this.layoutNodes = collapsedLayout.layoutNodes
  }
}

function pickDataSubset (layoutNode) {
  // Use collapsed
  if (layoutNode.collapsedNodes) {
    return layoutNode.collapsedNodes.map(hiddenLayoutNode => hiddenLayoutNode.node)
  }
  // Use aggregates
  return [...layoutNode.node.nodes.values()]
}

module.exports = Layout

},{"../data/data-node.js":3,"./collapsed-layout.js":23,"./connections.js":24,"./layout-node.js":26,"./positioning.js":30,"./scale.js":31,"./stems.js":32}],28:[function(require,module,exports){
'use strict'

const { isNumber } = require('../validation.js')

class LineCoordinates {
  constructor (args) {
    // Args must contain x1, y1, and either x2 & x2 or length & angle (radians or degrees)
    if (!args || !isNumber(args.x1) || !isNumber(args.y1)) {
      const argsMessage = args ? `{ x1: ${args.x1}, y1: ${args.y1} }` : 'no args object'
      throw new Error(`x1 and y1 of new LineCoordinates must be numeric: ${argsMessage}`)
    }

    this.x1 = args.x1
    this.y1 = args.y1

    if (isNumber(args.x2) && isNumber(args.y2)) {
      this.applyRadians(LineCoordinates.radiansFromXY(args))
      this.x2 = args.x2
      this.y2 = args.y2
      this.length = LineCoordinates.lineLengthFromXY(args)
    } else if (isNumber(args.length)) {
      this.length = args.length
      if (isNumber(args.radians)) {
        this.applyRadians(args.radians)
      } else if (isNumber(args.degrees)) {
        this.applyDegrees(args.degrees)
      } else {
        throw new Error(`Radians or degrees of new LineCoordinates must be numeric: { radians: ${args.radians}, degrees: ${args.degrees} }`)
      }
      const { x2, y2 } = LineCoordinates.lineEndpoints(this)
      this.x2 = x2
      this.y2 = y2
    } else {
      throw new Error(`Length or (x2, y2) of new LineCoordinates must be numeric: { length: ${args.length}, x2: ${args.x2}, y2: ${args.y2} }`)
    }
  }

  applyRadians (radians) {
    this.radians = radians
    const degrees = LineCoordinates.radiansToDegrees(radians)
    this.degrees = LineCoordinates.enforceDegreesRange(degrees)
  }
  applyDegrees (degrees) {
    this.degrees = LineCoordinates.enforceDegreesRange(degrees)
    this.radians = LineCoordinates.degreesToRadians(degrees)
  }

  preventBackwardsAngle (parentDegrees, acceptableRange) {
    const isAngleBackwards = this.isAngleBackwards(parentDegrees, acceptableRange)

    if (isAngleBackwards) {
      this.applyDegrees(isAngleBackwards.acceptableAngle)
      const { x2, y2 } = LineCoordinates.lineEndpoints(this)

      this.x2 = x2
      this.y2 = y2
    }
  }

  isAngleBackwards (parentDegrees = 90, acceptableRange = 90) {
    // If this is the line from B to C, parentDegrees is the angle from A towards B
    // Make sure this line isn't pointing back towards A
    const degrees = LineCoordinates.radiansToDegrees(this.radians)
    const relativeDegrees = LineCoordinates.enforceDegreesRange(degrees - parentDegrees)

    if (relativeDegrees > acceptableRange) {
      // This relative angle is too high
      return {
        problem: '>',
        acceptableAngle: LineCoordinates.enforceDegreesRange(acceptableRange + parentDegrees)
      }
    }
    if (relativeDegrees < 0 - acceptableRange) {
      // This relative angle is too low
      return {
        problem: '<',
        acceptableAngle: LineCoordinates.enforceDegreesRange(0 - acceptableRange + parentDegrees)
      }
    }
    // This relative angle is fine
    return false
  }

  pointAtLength (length) {
    const vector = { x: this.x2 - this.x1, y: this.y2 - this.y1 }
    const normalizedLength = length / this.length
    return { x: this.x1 + (vector.x * normalizedLength), y: this.y1 + (vector.y * normalizedLength) }
  }

  static lineEndpoints ({length, radians, x1, y1}) {
    return {
      x2: x1 + length * Math.cos(radians),
      y2: y1 + length * Math.sin(radians)
    }
  }

  static lineLengthFromXY ({x1, y1, x2, y2}) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
  }

  static radiansFromXY ({x1, y1, x2, y2}) {
    return Math.atan2(y2 - y1, x2 - x1)
  }

  static radiansToDegrees (radians) {
    return radians * 57.2957795
  }

  static degreesToRadians (degrees) {
    return degrees / 57.2957795
  }

  static reverseRadians (radians) {
    return radians - Math.PI
  }

  static enforceDegreesRange (degrees) {
    // Keep angles between -180 and 180
    if (degrees < -180) degrees += 360
    if (degrees > 180) degrees -= 360
    return degrees
  }

  static radiusFromCircumference (circumference) {
    // Each pixel of colour must represent the same amount of time, else
    // the dataviz is misleading. So, circles representing delays within a
    // node are stroked, not filled, and data is linked to circumference,
    // not area, so lines and circles are equivalent
    return circumference / (2 * Math.PI)
  }
}

module.exports = LineCoordinates

},{"../validation.js":34}],29:[function(require,module,exports){
'use strict'

const LineCoordinates = require('./line-coordinates.js')
const { validateNumber } = require('../validation.js')

class NodeAllocation {
  constructor (layout, layoutNodes, coordinatesFn = NodeAllocation.threeSided) {
    this.layout = layout
    this.layoutNodes = layoutNodes
    this.leaves = new Map()
    this.midPoints = new Map()
    this.roots = new Map()
    for (const layoutNode of layoutNodes.values()) {
      const position = {
        units: 0,
        offset: null, // Leaves only (null for midpoints)
        x: 0,
        y: 0,
        segment: null // Leaves only, used for debugging
      }
      layoutNode.position = position
      const category = layoutNode.stem.leaves.ids.length ? 'midPoints' : 'leaves'
      this[category].set(layoutNode.id, layoutNode)
    }
    for (const midPoint of this.midPoints.values()) {
      if (!midPoint.parent) {
        this.roots.set(midPoint.id, midPoint)
      }
    }
    const coordinates = coordinatesFn(this.layout, this.roots)
    this.initializeSegments(coordinates)
  }
  initializeSegments (coordinates) {
    this.segments = []
    this.total1DSpaceAvailable = 0
    for (const coordinate of coordinates) {
      const label = coordinate.label
      const line = new LineCoordinates(coordinate)
      const tail = this.segments[this.segments.length - 1]
      const begin = coordinate === coordinates[0] ? 0 : tail.end
      this.segments.push(new LinearSpaceSegment(label, begin, line))
      this.total1DSpaceAvailable += line.length
    }
  }
  static threeSided (layout, roots) {
    const { svgWidth, svgDistanceFromEdge } = layout.settings
    const { finalSvgHeight } = layout.scale
    const toLargestDiameter = (largest, rootLayoutNode) => Math.max(largest, rootLayoutNode.stem.scaled.ownDiameter)
    const largestRootDiameter = [...roots.values()].reduce(toLargestDiameter, 0)
    const topOffset = svgDistanceFromEdge + Math.max(finalSvgHeight * 0.2, largestRootDiameter)
    const borders = {
      top: validateNumber(topOffset),
      bottom: validateNumber(finalSvgHeight - svgDistanceFromEdge),
      left: validateNumber(svgDistanceFromEdge),
      right: validateNumber(svgWidth - svgDistanceFromEdge)
    }
    const coordinates = [
      { label: 'LHS', x1: borders.left, y1: borders.top, x2: borders.left, y2: borders.bottom },
      { label: 'BOT', x1: borders.left, y1: borders.bottom, x2: borders.right, y2: borders.bottom },
      { label: 'RHS', x1: borders.right, y1: borders.bottom, x2: borders.right, y2: borders.top }
    ]
    return coordinates
  }
  process (placementMode = NodeAllocation.placementMode.LENGTH_CONSTRAINED) {
    this.convertTotalStemLengthsToUnits()
    this.calculate1DLinearOffsets()
    this.calculate2DLeafCoordinates()
    this.calculate2DMidpointCoordinates(placementMode)
    if (placementMode === NodeAllocation.placementMode.LENGTH_CONSTRAINED) {
      this.constrain2DLeafCoordinates()
    }
  }
  // Hierarchical (by depth) comparison narrows clumps internally and expands space between clumps.
  // This has proved to be more visually appealing than result of flat comparison.
  // Example:
  // 1.2     100
  // 1.3.4.5 500
  // 1.3.6.7 900
  // 1.3.6.8 500
  // In flat longest leaf comparison set: [2, 5, 7, 8], leaf 2 is allocated 5% of space (100/2000)
  // In longest leaf comparison set at depth=1: [2, 3], leaf 2 is allocated 10% of space (100/1000)
  // Subsets of nodes may not have a common ancestor and therefore cannot recursively traverse the tree root-up
  // Thus traversing depth by depth
  convertTotalStemLengthsToUnits () {
    // Traverse the hierarchies and index Clumps at each level
    const hierarchyLevels = new Map()
    for (const leafLayoutNode of this.leaves.values()) {
      const leaf = leafLayoutNode
      const stem = leafLayoutNode.stem

      const leafTotalStemLength = stem.lengths.prescaledTotal
      // Include ancestor Clumps
      const ancestors = stem.ancestors.ids.length ? stem.ancestors.ids : [leaf.parentId]
      for (let depth in ancestors) {
        depth = parseInt(depth)
        if (!hierarchyLevels.has(depth)) {
          hierarchyLevels.set(depth, new HierarchyLevel(depth))
        }
        const hierarchyLevel = hierarchyLevels.get(depth)
        // Form Clump for given node at given level
        const ancestorId = ancestors[depth]
        if (!this.midPoints.get(ancestorId)) {
          continue
        }
        const ancestorAtDepthLayoutNode = this.layoutNodes.get(ancestorId)
        const ancestorAtDepth = ancestorAtDepthLayoutNode && ancestorAtDepthLayoutNode
        if (!hierarchyLevel.clumps.has(ancestorAtDepth)) {
          const previousHierarchyLevel = hierarchyLevels.get(depth - 1)
          const parentClump = previousHierarchyLevel ? previousHierarchyLevel.clumps.get(ancestorAtDepthLayoutNode.parent && ancestorAtDepthLayoutNode.parent) : null
          const ancestorClump = new Clump(ancestorAtDepthLayoutNode, parentClump, leafTotalStemLength)
          hierarchyLevel.clumps.set(ancestorAtDepth, ancestorClump)
          if (parentClump) {
            parentClump.childClumps.set(ancestorAtDepth, ancestorClump)
          }
          continue
        }
        // Determine which leaf is longest in the Clump
        const clumpAtDepth = hierarchyLevel.clumps.get(ancestorAtDepth)
        if (!clumpAtDepth.longestLeafLength || leafTotalStemLength > clumpAtDepth.longestLeafLength) {
          clumpAtDepth.longestLeafLength = leafTotalStemLength
        }
      }
      // Include leaf Clump
      const leafDepth = ancestors.length
      if (!hierarchyLevels.has(leafDepth)) {
        hierarchyLevels.set(leafDepth, new HierarchyLevel(leafDepth))
      }
      const hierarchyLevel = hierarchyLevels.get(leafDepth)
      const previousHierarchyLevel = hierarchyLevels.get(leafDepth - 1)
      const parentClump = previousHierarchyLevel.clumps.get(leafLayoutNode.parent && leafLayoutNode.parent)
      const leafClump = new Clump(leafLayoutNode, parentClump, leafTotalStemLength)
      hierarchyLevel.clumps.set(leaf, leafClump)
      if (parentClump) {
        parentClump.childClumps.set(leaf, leafClump)
      }
    }

    // Determine portion of space to allocate for each node
    for (let depth = 0; depth < hierarchyLevels.size; ++depth) {
      const hierarchyLevel = hierarchyLevels.get(depth)
      hierarchyLevel.sumLongestLeafLengths()
      for (const clumpAtDepth of hierarchyLevel.clumps.values()) {
        const parentUnits = clumpAtDepth.parentClump ? clumpAtDepth.parentClump.units : 1
        const proportionFactor = clumpAtDepth.parentClump ? clumpAtDepth.parentClump.getTotalChildrenLongestLeafLength() : hierarchyLevel.longestLeafLengthSum

        // In some cases e.g. root node, these can be 0; if so, set as 1. TODO: investigate this further
        const clumpUnits = ((parentUnits * clumpAtDepth.longestLeafLength) || 1) / (proportionFactor || 1)
        clumpAtDepth.units = clumpAtDepth.layoutNode.validateStat(clumpUnits)
        clumpAtDepth.layoutNode.position.units = clumpUnits
      }
    }
  }
  calculate1DLinearOffsets () {
    let currentSegment = this.segments[0]
    let currentBlock = null
    const intoOrder = (leafA, leafB) => this.layout.positioning.order.indexOf(leafA.id) - this.layout.positioning.order.indexOf(leafB.id)
    const arrangedLeaves = [...this.leaves.values()].sort(intoOrder) // To be optimized (unnecessary iterations)
    for (const leafLayoutNode of arrangedLeaves) {
      const position = leafLayoutNode.position
      const allocatedSpace = position.units * this.total1DSpaceAvailable
      currentBlock = new SpaceBlock(leafLayoutNode, currentBlock ? currentBlock.end : currentSegment.begin, allocatedSpace)
      position.offset = currentBlock.center
      currentSegment = this.segments.find(segment => segment.contains1DPoint(currentBlock.center))
      currentSegment.blocks.push(currentBlock)
      currentBlock.layoutNode.position.segment = currentSegment.label
    }
  }
  calculate2DLeafCoordinates () {
    for (const segment of this.segments) {
      for (const block of segment.blocks) {
        const position = block.layoutNode.position
        const relativeOffset = block.center - segment.begin
        const { x, y } = segment.translate1DPointTo2D(relativeOffset)

        position.x = block.layoutNode.validateStat(x, 'x position')
        position.y = block.layoutNode.validateStat(y, 'y position')
      }
    }
  }
  constrain2DLeafCoordinates () {
    for (const layoutNode of this.leaves.values()) {
      const leaf = layoutNode
      const stem = layoutNode.stem

      const parentStem = layoutNode.parent && layoutNode.parent.stem
      const parentDiameter = parentStem ? parentStem.scaled.ownDiameter : 0
      const position = layoutNode.position
      const parentPosition = layoutNode.parent ? layoutNode.parent.position : this.getRootPosition(parentDiameter)
      const line = new LineCoordinates({ x1: parentPosition.x, y1: parentPosition.y, x2: position.x, y2: position.y })
      const parentRadius = parentDiameter / 2
      const thisRadius = stem.scaled.ownDiameter / 2
      const lineLength = stem.scaled.ownBetween
      const leafLength = layoutNode.node.constructor.name === 'ShortcutNode' ? this.layout.settings.shortcutLength : (lineLength + thisRadius)
      const { x, y } = line.pointAtLength(parentRadius + leafLength)

      position.x = leaf.validateStat(x)
      position.y = leaf.validateStat(y)
    }
  }
  calculate2DMidpointCoordinates (placementMode) {
    for (const layoutNode of this.midPoints.values()) {
      const midPoint = layoutNode // TODO: make naming consistent
      const stem = layoutNode.stem
      const position = layoutNode.position

      if (!layoutNode.parent) {
        // TODO: spread out x's to declutter multiple top-level nodes, preferably using this.layout.positioning.order
        const rootPosition = this.getRootPosition(stem.scaled.ownDiameter)
        position.x = midPoint.validateStat(rootPosition.x)
        position.y = midPoint.validateStat(rootPosition.y + (layoutNode.node.constructor.name === 'ShortcutNode' ? this.layout.settings.shortcutLength : 0))
        continue
      }
      const parentStem = layoutNode.parent.stem
      const parentNode = layoutNode.parent
      const parentPosition = layoutNode.parent.position

      const ownLeavesInSubset = stem.leaves.ids.filter(leafId => this.leaves.has(leafId))
      const leafPositions = ownLeavesInSubset.map(leafId => this.layoutNodes.get(leafId).position)
      midPoint.validateStat(leafPositions.length, `leafCenter division`, { aboveZero: true })
      const leafCenter = leafPositions.reduce((combinedPosition, nodePosition) => {
        return {
          x: midPoint.validateStat(combinedPosition.x + nodePosition.x),
          y: midPoint.validateStat(combinedPosition.y + nodePosition.y)
        }
      }, { x: 0, y: 0 })

      leafCenter.x /= leafPositions.length
      leafCenter.y /= leafPositions.length

      switch (placementMode) {
        case NodeAllocation.placementMode.LENGTH_CONSTRAINED:
          const line = new LineCoordinates({ x1: parentPosition.x, y1: parentPosition.y, x2: leafCenter.x, y2: leafCenter.y })

          const parentRadius = parentNode.validateStat(parentStem.scaled.ownDiameter / 2)
          const thisRadius = midPoint.validateStat(stem.scaled.ownDiameter / 2)
          const lineLength = midPoint.validateStat(stem.scaled.ownBetween)

          const { x, y } = line.pointAtLength(parentRadius + lineLength + thisRadius)
          position.x = midPoint.validateStat(x)
          position.y = midPoint.validateStat(y)
          break
        case NodeAllocation.placementMode.SPIDER:
          const combinedCenter = {
            x: leafCenter.x + parentPosition.x / 2,
            y: leafCenter.y + parentPosition.y / 2
          }
          position.x = midPoint.validateStat(combinedCenter.x)
          position.y = midPoint.validateStat(combinedCenter.y)
          break
      }
    }
  }
  getRootPosition (nodeDiameter) {
    return {
      x: this.layout.settings.svgWidth / 2,
      y: this.layout.settings.svgDistanceFromEdge + (nodeDiameter / 2)
    }
  }
  static get placementMode () {
    return {
      LENGTH_CONSTRAINED: 'LENGTH_CONSTRAINED',
      SPIDER: 'SPIDER'
    }
  }
}

class HierarchyLevel {
  constructor (depth) {
    this.depth = depth
    this.clumps = new Map()
  }
  sumLongestLeafLengths () {
    this.longestLeafLengthSum = [...this.clumps.values()].reduce((total, clump) => total + clump.longestLeafLength, 0)
  }
}

class Clump {
  constructor (layoutNode, parentClump, longestLeafLength) {
    this.parentClump = parentClump
    this.layoutNode = layoutNode
    this.childClumps = new Map()
    this.longestLeafLength = longestLeafLength
  }
  getTotalChildrenLongestLeafLength () {
    return [...this.childClumps.values()].reduce((total, clump) => total + clump.longestLeafLength, 0)
  }
}

class LinearSpaceSegment {
  constructor (label, begin, line) {
    this.label = label
    this.line = line
    this.begin = begin
    this.end = begin + line.length
    // SpaceBlock may span across multiple LinearSpaceSegments, however it will belong to the one which contains its center
    this.blocks = []
  }
  contains1DPoint (offset) {
    return this.begin < offset && offset < this.end
  }
  translate1DPointTo2D (relativeOffset) {
    return this.line.pointAtLength(relativeOffset)
  }
}

class SpaceBlock {
  constructor (layoutNode, begin, length) {
    this.layoutNode = layoutNode
    this.begin = begin
    this.end = begin + length
    this.center = begin + (length / 2)
  }
}

// TODO: debugInspect moreless like this:
//  LHS                            BOT                    RHS
// [------.---------.------------][-----------.---------][--------------.-------.------]
//        9         12                        15                        10      8

// 1.9                 LHS (o=250, u=0.43, x=0, y=250)      [------.----
// 1.2.3.4.12          LHS (o=600, u=0.43, x=0, y=600)      -----.-------
// 1.2.3.5.11.13.14.15 BOT (o=1500, u=0.43, x=500, y=1000)  -----][-----------.---------][-------
// 1.2.6.7.10          RHS (o=1750, u=0.43, x=1000, y=750)  -------.----
// 1.8                 RHS (o=2750, u=0.43, x=1000, y=250)  ---.------]

module.exports = NodeAllocation

},{"../validation.js":34,"./line-coordinates.js":28}],30:[function(require,module,exports){
'use strict'

const { pickLeavesByLongest } = require('./stems.js')
const NodeAllocation = require('./node-allocation.js')
const arrayFlatten = require('array-flatten')

// Modified version of https://gist.github.com/samgiles/762ee337dff48623e729#gistcomment-2128332

class Positioning {
  constructor (layout) {
    this.layout = layout
    this.layoutNodes = null // defined later
  }
  formClumpPyramid () {
    this.layoutNodes = this.layout.layoutNodes
    const leavesByLongest = pickLeavesByLongest(this.layoutNodes)
    const clumpPyramid = new ClumpPyramid(this.layout)
    clumpPyramid.setLeaves(leavesByLongest)
    this.order = clumpPyramid.order
  }
  placeNodes () {
    this.nodeAllocation = new NodeAllocation(this.layout, this.layoutNodes)
    this.nodeAllocation.process()
  }
  debugInspect () {
    const intoOrder = (leafA, leafB) => this.order.indexOf(leafA.id) - this.order.indexOf(leafB.id)
    const leavesByLongest = pickLeavesByLongest(this.layoutNodes)
    const longestStemLength = leavesByLongest[0].stem.pickMostAccurateTotal()
    const arrangedLeaves = leavesByLongest.sort(intoOrder)

    const rows = arrangedLeaves.map(leaf => {
      const magnitude = leaf.stem.pickMostAccurateTotal()
      const units = parseInt((magnitude / longestStemLength) * 50)
      const lengthAsDashes = new Array(units).fill('-').join('')
      const nodeGenealogy = [...leaf.stem.ancestors.ids, leaf.id].join('.')
      return [nodeGenealogy, lengthAsDashes + ' ' + magnitude]
    })

    const toLongest = (a, b) => a > b ? a : b
    const longestGenealogy = rows.map(row => row[0].length).reduce(toLongest, 0)
    const normalize = row => {
      while (row[0].length < longestGenealogy) {
        row[0] += ' '
      }
    }
    rows.forEach(normalize)
    rows.unshift([])

    return rows.map(row => row.join('  ')).join('\n')
  }
}

// ClumpPyramid heuristics:
// Clump orientation | Children insertion when siblings are present
// __________________|______________________________________________
// lhs               | ascending => unshift (the / of /^\)
// centered          | nextPyramidSide => unshift || push (the ^ of /^\)
// rhs               | descending => push (the \ of /^\)
// * Leaves are inserted longest to shortest (as per totalStemLength)
// * Leaves' ancestors are represented by Clumps (arrays [] of Leaves and other Clumps) and are created if missing (in ground-up order, from Root to leaf's parent, i.e. R->C->C->C->C->L converts to [[[[[L]]]]])
// * Clumps within Clumps count as siblings to inserted leaves (i.e. quite common to see [L, [L], L])

// Simplified example:
// Leaves with ids 1..8, sorted by totalStemLength, result in following tree:
//
//           1
//           |     2
//  3        C  4  | 5
//   \       | /   |/
// 6 _\    8 |/    C_ 7
//     C    \C    /
//      \    |   /
//       C   C  C
//        \  | /
//         C C/
//          \|
//           C
//           |
//           R

// Walkthrough:
// Leaf | Missing ancestor Clumps formed | Clump orientation   | Leaf insertion factor
// _____|________________________________|_____________________|____________________________________
// 1    | 6 (including Root)             | first=center        | longest=first=n/a
// 2    | 2                              | nextPyramidSide=rhs | first-in-clump=n/a
// 3    | 3                              | nextPyramidSide=lhs | first-in-clump=n/a
// 4    | - (parent clump exists)        | center (^)          | clumpSlant=nextPyramidSide=push (not first-in-clump because sibling clump is present)
// 5    | - (parent clump exists)        | rhs (\)             | clumpSlant=push
// 6    | - (parent clump exists)        | lhs (/)             | clumpSlant=unshift
// 7    | - (parent clump exists)        | rhs (\)             | clumpSlant=push
// 8    | - (parent clump exists)        | center (^)          | clumpSlant=nextPyramidSide=unshift
class ClumpPyramid {
  constructor (layout) {
    this.layout = layout
    this.layoutNodes = layout.layoutNodes
    this.insertionSideToOrientation = {
      'unshift': 'lhs',
      'push': 'rhs'
    }
    this.orientationToInsertionSide = {
      'lhs': 'unshift',
      'rhs': 'push'
    }
    this.emptyPyramid()
  }
  emptyPyramid () {
    this.leavesOnSide = {
      lhs: 0,
      center: 0,
      rhs: 0
    }

    this.clumpById = {}
    this.leadingLeaf = null
  }
  nextPyramidSide () {
    return this.leavesOnSide.lhs < this.leavesOnSide.rhs ? 'unshift' : 'push'
  }
  setAncestorClump (leaf, ancestorId, insertAtSide) {
    if (this.clumpById[ancestorId]) {
      return
    }

    // Create non-existent ancestor clump
    this.clumpById[ancestorId] = []

    // Assign orientation in relation to centered leaf
    // Note - first (i.e. longest) leaf will always be centered, thus its ancestor clumps have center orientation
    const clumpOrientation = leaf === this.leadingLeaf ? 'center' : this.insertionSideToOrientation[insertAtSide]
    this.clumpById[ancestorId].orientation = clumpOrientation

    // Insert newly-created ancestor clump into its direct-parent clump
    // Note - root will have no parent
    const ancestor = this.layoutNodes.get(ancestorId)
    const ancestorParent = ancestor ? ancestor.parent : null
    if (ancestorParent) {
      this.clumpById[ancestorParent.id][insertAtSide](this.clumpById[ancestorId])
    }
  }
  setLeaves (leavesByLongest) {
    const roots = []
    this.emptyPyramid()
    this.leadingLeaf = leavesByLongest[0]
    for (const layoutNodeLeaf of leavesByLongest) {
      let insertAtSide = this.nextPyramidSide()
      const leaf = layoutNodeLeaf
      const stem = layoutNodeLeaf.stem

      const ancestors = stem.ancestors.ids.length ? stem.ancestors.ids : [leaf.parentId]
      for (const ancestorId of ancestors) {
        this.setAncestorClump(leaf, ancestorId, insertAtSide)
        const ancestorLayoutNode = this.layoutNodes.get(ancestorId)
        if (!ancestorLayoutNode || !ancestorLayoutNode.parent) {
          if (!roots.includes(ancestorId)) {
            roots[insertAtSide](ancestorId)
          }
        }
      }

      const parentClump = this.clumpById[layoutNodeLeaf.parent ? layoutNodeLeaf.parent.id : 0]

      // TODO: find out why at aggregateNode level sometimes there's a node on its own like this
      if (!parentClump) continue

      if (parentClump.orientation !== 'center') {
        insertAtSide = this.orientationToInsertionSide[parentClump.orientation]
      }
      parentClump[insertAtSide](leaf.id)
      const updateSide = leaf === this.leadingLeaf ? 'center' : this.insertionSideToOrientation[insertAtSide]
      this.leavesOnSide[updateSide]++
    }

    this.order = arrayFlatten(roots.map(rootId => arrayFlatten(this.clumpById[rootId])))
  }
}

module.exports = Positioning

},{"./node-allocation.js":29,"./stems.js":32,"array-flatten":35}],31:[function(require,module,exports){
'use strict'

const { radiusFromCircumference } = require('./line-coordinates.js')
const { pickLeavesByLongest } = require('./stems.js')
const { validateNumber } = require('../validation.js')

class Scale {
  constructor (layout) {
    this.layout = layout
    this.layoutNodes = null // set later
  }
  // This simplified computation is necessary to ensure correct leaves order
  // when calculating the final scale factor
  calculatePreScaleFactor () {
    this.layoutNodes = this.layout.layoutNodes
    const toLongest = (longest, layoutNode) => Math.max(longest, layoutNode.stem.lengths.scalable)
    const longest = [...this.layoutNodes.values()].reduce(toLongest, 0)
    this.prescaleFactor = this.layout.settings.svgHeight / (longest || 1)
  }
  calculateScaleFactor () {
    // Called after new Scale() because it reads stem length data based on logic
    // using the spacing/width settings and radiusFromCircumference()
    let leavesByShortest = pickLeavesByLongest(this.layoutNodes, this).reverse()
    // Zero-sized nodes do not affect the shape and therefore should not be accounted
    leavesByShortest = leavesByShortest.filter(leaf => leaf.stem.lengths.scalable > 0)

    const longest = leavesByShortest.length && leavesByShortest[leavesByShortest.length - 1].stem.lengths
    const shortest = leavesByShortest.length && leavesByShortest[0].stem.lengths
    // TODO: Consider using in-between computed values for quantiles, like d3 does
    const q50 = leavesByShortest.length && leavesByShortest[Math.floor(leavesByShortest.length / 2)].stem.lengths
    const q25 = leavesByShortest.length && leavesByShortest[Math.floor(leavesByShortest.length / 4)].stem.lengths
    const q75 = leavesByShortest.length && leavesByShortest[Math.floor(3 * leavesByShortest.length / 4)].stem.lengths

    const nodesCount = this.layoutNodes.size

    const {
      svgWidth,
      svgDistanceFromEdge,
      allowStretch
    } = this.layout.settings

    // Reduces scrolling on tiny sublayouts. Only needed on scroll view mode
    const svgHeightAdjustment = nodesCount < 4 && allowStretch ? 0.2 * (nodesCount + 1) : 1
    const svgHeight = this.layout.settings.svgHeight * svgHeightAdjustment

    const availableHeight = svgHeight - (svgDistanceFromEdge * 2)
    const availableWidth = (svgWidth / 2) - svgDistanceFromEdge
    const availableShortest = Math.min(availableWidth, svgHeight * 0.71 - svgDistanceFromEdge)

    // Only stretch if we're in scroll mode and it's a complex profile with many nodes that needs more space
    const stretchedHeight = svgHeight * (nodesCount > 6 && allowStretch ? 1.5 : 1)
    const availableStretchedHeight = stretchedHeight - (svgDistanceFromEdge * 2)

    const longestStretched = new ScaleWeight('longest', leavesByShortest[leavesByShortest.length - 1], availableStretchedHeight, longest.scalable, longest.absolute)
    // Note - assumptions below depend on ClumpPyramid Positioning
    const scalesBySignificance = [
      // Longest should be no more (and ideally no less) than 1.5 height
      longestStretched,
      // Shortest should be no more (and ideally no less) than half width
      new ScaleWeight('shortest', leavesByShortest[0], availableWidth, shortest.scalable, shortest.absolute),
      // q50 is usually angled like the hypotenuse in a 1-1-sqrt(2) triangle, which indicates 1/sqrt(2)=~71% of line length in width is ideal
      new ScaleWeight('q50 1-1-sqrt(2) triangle', leavesByShortest[Math.floor(leavesByShortest.length / 2)], availableShortest, q50.scalable * 0.71, q50.absolute),
      // q25 is usually angled like the hypotenuse in a 4-3-5 triangle, which indicates 80% of line length in width is ideal
      new ScaleWeight('q25 4-3-5 triangle', leavesByShortest[Math.floor(leavesByShortest.length / 4)], availableWidth, q25.scalable * 0.8, q25.absolute),
      // q75 is usually angled like the hypotenuse in a 3-4-5 triangle, which indicates 60% of line length in width is ideal
      new ScaleWeight('q75 3-4-5 triangle', leavesByShortest[Math.floor(3 * leavesByShortest.length / 4)], availableWidth, q75.scalable * 0.6, q75.absolute)
    ]
    const smallestSide = availableWidth < availableHeight ? availableWidth : availableHeight
    const largestDiameterNode = [...this.layoutNodes.values()].sort((a, b) => b.stem.raw.ownDiameter - a.stem.raw.ownDiameter)[0]
    // For diagram clarity, largest circle should be no more (and ideally no less) than quater of the viewport
    const diameterClamp = new ScaleWeight('diameter clamp', largestDiameterNode, smallestSide / 2, largestDiameterNode.stem.raw.ownDiameter, 0)
    const longestConstrained = new ScaleWeight('longest constrained', leavesByShortest[leavesByShortest.length - 1], availableHeight, longest.scalable, longest.absolute)

    const accountedScales = [longestConstrained, ...scalesBySignificance.slice(0, leavesByShortest.length), diameterClamp]
    if (leavesByShortest.length) {
      this.scalesBySmallest = accountedScales.sort((a, b) => a.weight - b.weight)
      this.decisiveWeight = this.scalesBySmallest[0]
      if (this.scalesBySmallest[0] === longestConstrained && this.scalesBySmallest[1] === longestStretched) {
        this.decisiveWeight = longestStretched
      }
    } else {
      this.decisiveWeight = new ScaleWeight('zero-sized view', null, availableShortest, 0, 0, 0)
      this.scalesBySmallest = [this.decisiveWeight]
    }
    this.scaleFactor = validateNumber(this.decisiveWeight.weight)

    // For collapsing nodes, we need a threshold that is independent of the SVG size so that
    // the same data gives the same number of visible nodes if presented in different sized SVG
    // 680 is based on common window sizes and tested to give reasonable collapsing
    const sizeIndependentWeight = new ScaleWeight('size-independent', null, 680, longestStretched.scalableToContain, longestStretched.absoluteToContain)
    this.sizeIndependentScale = sizeIndependentWeight.weight

    const isLineTooLong = this.decisiveWeight === longestStretched
    const isDiameterAboveHeight = this.decisiveWeight === diameterClamp && smallestSide === availableHeight
    const shouldStretchHeight = isLineTooLong || isDiameterAboveHeight
    this.finalSvgHeight = shouldStretchHeight ? stretchedHeight : svgHeight
  }

  getLineLength (dataValue) {
    return dataValue * this.scaleFactor
  }

  getCircleRadius (dataValue) {
    const equivalentLineLength = this.getLineLength(dataValue)
    return radiusFromCircumference(equivalentLineLength)
  }
}

class ScaleWeight {
  constructor (category, node, available, scalableToContain, absoluteToContain) {
    this.category = category
    this.node = node
    this.available = available
    this.absoluteToContain = absoluteToContain
    this.scalableToContain = scalableToContain
    this.weight = (available - absoluteToContain) / scalableToContain
    if (this.weight < 0 && absoluteToContain > 0) {
      this.weight = available / absoluteToContain
    }
    // If node has zero size, weight will be Infinity
    // Default to stretching to available (or absolute if it's more than available)
    if (!Number.isFinite(this.weight)) this.weight = available > absoluteToContain ? available - absoluteToContain : absoluteToContain
  }
}

module.exports = Scale

},{"../validation.js":34,"./line-coordinates.js":28,"./stems.js":32}],32:[function(require,module,exports){
'use strict'

const { radiusFromCircumference } = require('./line-coordinates.js')
const { validateNumber } = require('../validation.js')

function getNodeAncestorIds (parent) {
  return parent ? [...parent.stem.ancestors.ids, parent.id] : []
}

class Stem {
  constructor (layout, layoutNode) {
    this.layout = layout

    // Ancestor stem stats must be calculated before descendent stem stats
    const parent = layoutNode.parent
    if (parent && !parent.stem) {
      parent.stem = new Stem(layout, parent)
    }

    this.ancestors = {
      totalBetween: 0,
      totalDiameter: 0,
      ids: getNodeAncestorIds(parent)
    }
    this.leaves = {
      ids: []
    }
    this.raw = {
      ownBetween: layoutNode.getBetweenTime(),
      ownDiameter: radiusFromCircumference(layoutNode.getWithinTime()) * 2
    }

    this.shortcutsInStem = layoutNode.node.constructor.name === 'ShortcutNode' ? 1 : 0

    for (const ancestorId of this.ancestors.ids) {
      const ancestor = layout.layoutNodes.get(ancestorId)
      const ancestorStem = ancestor.stem

      if (ancestor.node.constructor.name === 'ShortcutNode') this.shortcutsInStem++

      this.ancestors.totalBetween += ancestorStem.raw.ownBetween
      this.ancestors.totalDiameter += ancestorStem.raw.ownDiameter
      if (!layoutNode.children.length) {
        ancestorStem.leaves.ids.push(layoutNode.id)
      }
    }
    this.update()
  }
  update () {
    if (!this.lengths) {
      const {
        labelMinimumSpace,
        lineWidth,
        shortcutLength
      } = this.layout.settings

      const absolute = ((labelMinimumSpace * 2) + lineWidth) * this.ancestors.ids.length + shortcutLength * this.shortcutsInStem
      const scalable = this.ancestors.totalBetween + this.ancestors.totalDiameter + this.raw.ownBetween + this.raw.ownDiameter
      this.lengths = {
        absolute: validateNumber(absolute, this.getValidationMessage()),
        scalable: validateNumber(scalable, this.getValidationMessage()),
        rawTotal: absolute + scalable
      }
    }
    if (this.layout.scale.prescaleFactor) {
      this.lengths.prescaledTotal = this.lengths.absolute + (this.lengths.scalable * this.layout.scale.prescaleFactor)
    }
    if (this.layout.scale.scaleFactor) {
      const { settings, scale } = this.layout
      this.scaled = {
        ownBetween: (settings.labelMinimumSpace * 2) + settings.lineWidth + scale.getLineLength(this.raw.ownBetween),
        ownDiameter: scale.getLineLength(this.raw.ownDiameter)
      }
      this.lengths.scaledTotal = this.lengths.absolute + (this.lengths.scalable * this.layout.scale.scaleFactor)
    }
  }
  getValidationMessage () {
    return `for stem with:
    ancestor ids [${this.ancestors.ids.join(', ')}], length ${this.ancestors.ids.length});
    leaves [${this.leaves.ids.join(', ')}], length ${this.leaves.ids.length};
    `
  }
  pickMostAccurateTotal () {
    const { rawTotal, prescaledTotal, scaledTotal } = this.lengths
    return scaledTotal || prescaledTotal || rawTotal
  }
  static pickLeavesByLongest (layoutNodes) {
    const byLongest = (leafA, leafB) => leafB.stem.pickMostAccurateTotal() - leafA.stem.pickMostAccurateTotal()
    const byLeafOnly = layoutNode => !layoutNode.children.length
    return [...layoutNodes.values()].filter(byLeafOnly).sort(byLongest)
  }
}

module.exports = Stem

},{"../validation.js":34,"./line-coordinates.js":28}],33:[function(require,module,exports){
'use strict'

const drawOuterUI = require('./draw/index.js')

// Currently no headless browser testing, only test browser-independent logic
/* istanbul ignore next */
const ui = drawOuterUI()

// TODO: look into moving the below into a Worker to do in parrallel with drawOuterUI
setTimeout(() => {
  const loadData = require('./data/index.js')
  const generateLayout = require('./layout/index.js')

  const dataSet = loadData({ debugMode: false })
  if (dataSet.settings.debugMode) {
    window.data = dataSet
    console.log('data is exposed on window.data')
  }

  const layout = generateLayout(dataSet, Object.assign({ collapseNodes: true }, ui.getSettingsForLayout()))
  if (dataSet.settings.debugMode) {
    window.layout = layout
    console.log('layout is exposed on window.layout')
  }

  /* istanbul ignore next */
  ui.setData(layout, dataSet)

  /* istanbul ignore next */
  ui.complete()
})

},{"./data/index.js":6,"./draw/index.js":14,"./layout/index.js":25}],34:[function(require,module,exports){
'use strict'

// Helper functions for validating data

function isNumber (num) {
  return typeof num === 'number' && !Number.isNaN(num)
}
function validateKey (key, validOptions) {
  if (typeof key !== 'string' || validOptions.indexOf(key) === -1) {
    throw new Error(`Invalid key "${key}" passed, valid types are: ${validOptions.join(', ')}`)
  }
}
function validateNumber (num, targetDescription = '', conditions = {}) {
  const defaultConditions = {
    isFinite: true,
    aboveZero: false
  }
  conditions = Object.assign(defaultConditions, conditions)
  if (targetDescription) targetDescription += ': '

  if (!isNumber(num)) {
    throw new Error(`${targetDescription}Got ${typeof num} ${num}, must be a number`)
  }
  if (conditions.aboveZero && num <= 0) {
    throw new Error(`${targetDescription}Got ${num}, must be > 0`)
  }
  if (conditions.isFinite && !isFinite(num)) {
    throw new Error(`${targetDescription}Got ${num}, must be finite`)
  }

  return num
}

// Currently only used in /draw code
/* istanbul ignore next */
function uniqueMapKey (key, map) {
  let counter = 0
  function keyWithIncrement () {
    counter++
    const newKey = `${key}_${counter}`
    return map.has(newKey) ? keyWithIncrement() : newKey
  }
  return map.has(key) ? keyWithIncrement(key + '_') : key
}

module.exports = {
  isNumber,
  validateKey,
  validateNumber,
  uniqueMapKey
}

},{}],35:[function(require,module,exports){
'use strict'

/**
 * Expose `arrayFlatten`.
 */
module.exports = arrayFlatten

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth (array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever (array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i]

    if (Array.isArray(value)) {
      flattenForever(value, result)
    } else {
      result.push(value)
    }
  }

  return result
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten (array, depth) {
  if (depth == null) {
    return flattenForever(array, [])
  }

  return flattenWithDepth(array, [], depth)
}

},{}],36:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],37:[function(require,module,exports){

},{}],38:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],39:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":36,"ieee754":75}],40:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],41:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":77}],42:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.2.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector = function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

var pairs = function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
};

function pair(a, b) {
  return [a, b];
}

var cross = function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var number = function(x) {
  return x === null ? NaN : +x;
};

var variance = function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
};

var deviation = function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
};

var extent = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
};

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

var constant = function(x) {
  return function() {
    return x;
  };
};

var identity = function(x) {
  return x;
};

var range = function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

var ticks = function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
};

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

var sturges = function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram = function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
};

var quantile = function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
};

var freedmanDiaconis = function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

var scott = function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
};

var max = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
};

var mean = function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
};

var median = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
};

var merge = function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
};

var min = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
};

var permute = function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
};

var scan = function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
};

var shuffle = function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
};

var sum = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
};

var transpose = function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
};

function length(d) {
  return d.length;
}

var zip = function() {
  return transpose(arguments);
};

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],43:[function(require,module,exports){
// https://d3js.org/d3-axis/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

var identity = function(x) {
  return x;
};

var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],44:[function(require,module,exports){
// https://d3js.org/d3-brush/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

var BrushEvent = function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
};

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

var MODE_DRAG = {name: "drag"};
var MODE_SPACE = {name: "space"};
var MODE_HANDLE = {name: "handle"};
var MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

var brush = function() {
  return brush$1(XY);
};

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = d3Selection.mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = d3Selection.mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":48,"d3-drag":49,"d3-interpolate":56,"d3-selection":64,"d3-transition":69}],45:[function(require,module,exports){
// https://d3js.org/d3-chord/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-path')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
  (factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Array,d3Path) { 'use strict';

var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

var chord = function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = d3Array.range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3Array.range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
};

var slice = Array.prototype.slice;

var constant = function(x) {
  return function() {
    return x;
  };
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

var ribbon = function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = d3Path.path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
};

exports.chord = chord;
exports.ribbon = ribbon;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":42,"d3-path":57}],46:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],47:[function(require,module,exports){
// https://d3js.org/d3-color/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var define = function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],48:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],49:[function(require,module,exports){
// https://d3js.org/d3-drag/ Version 1.2.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Selection) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

var nodrag = function(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
};

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant = function(x) {
  return function() {
    return x;
  };
};

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch$$1) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch$$1;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

var drag = function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
};

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":48,"d3-selection":64}],50:[function(require,module,exports){
// https://d3js.org/d3-dsv/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

var dsv = function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
};

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

exports.dsvFormat = dsv;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],51:[function(require,module,exports){
// https://d3js.org/d3-ease/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI;
var halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeLinear = linear;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],52:[function(require,module,exports){
// https://d3js.org/d3-force/ Version 1.1.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

var center = function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var jiggle = function() {
  return (Math.random() - 0.5) * 1e-6;
};

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

var collide = function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  return force;
};

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

var link = function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = d3Collection.map(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
  };

  return force;
};

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));

var simulation = function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = d3Collection.map(),
      stepper = d3Timer.timer(step),
      event = d3Dispatch.dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
};

var manyBody = function() {
  var nodes,
      node,
      alpha,
      strength = constant(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
};

var radial = function(radius, x, y) {
  var nodes,
      strength = constant(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
};

var x$2 = function(x) {
  var strength = constant(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
  };

  return force;
};

var y$2 = function(y) {
  var strength = constant(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
  };

  return force;
};

exports.forceCenter = center;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-collection":46,"d3-dispatch":48,"d3-quadtree":59,"d3-timer":68}],53:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.2.2. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
var formatDecimal = function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
};

var exponent = function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
};

var formatDefault = function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
};

var prefixExponent;

var formatPrefixAuto = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

var identity = function(x) {
  return x;
};

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

var formatLocale = function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

var precisionFixed = function(step) {
  return Math.max(0, -exponent(Math.abs(step)));
};

var precisionPrefix = function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
};

var precisionRound = function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
};

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],54:[function(require,module,exports){
// https://d3js.org/d3-geo/ Version 1.9.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

var adder = function() {
  return new Adder;
};

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;

var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

function noop() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

var geoStream = function(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
};

var areaRingSum = adder();

var areaSum = adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;

var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos(phi),
      sinPhi = sin(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos(adLambda),
      v = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

var area = function(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
};

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda00$1;
var phi00$1;
var p0;
var deltaSum = adder();
var ranges;
var range$1;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    range$1[0] = lambda0$1, range$1[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign$$1 = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign$$1,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range$1[0] = lambda0$1, range$1[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
  range$1[0] = lambda0$1, range$1[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range$$1, x) {
  return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
}

var bounds = function(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range$1 = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
};

var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00$2;
var phi00$2;
var x0;
var y0;
var z0; // previous point

var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

var centroid = function(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var compose = function(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
};

function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi),
      sinDeltaPhi = sin(deltaPhi),
      cosDeltaGamma = cos(deltaGamma),
      sinDeltaGamma = sin(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

var rotation = function(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
};

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius),
      sinRadius = sin(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

var circle = function() {
  var center = constant([0, 0]),
      radius = constant(90),
      precision = constant(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
  };

  return circle;
};

var clipBuffer = function() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
};

var pointEqual = function(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
};

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
var clipRejoin = function(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
};

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum = adder();

var polygonContains = function(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [sin(lambda), -cos(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin(phi0),
        cosPhi0 = cos(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin(phi1),
          cosPhi1 = cos(phi1),
          delta = lambda1 - lambda0,
          sign$$1 = delta >= 0 ? 1 : -1,
          absDelta = sign$$1 * delta,
          antimeridian = absDelta > pi,
          k = sinPhi0 * sinPhi1;

      sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign$$1 * tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
};

var clip = function(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = d3Array.merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
};

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon
      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

var clipCircle = function(radius) {
  var cr = cos(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi) < epsilon,
        meridian = polar || delta < epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
};

var clipLine = function(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
};

var clipMax = 1e9;
var clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = d3Array.merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

var extent = function() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
};

var lengthSum = adder();
var lambda0$2;
var sinPhi0$1;
var cosPhi0$1;

var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin(phi),
      cosPhi = cos(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos(delta),
      sinDelta = sin(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

var length = function(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
};

var coordinates = [null, null];
var object = {type: "LineString", coordinates: coordinates};

var distance = function(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length(object);
};

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

var contains = function(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
};

function graticuleX(y0, y1, dy) {
  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}

function graticule10() {
  return graticule()();
}

var interpolate = function(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos(y0),
      sy0 = sin(y0),
      cy1 = cos(y1),
      sy1 = sin(y1),
      kx0 = cy0 * cos(x0),
      ky0 = cy0 * sin(x0),
      kx1 = cy1 * cos(x1),
      ky1 = cy1 * sin(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin(d);

  var interpolate = d ? function(t) {
    var B = sin(t *= d) / k,
        A = sin(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
};

var identity = function(x) {
  return x;
};

var areaSum$1 = adder();
var areaRingSum$1 = adder();
var x00;
var y00;
var x0$1;
var y0$1;

var areaStream$1 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity;
var y0$2 = x0$2;
var x1 = -x0$2;
var y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0;
var Y0$1 = 0;
var Z0$1 = 0;
var X1$1 = 0;
var Y1$1 = 0;
var Z1$1 = 0;
var X2$1 = 0;
var Y2$1 = 0;
var Z2$1 = 0;
var x00$1;
var y00$1;
var x0$3;
var y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

var lengthSum$1 = adder();
var lengthRing;
var x00$2;
var y00$2;
var x0$4;
var y0$4;

var lengthStream$1 = {
  point: noop,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

var index = function(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
};

var transform = function(methods) {
  return {
    stream: transformer(methods)
  };
};

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16;
var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

var resample = function(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
};

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = clipAntimeridian, // clip angle
      x0 = null, y0, x1, y1, postclip = identity, // clip extent
      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * radians, point[1] * radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin(y)) / n;
    return [r * sin(x *= n), r0 - r * cos(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

var conicEqualArea = function() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
};

var albers = function() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
};

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
var albersUsa = function() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
};

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x),
        cy = cos(y),
        k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin(c),
        cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

var azimuthalEqualArea = function() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
};

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

var azimuthalEquidistant = function() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
};

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

var mercator = function() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau);
};

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
    var r = f / pow(tany(y), n);
    return [r * sin(n * x), f - r * cos(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
  };

  return project;
}

var conicConformal = function() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
};

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

var equirectangular = function() {
  return projection(equirectangularRaw)
      .scale(152.63);
};

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin(nx), g - gy * cos(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

var conicEquidistant = function() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
};

function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

var gnomonic = function() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
};

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

var identity$1 = function() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
};

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

var naturalEarth1 = function() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
};

function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

var orthographic = function() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon);
};

function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

var stereographic = function() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
};

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

var transverseMercator = function() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
};

exports.geoArea = area;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent;
exports.geoClipRectangle = clipRectangle;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoInterpolate = interpolate;
exports.geoLength = length;
exports.geoPath = index;
exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoIdentity = identity$1;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;
exports.geoRotation = rotation;
exports.geoStream = geoStream;
exports.geoTransform = transform;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":42}],55:[function(require,module,exports){
// https://d3js.org/d3-hierarchy/ Version 1.1.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

var cluster = function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
};

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

var node_count = function() {
  return this.eachAfter(count);
};

var node_each = function(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
};

var node_eachBefore = function(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
};

var node_eachAfter = function(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

var node_sum = function(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
};

var node_sort = function(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
};

var node_path = function(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
};

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

var node_ancestors = function() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
};

var node_descendants = function() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
};

var node_leaves = function() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
};

var node_links = function() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
};

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

var enclose = function(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
};

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

var siblings = function(circles) {
  packEnclose(circles);
  return circles;
};

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

var constant = function(x) {
  return function() {
    return x;
  };
};

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

var index = function() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
};

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

var roundNode = function(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
};

var treemapDice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
};

var partition = function() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
};

var keyPrefix = "$";
var preroot = {depth: -1};
var ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

var stratify = function() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
};

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
var tree = function() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
};

var treemapSlice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
};

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}))(phi);

var index$1 = function() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
};

var binary = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
};

var sliceDice = function(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
};

var resquarify = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}))(phi);

exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$1;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],56:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ Version 1.1.6. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

var basis$1 = function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var basisClosed = function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var constant = function(x) {
  return function() {
    return x;
  };
};

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb$1 = ((function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
}))(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = d3Color.rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var array = function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
};

var date = function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
};

var number = function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
};

var object = function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

var string = function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
};

var value = function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
      : b instanceof d3Color.color ? rgb$1
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
};

var round = function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
var zoom = function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
};

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

var quantize = function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
};

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb$1;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":47}],57:[function(require,module,exports){
// https://d3js.org/d3-path/ Version 1.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {}

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],58:[function(require,module,exports){
// https://d3js.org/d3-polygon/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var area = function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
};

var centroid = function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
};

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
var cross = function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
};

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

var hull = function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
};

var contains = function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
};

var length = function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
};

exports.polygonArea = area;
exports.polygonCentroid = centroid;
exports.polygonHull = hull;
exports.polygonContains = contains;
exports.polygonLength = length;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],59:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var tree_add = function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
};

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

var tree_cover = function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
};

var tree_data = function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
};

var tree_extent = function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
};

var Quad = function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};

var tree_find = function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
};

var tree_remove = function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
};

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

var tree_root = function() {
  return this._root;
};

var tree_size = function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
};

var tree_visit = function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
};

var tree_visitAfter = function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
};

function defaultX(d) {
  return d[0];
}

var tree_x = function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
};

function defaultY(d) {
  return d[1];
}

var tree_y = function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
};

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],60:[function(require,module,exports){
// https://d3js.org/d3-queue/ Version 3.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = [].slice;

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = slice.call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try { start(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}

exports.queue = queue;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],61:[function(require,module,exports){
// https://d3js.org/d3-random/ Version 1.1.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var defaultSource = function() {
  return Math.random();
};

var uniform = ((function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
}))(defaultSource);

var normal = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
}))(defaultSource);

var logNormal = ((function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
}))(defaultSource);

var irwinHall = ((function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
}))(defaultSource);

var bates = ((function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
}))(defaultSource);

var exponential = ((function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
}))(defaultSource);

exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],62:[function(require,module,exports){
'use strict';

var XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;

Object.defineProperty(exports, '__esModule', { value: true });

var d3Collection = require('d3-collection');
var d3Dispatch = require('d3-dispatch');
var d3Dsv = require('d3-dsv');

var request = function(url, callback) {
  var request,
      event = d3Dispatch.dispatch("beforesend", "progress", "load", "error"),
      mimeType,
      headers = d3Collection.map(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", …).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", …).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
};

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}

var type = function(defaultMimeType, response) {
  return function(url, callback) {
    var r = request(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
};

var html = type("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

var json = type("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
});

var text = type("text/plain", function(xhr) {
  return xhr.responseText;
});

var xml = type("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

var dsv = function(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = request(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
};

function responseOf(parse, row) {
  return function(request$$1) {
    return parse(request$$1.responseText, row);
  };
}

var csv = dsv("text/csv", d3Dsv.csvParse);

var tsv = dsv("text/tab-separated-values", d3Dsv.tsvParse);

exports.request = request;
exports.html = html;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.csv = csv;
exports.tsv = tsv;

},{"d3-collection":46,"d3-dispatch":48,"d3-dsv":50,"xmlhttprequest":180}],63:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

var array = Array.prototype;

var map$1 = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal(range$$1) {
  var index = d3Collection.map(),
      domain = [],
      unknown = implicit;

  range$$1 = range$$1 == null ? [] : slice.call(range$$1);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range$$1[(i - 1) % range$$1.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), scale) : range$$1.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range$$1)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var constant = function(x) {
  return function() {
    return x;
  };
};

var number = function(x) {
  return +x;
};

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range$$1, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range$$1, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range$$1.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range$$1 = range$$1.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range$$1 = unit,
      interpolate$$1 = d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = slice.call(_), interpolate$$1 = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

var tickFormat = function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
};

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

var nice = function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
};

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range$$1 = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range$$1.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range$$1[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range$$1 = [0, 1];

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range$$1 = slice.call(_)).length - 1, rescale()) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range$$1);
  };

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range$$1 = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format$$1) {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format$$1(".%L"),
      formatSecond = format$$1(":%S"),
      formatMinute = format$$1("%I:%M"),
      formatHour = format$$1("%I %p"),
      formatDay = format$$1("%a %d"),
      formatWeek = format$$1("%b %d"),
      formatMonth = format$$1("%B"),
      formatYear = format$$1("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format$$1(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format$$1));
  };

  return scale;
}

var time = function() {
  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
};

var utcTime = function() {
  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
};

var colors = function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
};

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var rainbow = d3Color.cubehelix();

var rainbow$1 = function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
};

function ramp(range$$1) {
  var n = range$$1.length;
  return function(t) {
    return range$$1[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile$1;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.schemeCategory10 = category10;
exports.schemeCategory20b = category20b;
exports.schemeCategory20c = category20c;
exports.schemeCategory20 = category20;
exports.interpolateCubehelixDefault = cubehelix$1;
exports.interpolateRainbow = rainbow$1;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.scaleSequential = sequential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":42,"d3-collection":46,"d3-color":47,"d3-format":53,"d3-interpolate":56,"d3-time":67,"d3-time-format":66}],64:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.3.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.create = create;
exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],65:[function(require,module,exports){
// https://d3js.org/d3-shape/ Version 1.2.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Path) { 'use strict';

var constant = function(x) {
  return function constant() {
    return x;
  };
};

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc = function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi) {
          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
};

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

var curveLinear = function(context) {
  return new Linear(context);
};

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

var line = function() {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area = function() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity = function(d) {
  return d;
};

var pie = function() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

var lineRadial$1 = function() {
  return lineRadial(line().curve(curveRadialLinear));
};

var areaRadial = function() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
};

var pointRadial = function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
};

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x,
      y$$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810;
var kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5;
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

var symbol = function() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop = function() {};

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis = function(context) {
  return new Basis(context);
};

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed = function(context) {
  return new BasisClosed(context);
};

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen = function(context) {
  return new BasisOpen(context);
};

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
}))(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

var linearClosed = function(context) {
  return new LinearClosed(context);
};

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

var natural = function(context) {
  return new Natural(context);
};

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

var step = function(context) {
  return new Step(context, 0.5);
};

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

var none = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$1 = function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
};

function stackValue(d, key) {
  return d[key];
}

var stack = function() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
};

var expand = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
};

var diverging = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
};

var silhouette = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
};

var wiggle = function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
};

var ascending = function(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
};

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

var descending$1 = function(series) {
  return ascending(series).reverse();
};

var insideOut = function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse = function(series) {
  return none$1(series).reverse();
};

exports.arc = arc;
exports.area = area;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-path":57}],66:[function(require,module,exports){
// https://d3js.org/d3-time-format/ Version 2.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;





defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":67}],67:[function(require,module,exports){
// https://d3js.org/d3-time/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date;
var t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],68:[function(require,module,exports){
// https://d3js.org/d3-timer/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1000;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

var timeout$1 = function(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
};

var interval$1 = function(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
};

exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],69:[function(require,module,exports){
// https://d3js.org/d3-transition/ Version 1.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Dispatch,d3Timer,d3Interpolate,d3Color,d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

var schedule = function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
};

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

var interrupt = function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
};

var selection_interrupt = function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
};

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

var transition_tween = function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
};

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

var interpolate = function(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
};

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

var transition_attr = function(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
};

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

var transition_attrTween = function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
};

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

var transition_delay = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
};

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

var transition_duration = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
};

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

var transition_ease = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
};

var transition_filter = function(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
};

var transition_merge = function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
};

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

var transition_on = function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
};

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

var transition_remove = function() {
  return this.on("end.remove", removeFunction(this._id));
};

var transition_select = function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
};

var transition_selectAll = function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
};

var Selection = d3Selection.selection.prototype.constructor;

var transition_selection = function() {
  return new Selection(this._groups, this._parents);
};

function styleRemove(name, interpolate$$1) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

var transition_style = function(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, tweenValue(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
};

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

var transition_styleTween = function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
};

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

var transition_text = function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
};

var transition_transition = function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
};

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

var selection_transition = function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
};

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

var active = function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
};

exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":47,"d3-dispatch":48,"d3-ease":51,"d3-interpolate":56,"d3-selection":64,"d3-timer":68}],70:[function(require,module,exports){
// https://d3js.org/d3-voronoi/ Version 1.1.2. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

var voronoi = function() {
  var x$$1 = x,
      y$$1 = y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
};

exports.voronoi = voronoi;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],71:[function(require,module,exports){
// https://d3js.org/d3-zoom/ Version 1.7.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform$$1, extent, translateExtent) {
  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];
  return transform$$1.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

var zoom = function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      gestures = [],
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform$$1) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform$$1);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform$$1 === "function" ? transform$$1.apply(this, arguments) : transform$$1)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform$$1, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);
  }

  function translate(transform$$1, p0, p1) {
    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;
    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform$$1, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform$$1 === "function" ? transform$$1.apply(that, args) : transform$$1,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform$$1) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform$$1.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform$$1.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform$$1.invert(this.touch1[0]);
      this.that.__zoom = transform$$1;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        started,
        n = touches.length, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
};

exports.zoom = zoom;
exports.zoomTransform = transform;
exports.zoomIdentity = identity;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":48,"d3-drag":49,"d3-interpolate":56,"d3-selection":64,"d3-transition":69}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var d3Axis = require('d3-axis');
var d3Brush = require('d3-brush');
var d3Chord = require('d3-chord');
var d3Collection = require('d3-collection');
var d3Color = require('d3-color');
var d3Dispatch = require('d3-dispatch');
var d3Drag = require('d3-drag');
var d3Dsv = require('d3-dsv');
var d3Ease = require('d3-ease');
var d3Force = require('d3-force');
var d3Format = require('d3-format');
var d3Geo = require('d3-geo');
var d3Hierarchy = require('d3-hierarchy');
var d3Interpolate = require('d3-interpolate');
var d3Path = require('d3-path');
var d3Polygon = require('d3-polygon');
var d3Quadtree = require('d3-quadtree');
var d3Queue = require('d3-queue');
var d3Random = require('d3-random');
var d3Request = require('d3-request');
var d3Scale = require('d3-scale');
var d3Selection = require('d3-selection');
var d3Shape = require('d3-shape');
var d3Time = require('d3-time');
var d3TimeFormat = require('d3-time-format');
var d3Timer = require('d3-timer');
var d3Transition = require('d3-transition');
var d3Voronoi = require('d3-voronoi');
var d3Zoom = require('d3-zoom');

var version = "4.13.0";

exports.version = version;
Object.keys(d3Array).forEach(function (key) { exports[key] = d3Array[key]; });
Object.keys(d3Axis).forEach(function (key) { exports[key] = d3Axis[key]; });
Object.keys(d3Brush).forEach(function (key) { exports[key] = d3Brush[key]; });
Object.keys(d3Chord).forEach(function (key) { exports[key] = d3Chord[key]; });
Object.keys(d3Collection).forEach(function (key) { exports[key] = d3Collection[key]; });
Object.keys(d3Color).forEach(function (key) { exports[key] = d3Color[key]; });
Object.keys(d3Dispatch).forEach(function (key) { exports[key] = d3Dispatch[key]; });
Object.keys(d3Drag).forEach(function (key) { exports[key] = d3Drag[key]; });
Object.keys(d3Dsv).forEach(function (key) { exports[key] = d3Dsv[key]; });
Object.keys(d3Ease).forEach(function (key) { exports[key] = d3Ease[key]; });
Object.keys(d3Force).forEach(function (key) { exports[key] = d3Force[key]; });
Object.keys(d3Format).forEach(function (key) { exports[key] = d3Format[key]; });
Object.keys(d3Geo).forEach(function (key) { exports[key] = d3Geo[key]; });
Object.keys(d3Hierarchy).forEach(function (key) { exports[key] = d3Hierarchy[key]; });
Object.keys(d3Interpolate).forEach(function (key) { exports[key] = d3Interpolate[key]; });
Object.keys(d3Path).forEach(function (key) { exports[key] = d3Path[key]; });
Object.keys(d3Polygon).forEach(function (key) { exports[key] = d3Polygon[key]; });
Object.keys(d3Quadtree).forEach(function (key) { exports[key] = d3Quadtree[key]; });
Object.keys(d3Queue).forEach(function (key) { exports[key] = d3Queue[key]; });
Object.keys(d3Random).forEach(function (key) { exports[key] = d3Random[key]; });
Object.keys(d3Request).forEach(function (key) { exports[key] = d3Request[key]; });
Object.keys(d3Scale).forEach(function (key) { exports[key] = d3Scale[key]; });
Object.keys(d3Selection).forEach(function (key) { exports[key] = d3Selection[key]; });
Object.keys(d3Shape).forEach(function (key) { exports[key] = d3Shape[key]; });
Object.keys(d3Time).forEach(function (key) { exports[key] = d3Time[key]; });
Object.keys(d3TimeFormat).forEach(function (key) { exports[key] = d3TimeFormat[key]; });
Object.keys(d3Timer).forEach(function (key) { exports[key] = d3Timer[key]; });
Object.keys(d3Transition).forEach(function (key) { exports[key] = d3Transition[key]; });
Object.keys(d3Voronoi).forEach(function (key) { exports[key] = d3Voronoi[key]; });
Object.keys(d3Zoom).forEach(function (key) { exports[key] = d3Zoom[key]; });
Object.defineProperty(exports, "event", {get: function() { return d3Selection.event; }});

},{"d3-array":42,"d3-axis":43,"d3-brush":44,"d3-chord":45,"d3-collection":46,"d3-color":47,"d3-dispatch":48,"d3-drag":49,"d3-dsv":50,"d3-ease":51,"d3-force":52,"d3-format":53,"d3-geo":54,"d3-hierarchy":55,"d3-interpolate":56,"d3-path":57,"d3-polygon":58,"d3-quadtree":59,"d3-queue":60,"d3-random":61,"d3-request":62,"d3-scale":63,"d3-selection":64,"d3-shape":65,"d3-time":67,"d3-time-format":66,"d3-timer":68,"d3-transition":69,"d3-voronoi":70,"d3-zoom":71}],73:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],74:[function(require,module,exports){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":171,"url":177}],75:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],76:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],77:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],78:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],79:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":110,"./_hashDelete":111,"./_hashGet":112,"./_hashHas":113,"./_hashSet":114}],80:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":118,"./_listCacheDelete":119,"./_listCacheGet":120,"./_listCacheHas":121,"./_listCacheSet":122}],81:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":107,"./_root":131}],82:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":123,"./_mapCacheDelete":124,"./_mapCacheGet":125,"./_mapCacheHas":126,"./_mapCacheSet":127}],83:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":82,"./_setCacheAdd":132,"./_setCacheHas":133}],84:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":131}],85:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],86:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":95}],87:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],88:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],89:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],90:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":141}],91:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":83,"./_arrayIncludes":86,"./_arrayIncludesWith":87,"./_arrayMap":88,"./_baseUnary":101,"./_cacheHas":102}],92:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],93:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":89,"./_isFlattenable":115}],94:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":84,"./_getRawTag":108,"./_objectToString":129}],95:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":92,"./_baseIsNaN":97,"./_strictIndexOf":136}],96:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":94,"./isObjectLike":150}],97:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],98:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":117,"./_toSource":137,"./isFunction":147,"./isObject":149}],99:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":130,"./_setToString":134,"./identity":142}],100:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":104,"./constant":138,"./identity":142}],101:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],102:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],103:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":131}],104:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":107}],105:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],106:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":116}],107:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":98,"./_getValue":109}],108:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":84}],109:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],110:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":128}],111:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],112:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":128}],113:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":128}],114:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":128}],115:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":84,"./isArguments":143,"./isArray":144}],116:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],117:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":103}],118:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],119:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":90}],120:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":90}],121:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":90}],122:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":90}],123:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":79,"./_ListCache":80,"./_Map":81}],124:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":106}],125:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":106}],126:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":106}],127:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":106}],128:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":107}],129:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],130:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":85}],131:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":105}],132:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],133:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],134:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":100,"./_shortOut":135}],135:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],136:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],137:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],138:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],139:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":149,"./now":152,"./toNumber":153}],140:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

},{"./_baseDifference":91,"./_baseFlatten":93,"./_baseRest":99,"./isArrayLikeObject":146}],141:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],142:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],143:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":96,"./isObjectLike":150}],144:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],145:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":147,"./isLength":148}],146:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":145,"./isObjectLike":150}],147:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":94,"./isObject":149}],148:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],149:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],150:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],151:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":94,"./isObjectLike":150}],152:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":131}],153:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":149,"./isSymbol":151}],154:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":155}],155:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],156:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],157:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],158:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],159:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":157,"./encode":158}],160:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":162,"./_stream_writable":164,"core-util-is":41,"inherits":76,"process-nextick-args":154}],161:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":163,"core-util-is":41,"inherits":76}],162:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":160,"./internal/streams/BufferList":165,"./internal/streams/destroy":166,"./internal/streams/stream":167,"_process":155,"core-util-is":41,"events":73,"inherits":76,"isarray":78,"process-nextick-args":154,"safe-buffer":170,"string_decoder/":168,"util":37}],163:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":160,"core-util-is":41,"inherits":76}],164:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":160,"./internal/streams/destroy":166,"./internal/streams/stream":167,"_process":155,"core-util-is":41,"inherits":76,"process-nextick-args":154,"safe-buffer":170,"timers":175,"util-deprecate":179}],165:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":170,"util":37}],166:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":154}],167:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":73}],168:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":170}],169:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":160,"./lib/_stream_passthrough.js":161,"./lib/_stream_readable.js":162,"./lib/_stream_transform.js":163,"./lib/_stream_writable.js":164}],170:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":39}],171:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":173,"./lib/response":174,"builtin-status-codes":40,"url":177,"xtend":181}],172:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],173:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":172,"./response":174,"_process":155,"buffer":39,"inherits":76,"readable-stream":169,"to-arraybuffer":176}],174:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":172,"_process":155,"buffer":39,"inherits":76,"readable-stream":169}],175:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":155,"timers":175}],176:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":39}],177:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":178,"punycode":156,"querystring":159}],178:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],179:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],180:[function(require,module,exports){
(function (process,Buffer){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url");
var spawn = require("child_process").spawn;


exports.XMLHttpRequest = function() {
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = require("http");
  var https = require("https");

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = {};
  var headersCase = {};

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error("SecurityError: Request method not allowed");
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn("Refused to set unsafe header \"" + header + "\"");
      return;
    }
    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send flag is true");
    }
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    if (typeof name === "string" && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    }

    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send has already been called");
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw new Error("XMLHttpRequest: Only GET method is supported");
      }

      if (settings.async) {
        fs.readFile(url.pathname, "utf8", function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name];
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ":" + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on("end", function() {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on("error", function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      var errorHandler = function errorHandler(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) {
        self.handleError(resp.err);
      } else {
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (state == self.LOADING || self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":155,"buffer":39,"child_process":38,"http":171,"https":74,"url":177}],181:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[33]);
</script>
    